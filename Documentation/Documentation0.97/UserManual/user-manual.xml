<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<article lang="en">
<articleinfo>
    <title>Larceny User Manual</title>


</articleinfo>
<section id="LarcenyChapter">
<title>Larceny</title>
<simpara>Larceny
implements the Scheme programming language
as defined by
<link linkend="Standards">IEEE Standard 1178-1990</link>,
the
<link linkend="Standards">Revised<superscript>5</superscript> Report</link>,
the
<link linkend="Standards">Revised<superscript>6</superscript> Report</link>,
and
<link linkend="Standards">ERR5RS</link>.
Those language standards serve as Larceny's primary documentation.</simpara>

<simpara>This manual describes aspects of Larceny that are not described
by the IEEE standard, the Revised Reports, or ERR5RS.
For the most current version of this manual, please see
<ulink url="http://larceny.ccs.neu.edu/doc">Larceny's online documentation page</ulink>.
For links to the Common Larceny User Manual and the Larceny
mailing list, please visit
<ulink url="http://larceny.ccs.neu.edu/">Larceny's main web page</ulink>.</simpara>

<simpara>To report bugs, please send email to the Larceny
developers at <literal>&lt;larceny@ccs.neu.edu&gt;</literal>, or submit a
bug ticket using Larceny's
<ulink url="http://larceny.ccs.neu.edu/trac/">Trac system</ulink>.</simpara>

</section>
<section id="InstallationChapter">
<title>Installing Larceny</title>
<section id="VarietiesSection">
<title>Varieties of Larceny</title>
<simpara>There are three main varieties of Larceny.</simpara>

<simpara>Native Larceny is the fastest and most convenient variety
of Larceny.  It compiles directly to native machine code
for Intel x86-32 or SPARC microprocessors running Windows,
Linux, MacOS X, or Solaris operating systems.</simpara>

<simpara>Petit Larceny compiles to C instead of machine code.  It
runs on most Unix machines, including PowerPC Macintoshes
with MacOS X.</simpara>

<simpara>Common Larceny compiles to JIT-compiled IL on Microsoft's
Common Language Runtime (CLR) or Mono.  It provides access
to the .NET libraries from Scheme.</simpara>

</section>
<section id="DownloadingSection">
<title>Downloading</title>
<simpara>The current versions of Larceny are available for
download at
<ulink url="http://larceny.ccs.neu.edu/">Larceny's main web page</ulink>.</simpara>

<simpara>Twobit and Larceny are distributed in two forms: as a precompiled
binary, or as source code that can be used to reconstruct
any of the precompiled binary distributions.
Unless you intend to modify Larceny yourself, you do not
need to download the source code.</simpara>

</section>
<section id="InstallationSection">
<title>Installing the programs</title>
<simpara>If you are installing or running Common Larceny, please
consult the
<ulink url="http://larceny.ccs.neu.edu">Common Larceny User Manual</ulink>
instead of becoming confused by the instructions in this
manual.</simpara>

<simpara>Unpack the distribution files with an appropriate command such
as one of the following:</simpara>

<literallayout class="monospaced">tar -xzf larceny-X.Y-bin-native-sparc-solaris.tar.gz
tar -xzf larceny-X.Y-bin-native-ia32-macosx.tar.gz
tar -xzf larceny-X.Y-bin-native-ia32-linux86.tar.gz
tar -xzf larceny-X.Y-bin-native-ia32-win32.tar.gz
tar -xzf larceny-X.Y-bin-petit-stdc-macosx.tar.gz
tar -xzf larceny-X.Y-src.tar.gz</literallayout>
<simpara>That will create a directory with a similar name (but without
the <literal>.tar.gz</literal> suffix) in your current working directory.
That is the Larceny root directory, which you may rename
to something shorter, such as <literal>larceny</literal>; the rest of this
section will refer to it by that name.</simpara>

<simpara>Assuming you have unpacked a binary distribution, the <literal>larceny</literal>
directory will contain the following files:</simpara>

<literallayout class="monospaced">larceny.bin         Run-time system
larceny.heap        Heap image with all libraries, FFI, and compiler
larceny             Shell script that runs larceny.heap
scheme-script       Shell script that runs Scheme scripts
compile-stale       Scheme script that compiles ERR5RS/R6RS libraries
startup.sch         Pathnames for the require and autoload features</literallayout>
<simpara>If you unpacked a binary distribution, then you should be able to
run it immediately by making the <literal>larceny</literal> directory your current
working directory and invoking <literal>./larceny</literal> or perhaps just <literal>larceny</literal>.</simpara>

<simpara>If you unpacked the source code there will be many other files and
directories, but <literal>larceny.bin</literal> and <literal>larceny.heap</literal> will not be present.</simpara>

<tip>
<simpara>You can reconstruct the <literal>larceny.bin</literal> and <literal>larceny.heap</literal> files from their
source code, but that process requires a working version of Larceny
or PLT Scheme v37x; unless you're porting Larceny or Petit Larceny to a
brand new target architecture, it's easier to obtain those
files from a binary distribution of Larceny.</simpara>

</tip>
<simpara>You may add the <literal>larceny</literal> directory to your standard path,
or you may install Larceny into a directory that is already
part of your standard path.</simpara>

<simpara>Suppose, for example, that you want to install Larceny
in <literal>/usr/local/bin</literal> and <literal>/usr/local/lib/larceny</literal>.
Copy <literal>larceny</literal> and <literal>scheme-script</literal> to <literal>/usr/local/bin</literal>
and edit the definition of <literal>LARCENY_PATH</literal> at the head
of each file to point to the correct directory:</simpara>

<literallayout class="monospaced">LARCENY_PATH=/usr/local/lib/larceny</literallayout>
<simpara>Then move the entire <literal>larceny</literal> directory to <literal>/usr/local/lib/larceny</literal>,
or copy <literal>larceny.bin</literal>, <literal>larceny.heap</literal>, <literal>startup.sch</literal>, and the <literal>lib</literal>
directory to <literal>/usr/local/lib/larceny</literal>.</simpara>

<simpara>You should now be able to run Larceny from any directory
by typing "<literal>larceny</literal>" at a prompt.</simpara>

</section>
<section id="CompilingStdLibSection">
<title>Compiling the R6RS standard libraries</title>
<simpara>Before you can run Larceny in ERR5RS or R6RS modes, you may
have to compile the ERR5RS/R6RS runtime and standard libraries.
This step is definitely required if you are using Petit Larceny
or building any variety of Larceny from source code.
With the prebuilt native varieties of Larceny, however, this step
should not be necessary unless you change one of the files in
<literal>lib/R6RS</literal> or <literal>lib/SRFI</literal>.</simpara>

<tip>
<simpara>If the <literal>lib/R6RS</literal> directory and its subdirectories are read-only,
then the standard libraries will not be touched, modified, or
recompiled by accident.</simpara>

</tip>
<simpara>Compiling the ERR5RS/R6RS runtime and standard libraries is
accomplished as follows:</simpara>

<screen>    $ ./larceny
    Larceny v0.96 "Fluoridation" (...)
    &gt; (require 'r6rsmode)
    &gt; (larceny:compile-r6rs-runtime)
    &gt; (exit)</screen>
<warning>
<simpara>Compiling the ERR5RS/R6RS runtime as shown above causes
all previously compiled ERR5RS/R6RS libraries and top-level
programs to become <link linkend="CompilingChapter">stale</link>.  That means
those previously compiled files will need to be recompiled
or removed.</simpara>

</warning>
</section>
</section>
<section id="RunningChapter">
<title>Running Larceny</title>
<simpara>Larceny runs in any of four distinct modes:</simpara>

<literallayout class="monospaced">R5RS              traditional read/eval/print loop (the default)
ERR5RS            ERR5RS read/eval/print loop
R6RS              batch execution of R6RS top-level programs
Scheme script     batch execution of R6RS Scheme scripts</literallayout>
<simpara>These modes correspond to the four distinct kinds of Scheme
programs that are described by the current de facto standards
for Scheme.  (IEEE/ANSI Std 1178 is so similar to the R5RS
standard that Larceny implements both languages in R5RS mode.)</simpara>

<section id="R5rsSection">
<title>R5RS mode</title>
<simpara>When you start Larceny in R5RS mode (the default), you
will be presented with a banner message and the
read-eval-print loop's prompt:</simpara>

<screen>    % larceny
    Larceny vX.Y "&lt;version_name&gt;" (MMM DD YYYY HH:MM:SS, ...)
    larceny.heap, built ...

    &gt;</screen>
<simpara>You can enter a Scheme expression at the prompt.
After a complete expression has been read, it will
be evaluated and its results printed.</simpara>

<note>
<simpara>In native Larceny, the expression is evaluated by
compiling it to native machine code, which is then executed.
In Petit Larceny, the expression is evaluated by
an interpreter because compiling to C, running the
C compiler, and loading the compiled C code would
take too long.  Interpreted code behaves like compiled code,
so most of what this manual says about the compiler is also
true of Petit Larceny's interpreter.</simpara>

</note>
<simpara>By default, Larceny's Twobit compiler makes several
assumptions that allow it to generate faster code;
for example, the compiler assumes Scheme's standard
procedures will not be redefined.
To obtain strict conformance to R5RS semantics, see
the section of this user manual devoted to
<link linkend="PerformanceSection">performance</link>.</simpara>

</section>
<section id="Err5rsSection">
<title>ERR5RS mode</title>
<simpara>To interact with Larceny's ERR5RS read/eval/print loop,
specify the <literal>-err5rs</literal> option on Larceny's command line:</simpara>

<screen>    % larceny -err5rs
    Larceny v0.95 "First Safety" (...)
    ERR5RS mode (no libraries have been imported)</screen>
<simpara>Since no libraries have been imported, the only forms you
can evaluate are constant literals, variable references
(but no variables have been imported!), procedure calls
(but no procedure values are accessible!), library
definitions, and import forms.  The first thing you'll
want to do is to import some libraries, such as:</simpara>

<screen>    &gt; (import (rnrs base)
              (rnrs io simple)
              (err5rs records syntactic))</screen>
<simpara>Once you have imported <literal>(rnrs base)</literal> or a composite library
that includes it, you can evaluate definitions and use
all other syntax and variables you have imported.</simpara>

<section id="Err5rsAutomaticLoadingSection">
<title>Automatic loading</title>
<simpara>As an extension to ERR5RS, Larceny attempts to load
libraries automatically when they are first imported.
Autoloading makes interactive development and
<link linkend="CompilingChapter">separate compilation</link>
much more convenient.</simpara>

<simpara>All of Larceny's
<link linkend="Err5rsPreDefinedSection">predefined libraries</link>
can be autoloaded.</simpara>

<simpara>To enable autoloading of other ERR5RS/R6RS libraries,
you can:</simpara>

<itemizedlist>
<listitem>
<simpara>
use the <link linkend="R6RSLibraryPathSection"><literal>-path</literal> command-line option</link>
</simpara>
</listitem>
<listitem>
<simpara>
use the <link linkend="R6RSLibraryVariableSection"><literal>LARCENY_LIBPATH</literal></link> environment variable
</simpara>
</listitem>
<listitem>
<simpara>
use <link linkend="current-require-path"><literal>current-require-path</literal></link>
</simpara>
</listitem>
<listitem>
<simpara>
edit <literal>startup.sch</literal> in Larceny's root directory
</simpara>
</listitem>
<listitem>
<simpara>
add the libraries to Larceny's <literal>lib</literal> directory
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="Err5rsDynamicLoadingSection">
<title>Dynamic loading</title>
<simpara>Larceny automatically loads ERR5RS/R6RS libraries when
they are first imported.  This is usually the most
convenient way to load a library, but autoloading
can't be used to load a top-level program.  Explicit
loading is needed for top-level programs, for libraries
that don't reside in Larceny's
<link linkend="current-require-path"><literal>current-require-path</literal></link>,
and for libraries that are defined in files whose names
do not follow Larceny's
<link linkend="NamingChapter">standard naming conventions</link>.</simpara>

<simpara>Explicit loading is the only portable way for ERR5RS
programs to load a library.</simpara>

<simpara>Explicit loading also makes it possible to write portable
programs whose source files conform to both the R5RS and
ERR5RS.  Two different configuration files, one for the
R5RS and one for ERR5RS, can perform all of the imports
and loads needed to run the program.</simpara>

<simpara>For explicit loading of nonstandard libraries, top-level
programs, or unadorned R5RS-style code from a file, you
must first import a suitable load procedure:</simpara>

<screen>    &gt; (import (err5rs load))</screen>
<simpara>Loading a library does not automatically import it.
To use the variables and syntax that are exported by a
library, you must import that library explicitly:</simpara>

<screen>    &gt; (load "lib/R6RS/larceny/benchmarking.sls")
    &gt; (import (larceny benchmarking))
    &gt; (time (vector-for-each + (make-vector 1000000 0)))
    Words allocated: 3095752
    Words reclaimed: 0
    Elapsed time...: 111 ms (User: 104 ms; System: 8 ms)
    Elapsed GC time: 4 ms (CPU: 4 in 8 collections.)</screen>
<simpara>In Larceny, you may omit the call to <literal>load</literal> because the
<literal>(larceny benchmarking)</literal> library will be autoloaded when
it is imported.  In other ERR5RS systems, however, you
may have to load all of the nonstandard libraries that will
be imported by a top-level program or library before you
load that top-level program or library.</simpara>

<simpara>You do not have to import those libraries into the ERR5RS
top level, however, unless you want to use the variables
and syntax exported by those libraries in the expressions
and definitions you evaluate at the top level.</simpara>

</section>
<section id="Err5rsPreDefinedSection">
<title>Predefined libraries</title>
<simpara>Larceny predefines several nonstandard libraries in addition
to the standard ERR5RS and R6RS libraries, and autoloads them
for your convenience.  The predefined, autoloadable libraries
include:</simpara>

<simpara>R6RS standard libraries:</simpara>

<literallayout class="monospaced">(rnrs base (6))                        ; R6RS chapter 9
(rnrs unicode (6))                     ; R6RS library chapter 1
(rnrs bytevectors (6))                 ; R6RS library chapter 2
(rnrs lists (6))                       ; R6RS library chapter 3
(rnrs sorting (6))                     ; R6RS library chapter 4
(rnrs control (6))                     ; R6RS library chapter 5
(rnrs exceptions (6))                  ; R6RS library section 7.1
(rnrs conditions (6))                  ; R6RS library sections 7.2 and 7.3
(rnrs io ports (6))                    ; R6RS library sections 8.1 and 8.2
(rnrs io simple (6))                   ; R6RS library sections 8.1 and 8.3
(rnrs files (6))                       ; R6RS library chapter 9
(rnrs programs (6))                    ; R6RS library chapter 10
(rnrs arithmetic fixnums (6))          ; R6RS library section 11.2
(rnrs arithmetic flonums (6))          ; R6RS library section 11.3
(rnrs arithmetic bitwise (6))          ; R6RS library section 11.4
(rnrs syntax-case (6))                 ; R6RS library chapter 12
(rnrs hashtables (6))                  ; R6RS library chapter 13
(rnrs enums)                           ; R6RS library chapter 14
(rnrs (6))                             ; R6RS library chapter 15
(rnrs eval (6))                        ; R6RS library chapter 16
(rnrs mutable-pairs (6))               ; R6RS library chapter 17
(rnrs mutable-strings (6))             ; R6RS library chapter 18
(rnrs r5rs (6))                        ; R6RS library chapter 19</literallayout>
<simpara>R6RS standard libraries that are autoloadable but deprecated in Larceny:</simpara>

<literallayout class="monospaced">(rnrs records procedural (6))          ; R6RS library section 6.3
(rnrs records inspection (6))          ; R6RS library section 6.4
(rnrs records syntactic (6))           ; R6RS library section 6.2</literallayout>
<simpara>SRFI libraries (which follow the SRFI 97 naming convention):</simpara>

<literallayout class="monospaced">(srfi :1 lists)                        ; list library
(srfi :2 and-let*)                     ; extended `and` and `let*`
(srfi :5 let)                          ; extended version of `let`
(srfi :6 basic-string-ports)           ; basic string ports
(srfi :8 receive)                      ; binding to multiple values
(srfi :9 records)                      ; defining record types
(srfi :11 let-values)                  ; syntax for multiple values
(srfi :13 strings)                     ; string libraries
(srfi :14 char-set)                    ; character-set library
(srfi :16 case-lambda)                 ; syntax for variable arity
(srfi :17 generalized-set!)            ; generalized set!
(srfi :19 time)                        ; time data types and procedures
(srfi :23 error)                       ; error reporting mechanism
(srfi :25 multi-dimensional-arrays)    ; multi-dimensional array primitives
(srfi :26 cut)                         ; specializing without currying
(srfi :27 random-bits)                 ; sources of random bits
(srfi :28 basic-format-strings)        ; basic format strings
(srfi :29 localization)                ; localization
(srfi :38 with-shared-structure)       ; i/o for data with shared structure
(srfi :39 parameters)                  ; parameter objects
(srfi :41 streams)                     ; streams
(srfi :42 eager-comprehensions)        ; eager comprehensions
(srfi :43 vectors)                     ; vector library
(srfi :45 lazy)                        ; iterative lazy algorithms
(srfi :48 intermediate-format-strings) ; format
(srfi :51 rest-values)                 ; rest values hackery
(srfi :54 cat)                         ; still more formatting
(srfi :59 vicinities)                  ; vicinity
(srfi :61 cond)                        ; a more general cond clause
(srfi :63 arrays)                      ; homogeneous, heterogeneous arrays
(srfi :64 testing)                     ; an API for test suites
(srfi :67 compare-procedures)          ; three-way comparison procedures
(srfi :78 lightweight-testing)         ; lightweight testing
(srfi :87 case)                        ; a more general case clause
(srfi :98 os-environment-variables)    ; environment variables
(srfi :99 records)                     ; ERR5RS records (composite library)
(srfi :99 records procedural)          ; ERR5RS records (procedural API)
(srfi :99 records inspection)          ; ERR5RS records (inspection API)
(srif :99 records syntactic)           ; ERR5RS records (syntactic API)</literallayout>
<simpara>SRFI libraries that are autoloadable but deprecated in Larceny,
usually because they have been superseded in whole or in part by
R6RS syntax or libraries:</simpara>

<literallayout class="monospaced">(srfi :60 integer-bits)                ; integers as bits
(srfi :66 octet-vectors)               ; octet vectors
(srfi :69 basic-hash-tables)           ; basic hash tables
(srfi :71 let)                         ; extensions of let, let*, letrec
(srfi :74 blobs)                       ; octet-addressed binary blocks
(srfi :86 mu-and-nu)                   ; mu and nu simulating values etc
(srfi :95 sorting-and-merging)         ; sorting and merging</literallayout>
<simpara>Other autoloadable libraries:</simpara>

<literallayout class="monospaced">(err5rs records procedural)            ; ERR5RS records (procedural API)
(err5rs records inspection)            ; ERR5RS records (inspection API)
(err5rs records syntactic)             ; ERR5RS records (syntactic API)
(err5rs load)                          ; ERR5RS load procedure
(rnrs load)                            ; equivalent to (err5rs load)
(larceny load)                         ; extension of (err5rs load)
(larceny compiler)                     ; separate compilation (ERR5RS/R6RS)
(larceny benchmarking)                 ; timing facilities
(larceny profiling)                    ; profiling of Scheme code
(larceny records printer)              ; custom printing of records
(larceny shivers-syntax)               ; syntax favored by Olin Shivers
(r5rs)                                 ; approximates the R5RS top level
(explicit-renaming)                    ; macros with explicit renaming</literallayout>
</section>
<section id="ERR5RSLibraryPathSection">
<title>Library path</title>
<simpara>Larceny's autoload feature locates ERR5RS/R6RS libraries
by performing a depth-first search of the directories
that belong to Larceny's
<link linkend="current-require-path"><literal>current-require-path</literal></link>.
Libraries will not be autoloaded unless they are defined
in files whose names follow
<link linkend="LibraryTranslationSection">Larceny's standard conventions</link>.</simpara>

<simpara>The
<link linkend="current-require-path"><literal>current-require-path</literal></link>
is initialized by the <literal>startup.sch</literal> file in Larceny's root
directory.</simpara>

<simpara><link linkend="R6RSLibraryPathSection">Larceny's <literal>-path</literal> command-line option</link>
adds one or more directories to the directories in the
<link linkend="current-require-path"><literal>current-require-path</literal></link>.</simpara>

<simpara>The <link linkend="R6RSLibraryVariableSection"><literal>LARCENY_LIBPATH</literal></link>
environment variable can also be used to add one or more directories
to the directories in the
<link linkend="current-require-path"><literal>current-require-path</literal></link>.</simpara>

</section>
<section id="ERR5RSprimitivesSection">
<title>Importing Larceny's standard procedures</title>
<simpara>Any of Larceny's R5RS-mode top-level procedures can be imported
into an ERR5RS or R6RS library or program by using an import
declaration with a <literal>primitives</literal> clause that names the R5RS
procedures to be imported.  For example:</simpara>

<screen>    (import (primitives random current-seconds
                        getenv setenv system
                        current-directory file-modification-time
                        system-features vector-like-cas!)
            (rnrs base)
            (rnrs control))</screen>
<warning>
<simpara>This feature is non-portable.
Other implementations of ERR5RS or the R6RS may not even
have an underlying implementation of the R5RS.</simpara>

</warning>
</section>
</section>
<section id="R6rsSection">
<title>R6RS mode</title>
<simpara>To execute a top-level R6RS program that is contained
within a file named <literal>pgm</literal>, type:</simpara>

<screen>    larceny -r6rs -program pgm</screen>
<simpara>The <literal>-program</literal> option can be omitted, in which case
Larceny will read the top-level program from standard
input:</simpara>

<screen>    larceny -r6rs &lt; pgm</screen>
<simpara>If you omit the <literal>-program</literal> option and do not redirect
standard input, then Larceny will wait patiently
for you to type a complete top-level program into
standard input, terminating it with an end-of-file.</simpara>

<simpara>You probably don't want to do that.  Had you wanted
to type R6RS code at Larceny, you'd be using ERR5RS
mode instead.</simpara>

<simpara>By default, Larceny's Twobit compiler uses settings
that make good sense for production code but violate
some absolute requirements of the R6RS.  For maximal
adherence to R6RS requirements (at the expense of
portability, interoperability, and/or performance),
see the discussion of
<link linkend="compiler-switches"><literal>compiler-switches</literal></link>
in the section on the
<link linkend="LarcenyCompilerSection"><literal>(larceny compiler)</literal></link>
library.</simpara>

<section id="R6rsPreDefinedSection">
<title>Predefined libraries</title>
<simpara>The R6RS standard does not specify any way for a
top-level program to define its own libraries.
Portable R6RS programs are therefore limited to
importing a subset of the R6RS standard libraries.</simpara>

<simpara>As an extension to the R6RS, Larceny allows R6RS
top-level programs and Scheme scripts to import
any libraries that are
<link linkend="Err5rsPreDefinedSection">predefined in Larceny's ERR5RS mode</link>.</simpara>

</section>
<section id="R6RSLibraryPathSection">
<title>Library path</title>
<simpara>As another extension to the R6RS, Larceny allows
R6RS top-level programs to import any libraries
that can be found in the directories specified by the
<literal>-path</literal> option on Larceny's command line using
<link linkend="LibraryTranslationSection">Larceny's standard translation</link>
from library names to file names.
On most systems, you can specify multiple directories
by separating them with a colon; under Windows, use a
semicolon as separator instead.  The first directory
listed will be searched first.</simpara>

<tip>
<simpara>If you have a set of portable libraries that run under more than
one implementation of the R6RS, and you want to have a special
version of some of those libraries for Larceny, you can put all
your portable versions in one directory and the Larceny-specific
versions in another.  When you run Larceny, use the <literal>-path</literal>
option and specify the Larceny-specific directory first.</simpara>

</tip>
<note>
<simpara>The <literal>-path</literal> option cannot be used by Scheme scripts,
because command-line options are passed along to the Scheme
script without being interpreted by the <literal>scheme-script</literal> processor.</simpara>

</note>
<warning>
<simpara>We emphasize that this extension is non-portable.
Other implementations of the R6RS may not provide
anything comparable to Larceny's <literal>-path</literal> option.
Even if they do, their mappings from library names
to file names may be incompatible with Larceny's.</simpara>

</warning>
</section>
<section id="R6RSLibraryVariableSection">
<title>Library environment variable</title>
<simpara>As another extension to the R6RS, Larceny allows
R6RS top-level programs to import any libraries
that can be found in directories specified by the
<literal>LARCENY_LIBPATH</literal> environment variable.
The value of that environment variable should be
a string in the same format as for Larceny's <literal>-path</literal>
command-line option, described above.</simpara>

<warning>
<simpara>We emphasize that this extension is non-portable.
Other implementations of the R6RS may not support
anything comparable to Larceny's <literal>LARCENY_LIBPATH</literal>
environment variable.
Even if they do, their mappings from library names
to file names may be incompatible with Larceny's.</simpara>

</warning>
</section>
<section id="DefiningLibrariesSection">
<title>Defining libraries</title>
<simpara>As an extension to the R6RS, Larceny allows a top-level
program or Scheme script to define R6RS libraries within
the file that contains the top-level program or Scheme
script, before the import form that begins the top-level
program.  These libraries must be arranged so that no
library depends upon libraries that come later in the
file.</simpara>

<warning>
<simpara>We emphasize that this extension is non-portable.
Other implementations of the R6RS may not allow
R6RS programs to define their own libraries.</simpara>

</warning>
</section>
<section>
<title>Importing procedures from Larceny's underlying R5RS system</title>
<simpara>As an extension to the R6RS, Larceny allows any of the
procedures that are predefined at top level in Larceny's
R5RS mode to be imported by using
<link linkend="ERR5RSprimitivesSection">a <literal>primitives</literal> clause</link>
in an <literal>import</literal> declaration.</simpara>

<warning>
<simpara>This extension is highly non-portable.
Other implementations of the R6RS may not even
have an underlying implementation of the R5RS.</simpara>

</warning>
</section>
</section>
<section id="SchemeScriptsSection">
<title>Scheme scripts</title>
<simpara>On most Unix systems (including MacOS X and Linux), Larceny's
<literal>scheme-script</literal> will execute Scheme scripts as described in R6RS
non-normative appendix D, with or without the optional script
header.  To make Scheme scripts executable in their own
right, without executing <literal>scheme-script</literal> directly, add Larceny's
root directory to your path as described in <literal>doc/HOWTO-INSTALL</literal>.</simpara>

<simpara>Suppose, for example, that <literal>/home/myself/hello</literal> is an R6RS
Scheme script whose first line is the optional script header
shown below:</simpara>

<screen>#!/usr/bin/env scheme-script</screen>
<simpara>If you do not have execute permission for this script,
or Larceny's root directory is not in your path,
you can still run the script from
Larceny's root directory as follows:</simpara>

<screen>    % ./scheme-script /home/myself/hello</screen>
<simpara>If you have execute permission for the script, and Larceny's
root directory is in your path, you can also run the
script as follows:</simpara>

<screen>    % /home/myself/hello</screen>
<simpara>If, in addition, the directory that contains the script is
in your path, you can run the script as follows:</simpara>

<screen>    % hello</screen>
<simpara>You may also pass command-line arguments to a Scheme script.</simpara>

<warning>
<simpara>We emphasize that Scheme scripts are not portable.
Scheme scripts are specified only by a non-binding appendix
to the R6RS, not by the R6RS proper.
Other implementations of the R6RS may not support Scheme
scripts at all, or may give them a semantics incompatible
with Larceny's.</simpara>

</warning>
<simpara>On Unix systems, standard input and output can be redirected
in the usual way.  In Larceny, standard input corresponds to
the textual port initially returned by <literal>current-input-port</literal>,
and standard output corresponds to the textual port initially
returned by <literal>current-output-port</literal>.</simpara>

<warning>
<simpara>We emphasize that redirection of standard input and output
is non-portable.
Other implementations of the R6RS may not allow redirection,
or may identify the standard input and output with ports
other than those initially returned by <literal>current-input-port</literal>
and <literal>current-output-port</literal>.</simpara>

</warning>
</section>
<section id="R5rsScriptSection">
<title>R5RS scripting</title>
<simpara>Suppose <literal>hello.sch</literal> contains the following R5RS code:</simpara>

<screen>    (display "Hello world!")
    (newline)
    (exit)</screen>
<simpara>You can run <literal>hello.sch</literal> as a script by executing Larceny as
follows:</simpara>

<screen>    % larceny -nobanner -- hello.sch</screen>
<simpara>You can redirect Larceny's standard input, in which case
you may want to eliminate the herald announcement and the
read/eval/print loop's prompt:</simpara>

<screen>    % larceny -nobanner -- -e "(begin (herald #f) (repl-prompt values))" \
              &lt; hello.sch</screen>
<simpara>For an explanation of why that works, which may suggest other
creative uses of Larceny, ask for help:</simpara>

<screen>    % larceny -help</screen>
</section>
<section id="ErrorsSection">
<title>Errors</title>
<simpara>In R6RS modes, errors should result in an error message
followed by a clean exit from the program.</simpara>

<simpara>If your program encounters an error in an interactive mode
(R5RS or ERR5RS), it will enter the debugger; this is
believed to be a feature.</simpara>

<simpara>Despite its crudity, and to some extent because of it,
Larceny's debugger works at least as well with optimized
compiled code as with interpreted code.</simpara>

<simpara>If you type a question mark at the debugger prompt, the
debugger will print a help message.  That message is more
helpful if you understand the Twobit compiler and
Larceny's internal representations and invariants, but
this manual is not the place to explain those things.</simpara>

<simpara>The debugging context is saved so you can exit the debugger
and re-enter it from the main read/eval/print loop's prompt:</simpara>

<screen>    &gt; (debug)</screen>
<simpara>The debugger is pretty much a prototype; you don't need to
tell us how bad it is.</simpara>

</section>
<section>
<title>Troubleshooting</title>
<section>
<title>Errors when starting Larceny</title>
<simpara>When attempting to run an R6RS program, you may see
a warning about "<literal>loading source in favor of stale
fasl file</literal>",
following by a long series of error messages about
syntactic keywords used as a variable, ending with
the kind of error you'd expect to see when a large
R6RS program is fed to a Scheme compiler that was
expecting to see R5RS-compatible code.  That means
the R6RS runtime and standard libraries were not
installed correctly, or their source files have been
touched or modified since they were last compiled.
To fix the problem,
<link linkend="CompilingStdLibSection">recompile the R6RS standard libraries</link> as described in step 4 of <literal>doc/HOWTO-BUILD</literal>.</simpara>

<simpara>The precompiled binary forms of Larceny should run on
most machines with the appropriate processor and operating
system, but the executable program "<literal>larceny.bin</literal>" may be
incompatible with very old or with very new versions of
the processor or operating system.  If that appears to be
the case, you should see whether a newer version of Larceny
fixes the problem.  If not, please report the problem
to us at <literal>larceny@ccs.neu.edu</literal>.
Please report success stories as well.</simpara>

</section>
<section>
<title>Errors when compiling the ERR5RS/R6RS runtime</title>
<simpara>If something goes wrong while
<link linkend="CompilingStdLibSection">compiling the ERR5RS/R6RS runtime</link>,
make sure you are running the copy of Larceny you think
you are running and have read and write permission
for <literal>lib/R6RS</literal>, <literal>lib/SRFI</literal>, and all their subdirectories and files.
If you get an error message about something being
"<literal>expanded against a different build of this library</literal>",
then one or more of the compiled files in <literal>lib/R6RS</literal> or <literal>lib/SRFI</literal>
or its subdirectories has gone
<link linkend="CompilingChapter">stale</link>.
Removing all <literal>.slfasl</literal> files from <literal>lib/R6RS</literal> and <literal>lib/SRFI</literal> and
their subdirectories will eliminate the stale file(s).</simpara>

<warning>
<simpara>Don't remove the <literal>.sch</literal> or <literal>.sls</literal> files.</simpara>

</warning>
</section>
<section id="AutoLoadErrorsSection">
<title>Autoloading errors</title>
<simpara>If Larceny attempts to autoload an imported ERR5RS/R6RS
library but cannot find the library, then the library
may be defined in a file that doesn't follow
<link linkend="NamingChapter">Larceny's standard naming conventions</link>.
Another possibility is that the <literal>-path</literal> option was
omitted or incorrect.</simpara>

<simpara>If an ERR5RS/R6RS library is compiled, then all compiled
libraries and top-level programs that depend upon it must
also be recompiled.  In particular, recompiling the standard
R6RS runtime will invalidate all compiled libraries and
top-level programs.  Larceny's <literal>compile-stale</literal> script
and the
<link linkend="compile-stale-libraries"><literal>compile-stale-libraries</literal></link>
procedure of <literal>(larceny compiler)</literal> make it convenient
to recompile all of the libraries and top-level
programs within any given directory in an order
consistent with their dependencies.</simpara>

</section>
<section id="CrashesSection">
<title>Crashes</title>
<simpara>Please report all crashes with as much information is possible;
a backtrace from a debugger or a core dump is ideal (but please
do not mail the core dump without contacting us first).
Larceny's run-time system is compiled with full debugging
information by default and a debugger like GDB should be able
to provide at least some clues.</simpara>

</section>
</section>
<section id="PerformanceSection">
<title>Performance</title>
<simpara>By default, Larceny's Twobit compiler makes several
assumptions that allow it to generate faster code;
for example, the compiler assumes Scheme's standard
procedures will not be redefined.</simpara>

<simpara>To disable certain compiler optimizations that are
incompatible with the R6RS, see the section that
describes the
<link linkend="LarcenyCompilerSection"><literal>(larceny compiler)</literal> library</link>.</simpara>

<simpara>To obtain strict conformance to R5RS semantics at
the expense of slower code, evaluate the expression</simpara>

<screen>    (compiler-switches 'standard)</screen>
<simpara>To make the compiler generate faster code, you can promise not to
redefine standard procedures <emphasis>and</emphasis> not to redefine any top-level
procedure while it is running. To make this promise, evaluate</simpara>

<screen>        (compiler-switches 'fast-safe)</screen>
<simpara>To view the current settings of Twobit's numerous compiler switches,
evaluate</simpara>

<screen>        (compiler-switches)</screen>
<simpara>All of Twobit's compiler switches are procedures whose setting
can be changed by passing the new value of the switch as an
argument.</simpara>

<simpara>For more information, evaluate</simpara>

<screen>        (help)</screen>
<note>
<simpara>Some of the help information that will be printed may be
irrelevant to the heap image you are using.</simpara>

</note>
</section>
</section>
<section id="LexicalChapter">
<title>Lexical syntax</title>
<simpara>Larceny's default lexical syntax extends the lexical syntax
required by the R5RS, R6RS, and ERR5RS <link linkend="Standards">standards</link>.</simpara>

<simpara>The R6RS forbids most lexical extensions, however, so Larceny
provides several mechanisms for turning its lexical extensions
on and off.</simpara>

<section id="FlagsSection">
<title>Flags</title>
<simpara>By default, Larceny recognizes several Larceny-specific flags
of the form permitted by the R6RS.  The flag you are most
likely to encounter represents one of Larceny's unspecified
values:</simpara>

<screen>    #!unspecified</screen>
<simpara>Certain other flags have special meanings to Larceny's
<literal>read</literal> and <literal>get-datum</literal> procedures.  They are described below.</simpara>

</section>
<section id="CaseFoldingSection">
<title>Case-sensitivity</title>
<simpara>By default, Larceny is case-sensitive.
This global default can be overridden by specifying
<literal>&#8212;foldcase</literal> or <literal>&#8212;nofoldcase</literal> on Larceny's command line,
or by changing the value of Larceny's <literal>case-sensitive?</literal> parameter.</simpara>

<simpara>The case-sensitivity of a particular textual input port
is affected by reading one of the following flags from
the port using the <literal>read</literal> or <literal>get-datum</literal> procedures:</simpara>

<screen>    #!fold-case
    #!no-fold-case</screen>
<simpara>The <literal>#!fold-case</literal> flag enables case-folding on data read from
the port by the <literal>read</literal> and <literal>get-datum</literal> procedures, while the
<literal>#!no-fold-case</literal> flag disables case-folding.  The behavior
established by one of these flags extends to the next flag
read from the port by <literal>read</literal> or <literal>get-datum</literal>.</simpara>

<simpara>Both <literal>#!fold-case</literal> and <literal>#!no-fold-case</literal> evaluate to an
unspecified value.  To obtain the effect of one of these flags
while treating it as a comment, place <literal>#;</literal> in front of the flag.</simpara>

</section>
<section id="LexicalExtensionsSection">
<title>Lexical extensions</title>
<simpara>When a port is first opened, the Larceny-specific lexical
extensions that are accepted on the port are determined
by Larceny's <link linkend="LexicalParametersSection">lexical parameters</link>.</simpara>

<simpara>The following flags change the case-sensitivity and lexical
extensions on the specific port from which they are read:</simpara>

<screen>    #!r6rs         ; implies #!no-fold-case, negates other flags
    #!r5rs         ; implies #!fold-case, #!err5rs
    #!err5rs       ; allows Larceny-specific extensions
    #!larceny      ; implies #!no-fold-case, #!err5rs</screen>
<simpara>The <literal>#!r6rs</literal> flag is a comment, while all of Larceny's other
flags evaluate to an unspecified value.  To obtain the effect
of a flag other than <literal>#!r6rs</literal> while treating it as a comment,
place <literal>#;</literal> in front of the flag.</simpara>

<warning>
<simpara>The R6RS requires implementations to treat <literal>#!r6rs</literal> as a
comment; it is the only flag that implementations of the R6RS
are required to treat as a comment.  Since the <literal>#!r6rs</literal> flag
behaves differently from all other flags, it is deprecated.</simpara>

</warning>
</section>
<section id="LexicalParametersSection">
<title>Lexical parameters</title>
<simpara>When given no argument, these parameters return the current
default for some aspect of the lexical syntax that will be
accepted on newly created ports.
When given an argument, these procedures change the default
as specified by the argument.</simpara>

<simpara><anchor id="case-sensitive?" xreflabel="case-sensitive?"></anchor>
<emphasis> Procedure case-sensitive?</emphasis>
<simpara>
<indexterm><primary><code>case-sensitive?</code></primary></indexterm>
<literal>(case-sensitive? <emphasis></emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara>
<simpara><literal>(case-sensitive? <emphasis>boolean</emphasis>) </literal></simpara></simpara>

<simpara>Determines whether newly created textual ports default to
case-sensitive.</simpara>

<simpara><anchor id="read-larceny-weirdness?" xreflabel="read-larceny-weirdness?"></anchor>
<emphasis> Procedure read-larceny-weirdness?</emphasis>
<simpara>
<indexterm><primary><code>read-larceny-weirdness?</code></primary></indexterm>
<literal>(read-larceny-weirdness? <emphasis></emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara>
<simpara><literal>(read-larceny-weirdness? <emphasis>boolean</emphasis>) </literal></simpara></simpara>

<simpara>Determines whether newly created textual ports allow
Larceny's usual extensions to R5RS lexical syntax.
This parameter also determines whether newly created
ports allow <literal>#</literal> as an insignificant digit; this is
required by the R5RS, but disallowed by the R6RS.</simpara>

<simpara><anchor id="read-traditional-weirdness?" xreflabel="read-traditional-weirdness?"></anchor>
<emphasis> Procedure read-traditional-weirdness?</emphasis>
<simpara>
<indexterm><primary><code>read-traditional-weirdness?</code></primary></indexterm>
<literal>(read-traditional-weirdness? <emphasis></emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara>
<simpara><literal>(read-traditional-weirdness? <emphasis>boolean</emphasis>) </literal></simpara></simpara>

<simpara>Determines whether newly created textual ports allow
certain lexical extensions that are deprecated in Larceny.
These extensions include symbols enclosed by vertical
bars and read-time evaluation.</simpara>

<simpara>For the current semantics of these parameters, please consult
the Larceny developers' web page that describes
<ulink url="https://github.com/larcenists/larceny/wiki/LexicalConversion">Larceny's
lexical syntax</ulink>.</simpara>

</section>
</section>
<section id="NamingChapter">
<title>File naming conventions</title>
<section id="SuffixSection">
<title>Suffixes</title>
<simpara>In Larceny, file names generally follow Unix conventions,
even on Windows.  The following suffixes have special
meanings to some components of Larceny.</simpara>

<simpara><literal>.sls</literal>
is the preferred suffix for files that consist
of ERR5RS/R6RS-compatible library definitions.</simpara>

<simpara><literal>.sch</literal>
is the preferred suffix for files that contain R5RS
source code.</simpara>

<simpara><literal>.scm</literal>
is an alternative suffix for files that contain R5RS source code.</simpara>

<simpara><literal>.slfasl</literal>
is the suffix for files that contain the pre-compiled
form of ERR5RS/R6RS-compatible code.</simpara>

<simpara><literal>.fasl</literal>
is the suffix for files that contain the pre-compiled form of R5RS code.</simpara>

<simpara><literal>.mal</literal>
is the preferred suffix for files that contain MacScheme
assembly language in symbolic form.</simpara>

<simpara><literal>.lap</literal>
is the suffix for files that contain MacScheme assembly language.</simpara>

<simpara><literal>.lop</literal>
is the suffix for files that contain machine code
segments in the form expected by Larceny's heap linker.</simpara>

<simpara><literal>.heap</literal>
is the suffix for files that contain an executable heap
image (must be combined with the
<link linkend="InstallationSection"><literal>larceny.bin</literal></link> runtime).</simpara>

</section>
<section id="DirectorySection">
<title>Directories</title>
<simpara>Larceny's root directory should contain the following
files:</simpara>

<screen>    larceny
    scheme-script
    larceny.bin
    larceny.heap
    startup.sch</screen>
<simpara>The following subdirectories are also essential for correct
operation of some features of some modes in some varieties of
Larceny:</simpara>

<screen>    include
    lib
    lib/Base
    lib/Debugger
    lib/Ffi
    lib/MzScheme
    lib/R6RS
    lib/SRFI
    lib/Standard
    lib/TeachPacks</screen>
<simpara>The <literal>include</literal> subdirectory is used when compiling files with
Petit Larceny.</simpara>

<simpara>The <literal>startup.sch</literal> file tells Larceny's <literal>require</literal> procedure to
search some of the <literal>lib</literal> subdirectories for libraries that are
loaded dynamically.</simpara>

</section>
<section id="LibraryResolutionSection">
<title>Resolving references to libraries</title>
<simpara>The R6RS does not specify any mapping from library names to
files or to other locations at which the code for a library
might be found.  As R6RS non-normative appendix E puts it:</simpara>

<blockquote>
<attribution>
</attribution>
<simpara>Implementations may take radically different approaches to
storing source code for libraries, among them: files in the
file system where each file contains an arbitrary number of
library forms, files in the file system where each file
contains exactly one library form, records in a database,
and data structures in memory&#8230;.Implementations may provide
a means for importing libraries&#8230;.</simpara>

</blockquote>
<simpara>In other words, implementations are allowed to extend the
R6RS with arbitrary mechanisms for resolving references to
imported libraries, but R6RS programs that rely on such
mechanisms are not portable.  In particular, R6RS libraries
are not portable.</simpara>

<simpara>Larceny provides five distinct Larceny-specific
mechanisms that non-portable R6RS programs can use to
import or to define libraries:</simpara>

<orderedlist>
<listitem>
<simpara>
ERR5RS and R6RS standard libraries may be imported.
Their code is located automagically.
</simpara>
</listitem>
<listitem>
<simpara>
Nonstandard libraries, such as <literal>(larceny compiler)</literal>,
may be placed in one of the directories that are searched
by Larceny's
<link linkend="ERR5RSLibraryPathSection">autoload</link> feature, provided
those libraries are located in files that follow Larceny's
standard naming conventions as described in the next section.
</simpara>
</listitem>
<listitem>
<simpara>
R6RS top-level programs may use
<link linkend="R6RSLibraryPathSection">Larceny's <literal>-path</literal> option</link>
to specify directories that contain other libraries
the program may import, provided those libraries are
located in files that follow Larceny's standard naming
conventions as described in the next section.
</simpara>
</listitem>
<listitem>
<simpara>
R6RS top-level programs may use
<link linkend="R6RSLibraryVariableSection">Larceny's <literal>LARCENY_LIBPATH</literal> environment variable</link>
to specify directories that contain other libraries
the program may import, provided those libraries are
located in files that follow Larceny's standard naming
conventions as described in the next section.
</simpara>
</listitem>
<listitem>
<simpara>
R6RS top-level programs and Scheme scripts may
<link linkend="DefiningLibrariesSection">define their own libraries</link>
in the same file that contains the top-level program or
Scheme script.
</simpara>
</listitem>
</orderedlist>
<simpara>ERR5RS programs may use any of those five mechanisms,
and may also use a sixth mechanism:
An ERR5RS program can be written as a little configuration
program that loads the program's libraries from files
before any libraries are imported.  This sixth mechanism
is portable, but is not available to R6RS programs.</simpara>

</section>
<section id="LibraryTranslationSection">
<title>Mapping library names to files (ERR5RS/R6RS)</title>
<simpara>Suppose Larceny's <literal>-path</literal> option is used to specify
a certain <emphasis>directory</emphasis>, and the program imports a
nonstandard library whose name is of the form
<literal>(<emphasis>name1</emphasis> <emphasis>name2</emphasis> &#8230; <emphasis>lastname</emphasis>)</literal>.
Larceny will search for that library in the following
files:</simpara>

<itemizedlist>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>/<emphasis>name2</emphasis>/&#8230;/<emphasis>lastname</emphasis>.larceny.slfasl</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>/<emphasis>name2</emphasis>/&#8230;/<emphasis>lastname</emphasis>.larceny.sls</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>/<emphasis>name2</emphasis>/&#8230;/<emphasis>lastname</emphasis>.slfasl</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>/<emphasis>name2</emphasis>/&#8230;/<emphasis>lastname</emphasis>.sls</literal>
</simpara>
</listitem>
<listitem>
<simpara>
&#8230;
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>/<emphasis>name2</emphasis>.larceny.slfasl</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>/<emphasis>name2</emphasis>.larceny.sls</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>/<emphasis>name2</emphasis>.slfasl</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>/<emphasis>name2</emphasis>.sls</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>.larceny.slfasl</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>.larceny.sls</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>.slfasl</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>directory</emphasis>/<emphasis>name1</emphasis>.sls</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>The search starts with the first of those file names,
continues with the following file names in order,
and ends when a file with one of those names is found.
The imported library <emphasis>must</emphasis> be one of the libraries
defined within the first file found by this search,
since the search is not continued after that first file
is found (except as noted in the next paragraph).</simpara>

<simpara>If the search ends by finding a file whose name ends
with <literal>.slfasl</literal>, then Larceny checks to see whether
there is a file in the same directory with the same
root name but ending with <literal>.sls</literal> instead of <literal>.slfasl</literal>.
If the <literal>.sls</literal> file has been modified since the <literal>.slfasl</literal>
file was last modified, then a warning is printed and
the <literal>.sls</literal> file is loaded instead of the <literal>.slfasl</literal> file.
Otherwise the <literal>.slfasl</literal> file is loaded.</simpara>

<note>
<simpara>The R6RS allows arbitrary mappings from library names to library
code.  Larceny takes advantage of this by ignoring version
numbers when mapping library names to files, and by (virtually)
rewriting any version number that may be specified in the
definition of a library so it matches any version specification
that appears within the <literal>import</literal> form.  Furthermore Larceny
allows different versions of the same library to be imported,
but Larceny's algorithm for resolving library references
ensures that the different versions of a library will be
identical except for their version numbers, which have no
meaningful semantics.  Although Larceny's treatment of versions
conforms to the R6RS specification, it should be clear that
version numbers serve no purpose in Larceny.  Since the R6RS
version feature has no usefully portable semantics, it is
deprecated.</simpara>

</note>
</section>
<section id="RequireLibraryTranslationSection">
<title>Mapping library names to files (R5RS)</title>
<simpara>In R5RS mode, Larceny's <literal>-path</literal> option
and <literal>LARCENY_LIBPATH</literal> environment variable
may be used to
specify directories to be searched by the <literal>require</literal>
procedure, which takes a single symbol <emphasis>libname</emphasis> as
its argument.
The <literal>require</literal> procedure will search for the following
files in every directory that is part of the current
require path, starting with the directories specified
by LARCENY_LIBPATH and the <literal>-path</literal> option:</simpara>

<itemizedlist>
<listitem>
<simpara>
<literal><emphasis>libname</emphasis>.fasl</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>libname</emphasis>.sch</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal><emphasis>libname</emphasis>.scm</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>These files are expected to contain R5RS code, not
library definitions.  Otherwise the search proceeds
much the same as when searching for an ERR5RS/R6RS
library.</simpara>

<note>
<simpara>The <literal>require</literal> path is specified by <literal>startup.sch</literal> in Larceny's
root directory, but may be changed dynamically using the
<literal>current-require-path</literal> parameter.  Changing the <literal>require</literal> path
is not recommended, however, because Larceny relies on the
<literal>require</literal> path for dynamic loading of libraries used by several
important features of Larceny, notably ERR5RS and R6RS modes.</simpara>

</note>
<simpara><anchor id="require" xreflabel="require"></anchor>
<emphasis> Procedure require</emphasis>
<simpara>
<indexterm><primary><code>require</code></primary></indexterm>
<literal>(require <emphasis>libname</emphasis>) </literal>
</simpara></simpara>

<simpara><emphasis>libname</emphasis> must be a symbol that names an R5RS-compatible
library within the current require path.</simpara>

<simpara>If the library has not already been loaded, then it is
located and loaded.  If the library is found and loaded
successfully, then <literal>require</literal> returns true; otherwise an
error is signalled.</simpara>

<simpara>If the library has already been loaded, then <literal>require</literal>
returns false without loading the library a second time.</simpara>

<simpara><anchor id="current-require-path" xreflabel="current-require-path"></anchor>
<emphasis> Procedure current-require-path</emphasis>
<simpara>
<indexterm><primary><code>current-require-path</code></primary></indexterm>
<literal>(current-require-path <emphasis></emphasis>)  =&gt; <emphasis>stringlist</emphasis></literal>
</simpara>
<simpara><literal>(current-require-path <emphasis>stringlist</emphasis>) </literal></simpara></simpara>

<simpara>The optional argument is a list of directory names
(without slashes at the end) that should be searched
by <link linkend="require"><literal>require</literal></link> and (in ERR5RS/R6RS modes)
by Larceny's <link linkend="ERR5RSLibraryPathSection">autoload</link>
feature.
Returns the list of directory names that will be
searched.</simpara>

</section>
</section>
<section id="CompilingChapter">
<title>Compiling files and libraries</title>
<simpara>This chapter explains how you can use Larceny to compile
Scheme source code to native machine code.</simpara>

<simpara>The native varieties of Larceny have a just-in-time
compiler that compiles to native code automatically
whenever you evaluate an expression, load a source
file, or import a source library.  Even so, files
will load faster if they are compiled ahead of time.</simpara>

<simpara>Petit Larceny does not have a just-in-time compiler,
so compiling ahead of time is the only way to enjoy
the speed of native machine code in Petit Larceny.</simpara>

<simpara>Common Larceny uses an interpreter for expressions
that are typed at the interactive read/eval/print
loop, but files will be compiled as they are loaded
if you specify <literal>Larceny.fasl</literal> on the command line.
For more information on compiling files in Common
Larceny, please consult the
<ulink url="http://larceny.ccs.neu.edu">Common Larceny User Manual</ulink>.</simpara>

<simpara>The main disadvantage of compiling files and libraries
is that compiled code goes <emphasis>stale</emphasis> when its original
source code is changed or when a library on which
the compiled code depends is changed or recompiled.
Stale compiled code can be dangerously inconsistent
with libraries on which it depends, so Larceny checks
for staleness and refuses to execute a stale library
or program.</simpara>

<section id="CompilingErr5rsSection">
<title>Compiling ERR5RS/R6RS libraries</title>
<simpara>On Unix machines, the most convenient way to compile
a group of ERR5RS/R6RS libraries and top-level programs
is to use the <literal>compile-stale</literal> script in Larceny's root
directory.
If Larceny's root directory is in your execution path,
then there are just two steps:</simpara>

<orderedlist>
<listitem>
<simpara>
Use <literal>cd</literal> to change to the directory that contains
the ERR5RS/R6RS files you want to compile.  (Files
that lie within subdirectories of that directory will
be compiled also.)
</simpara>
</listitem>
<listitem>
<simpara>
Run the <literal>compile-stale</literal> script.
</simpara>
</listitem>
</orderedlist>
<simpara>For example:</simpara>

<screen>    % cd lib/R6RS
    % compile-stale</screen>
<simpara>On non-Unix machines, you can accomplish the same thing
using Larceny's ERR5RS mode and the <literal>(larceny compiler)</literal>
library:</simpara>

<screen>    % pushd lib\R6RS
    % ..\..\larceny.bat -err5rs
    Larceny v0.96 "Fluoridation"
    ERR5RS mode (no libraries have been imported)

    &gt; (import (larceny compiler))

    &gt; (compile-stale-libraries)</screen>
<simpara>To compile individual files, use the <literal>compile-file</literal> or
<literal>compile-library</literal> procedures that are exported by
<link linkend="LarcenyCompilerSection"><literal>(larceny compiler)</literal></link>.</simpara>

</section>
<section id="CompilingR5rsSection">
<title>Compiling R5RS source files</title>
<simpara><anchor id="compile-file" xreflabel="compile-file"></anchor>
<emphasis> Procedure compile-file</emphasis>
<simpara>
<indexterm><primary><code>compile-file</code></primary></indexterm>
<literal>(compile-file <emphasis>sourcefile</emphasis>) </literal>
</simpara></simpara>

<simpara>Compiles <emphasis>sourcefile</emphasis>, which must be a string naming
a file that contains R5RS source code.
If <emphasis>faslfile</emphasis> is supplied as a second argument,
then it must be a string naming the file that will
contain the compiled code; otherwise the name of
the compiled file is obtained from <emphasis>sourcefile</emphasis>
by replacing the "<literal>.sch</literal>" or "<literal>.scm</literal>" suffix with
"<literal>.fasl</literal>".</simpara>

<simpara>For ERR5RS/R6RS libraries and top-level programs,
<link linkend="CompilingErr5rsSection">see above</link>.</simpara>

</section>
</section>
<section id="Err5rsChapter">
<title>ERR5RS standard libraries</title>
<simpara><link linkend="Standards">ERR5RS</link> is still being developed, so the specifications
described below are subject to change as its standard libraries
are revised.</simpara>

<section id="Err5rsLoadSection">
<title>Load</title>
<simpara>This section describes the <literal>(err5rs load)</literal> library.</simpara>

<simpara><anchor id="load" xreflabel="load"></anchor>
<emphasis> Procedure load</emphasis>
<simpara>
<indexterm><primary><code>load</code></primary></indexterm>
<literal>(load <emphasis>filename</emphasis>) </literal>
</simpara></simpara>

<simpara>Loads ERR5RS code from <emphasis>filename</emphasis>, evaluating each form
as though it had been entered at the interactive
read/eval/print loop.</simpara>

<warning>
<simpara>The <literal>load</literal> procedure should be used only at an interactive top
level and in files that will be loaded into an interactive top
level.  Calls to the <literal>load</literal> procedure have no effect at compile
time, and should not appear in files that will be compiled
separately; use the <literal>library</literal> and <literal>import</literal> syntaxes instead.</simpara>

</warning>
</section>
<section id="Err5rsRecordsSection">
<title>Records</title>
<simpara>When a procedure is said to be equivalent to an R6RS
procedure, the equivalence holds only when all arguments
have the properties required of them by the R6RS
specification.  ERR5RS does not mandate R6RS exception
semantics for programs that violate the specification.</simpara>

<section id="Err5rsRecordsProceduralSection">
<title>Procedural layer</title>
<simpara>This section describes the <literal>(err5rs records procedural)</literal> library.</simpara>

<simpara><anchor id="make-rtd" xreflabel="make-rtd"></anchor>
<emphasis> Procedure make-rtd</emphasis>
<simpara>
<indexterm><primary><code>make-rtd</code></primary></indexterm>
<literal>(make-rtd <emphasis>name fieldspecs</emphasis>) </literal>
</simpara>
<simpara><literal>(make-rtd <emphasis>name fieldspecs parent-rtd</emphasis>) </literal></simpara>
<simpara><literal>(make-rtd <emphasis>name fieldspecs parent-rtd option &#8230;</emphasis>) </literal></simpara></simpara>

<simpara><emphasis>name</emphasis> is a symbol, which matters only to the
<link linkend="rtd-name"><literal>rtd-name</literal></link> procedure of the inspection layer.
<emphasis>fieldspecs</emphasis> is a vector of field specifiers, where
each field specifier is one of</simpara>

<itemizedlist>
<listitem>
<simpara>
a symbol naming the (mutable) field;
</simpara>
</listitem>
<listitem>
<simpara>
a list of the form <literal>(mutable <emphasis>name</emphasis>)</literal>,
where <emphasis>name</emphasis> is a symbol naming the mutable field;
</simpara>
</listitem>
<listitem>
<simpara>
a list of the form <literal>(immutable <emphasis>name</emphasis>)</literal>,
where <emphasis>name</emphasis> is a symbol naming the immutable field.
</simpara>
</listitem>
</itemizedlist>
<simpara>The optional parent is an rtd or <literal>#f</literal>. It is an error for
any of the symbols in fieldspecs to name more than one
of the fields specified by fieldspecs, but the field names
in fieldspecs may shadow field names in the parent rtd.</simpara>

<simpara><link linkend="make-rtd"><literal>make-rtd</literal></link> returns an R6RS-compatible record-type
descriptor.</simpara>

<simpara>Larceny allows the following optional arguments to follow
the optional <emphasis>parent-rtd</emphasis> argument:</simpara>

<itemizedlist>
<listitem>
<simpara>
the symbol <literal>sealed</literal> means the new rtd cannot be used
as the parent of other rtds;
</simpara>
</listitem>
<listitem>
<simpara>
the symbol <literal>opaque</literal> means the <link linkend="record?"><literal>record?</literal></link> predicate
will not recognize instances of the new rtd;
</simpara>
</listitem>
<listitem>
<simpara>
the symbol <literal>uid</literal>, followed by another symbol <emphasis>id</emphasis>,
means the new rtd is non-generative with uid <emphasis>id</emphasis>; the
semantics of this extension is the same as in the R6RS.
</simpara>
</listitem>
</itemizedlist>
<simpara>These Larceny-specific options may be used in any
combination, giving Larceny's ERR5RS records the same
expressive power as R6RS records, with which they are
fully interoperable.</simpara>

<simpara><anchor id="rtd?" xreflabel="rtd?"></anchor>
<emphasis> Procedure rtd?</emphasis>
<simpara>
<indexterm><primary><code>rtd?</code></primary></indexterm>
<literal>(rtd? <emphasis>obj</emphasis>) </literal>
</simpara></simpara>

<simpara>This predicate returns true if and only if its argument
is a record-type descriptor.
<literal>rtd?</literal> is equivalent to the <literal>record-type-descriptor?</literal>
procedure of the R6RS.</simpara>

<simpara><anchor id="rtd-constructor" xreflabel="rtd-constructor"></anchor>
<emphasis> Procedure rtd-constructor</emphasis>
<simpara>
<indexterm><primary><code>rtd-constructor</code></primary></indexterm>
<literal>(rtd-constructor <emphasis>rtd</emphasis>) </literal>
</simpara>
<simpara><literal>(rtd-constructor <emphasis>rtd fieldspecs</emphasis>) </literal></simpara></simpara>

<simpara><emphasis>rtd</emphasis> is a record-type descriptor, and <emphasis>fieldspecs</emphasis> is
an optional vector of symbols.</simpara>

<simpara>If no <emphasis>fieldspecs</emphasis> argument is supplied,
then <literal>rtd-constructor</literal> returns a procedure that expects
one argument for each field of the record-type described
by <emphasis>rtd</emphasis> and returns an instance of that record-type
with its fields initialized to the corresponding
arguments.
Arguments that correspond to the fields of the
record-type's parent (if any) come first.</simpara>

<simpara>If <emphasis>fieldspecs</emphasis> is supplied, then <literal>rtd-constructor</literal>
returns a procedure that expects one argument for each
element of <emphasis>fieldspecs</emphasis> and returns an instance of the
record-type described by <emphasis>rtd</emphasis> with the named fields
initialized to the corresponding arguments.</simpara>

<simpara>It is an error if some symbol occurs more than once in
<emphasis>fieldspecs</emphasis>.  Fields of a derived record-type shadow
fields of the same name in its parent; the <emphasis>fieldspecs</emphasis>
argument cannot be used to initialize a shadowed field.</simpara>

<simpara><anchor id="rtd-predicate" xreflabel="rtd-predicate"></anchor>
<emphasis> Procedure rtd-predicate</emphasis>
<simpara>
<indexterm><primary><code>rtd-predicate</code></primary></indexterm>
<literal>(rtd-predicate <emphasis>rtd</emphasis>) </literal>
</simpara></simpara>

<simpara>Equivalent to the <literal>record-predicate</literal> procedure of the R6RS.</simpara>

<simpara><anchor id="rtd-accessor" xreflabel="rtd-accessor"></anchor>
<emphasis> Procedure rtd-accessor</emphasis>
<simpara>
<indexterm><primary><code>rtd-accessor</code></primary></indexterm>
<literal>(rtd-accessor <emphasis>rtd field</emphasis>) </literal>
</simpara></simpara>

<simpara><emphasis>field</emphasis> is a symbol that names a field of the
record-type described by the record-type descriptor <emphasis>rtd</emphasis>.
Returns a unary procedure that accepts instances of <emphasis>rtd</emphasis>
(or any record-type that inherits from <emphasis>rtd</emphasis>) and
returns the current value of the named field.</simpara>

<simpara>Fields in derived record-types shadow fields of the same
name in a parent record-type.</simpara>

<simpara><anchor id="rtd-mutator" xreflabel="rtd-mutator"></anchor>
<emphasis> Procedure rtd-mutator</emphasis>
<simpara>
<indexterm><primary><code>rtd-mutator</code></primary></indexterm>
<literal>(rtd-mutator <emphasis>rtd field</emphasis>) </literal>
</simpara></simpara>

<simpara><emphasis>field</emphasis> is a symbol that names a field of the
record-type described by the record-type descriptor <emphasis>rtd</emphasis>.
Returns a binary procedure that accepts instances of <emphasis>rtd</emphasis>
(or any record-type that inherits from <emphasis>rtd</emphasis>) and a new
value to be stored into the named field, performs that
side effect, and returns an unspecified value.</simpara>

<simpara>Fields in derived record-types shadow fields of the same
name in a parent record-type.</simpara>

</section>
<section id="Err5rsRecordsInspectionSection">
<title>Inspection layer</title>
<simpara>This section describes the <literal>(err5rs records inspection)</literal> library.</simpara>

<simpara><anchor id="record?" xreflabel="record?"></anchor>
<emphasis> Procedure record?</emphasis>
<simpara>
<indexterm><primary><code>record?</code></primary></indexterm>
<literal>(record? <emphasis>obj</emphasis>) </literal>
</simpara></simpara>

<simpara>Equivalent to its R6RS namesake.</simpara>

<simpara><anchor id="record-rtd" xreflabel="record-rtd"></anchor>
<emphasis> Procedure record-rtd</emphasis>
<simpara>
<indexterm><primary><code>record-rtd</code></primary></indexterm>
<literal>(record-rtd <emphasis>record</emphasis>) </literal>
</simpara></simpara>

<simpara>Equivalent to its R6RS namesake.</simpara>

<simpara><anchor id="rtd-name" xreflabel="rtd-name"></anchor>
<emphasis> Procedure rtd-name</emphasis>
<simpara>
<indexterm><primary><code>rtd-name</code></primary></indexterm>
<literal>(rtd-name <emphasis>rtd</emphasis>) </literal>
</simpara></simpara>

<simpara>Equivalent to the <literal>record-type-name</literal> procedure of the R6RS.</simpara>

<simpara><anchor id="rtd-parent" xreflabel="rtd-parent"></anchor>
<emphasis> Procedure rtd-parent</emphasis>
<simpara>
<indexterm><primary><code>rtd-parent</code></primary></indexterm>
<literal>(rtd-parent <emphasis>rtd</emphasis>) </literal>
</simpara></simpara>

<simpara>Equivalent to the <literal>record-type-parent</literal> procedure of the R6RS.</simpara>

<simpara><anchor id="rtd-field-names" xreflabel="rtd-field-names"></anchor>
<emphasis> Procedure rtd-field-names</emphasis>
<simpara>
<indexterm><primary><code>rtd-field-names</code></primary></indexterm>
<literal>(rtd-field-names <emphasis>rtd</emphasis>) </literal>
</simpara></simpara>

<simpara>Equivalent to the <literal>record-type-field-names</literal> procedure of the R6RS.
(That is, it returns a vector of the symbols that name the fields
of the record-type represented by <emphasis>rtd</emphasis>, excluding the fields of
parent record-types.)</simpara>

<simpara><anchor id="rtd-all-field-names" xreflabel="rtd-all-field-names"></anchor>
<emphasis> Procedure rtd-all-field-names</emphasis>
<simpara>
<indexterm><primary><code>rtd-all-field-names</code></primary></indexterm>
<literal>(rtd-all-field-names <emphasis>rtd</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns a vector of the symbols that name the fields of
the record-type represented by <emphasis>rtd</emphasis>, including the fields
of its parent record-types, if any, with the fields of
parent record-types coming before the fields of its children,
with each subsequence in the same order as in the vectors
that would be returned by calling <link linkend="rtd-field-names"><literal>rtd-field-names</literal></link>
on <emphasis>rtd</emphasis> and on all its ancestral record-type descriptors.</simpara>

<simpara><anchor id="rtd-field-mutable?" xreflabel="rtd-field-mutable?"></anchor>
<emphasis> Procedure rtd-field-mutable?</emphasis>
<simpara>
<indexterm><primary><code>rtd-field-mutable?</code></primary></indexterm>
<literal>(rtd-field-mutable? <emphasis>rtd field</emphasis>) </literal>
</simpara></simpara>

<simpara><emphasis>rtd</emphasis> is a record-type descriptor, and <emphasis>field</emphasis> is a
symbol naming a field of the record-type described by <emphasis>rtd</emphasis>.
Returns <literal>#t</literal> if the named field is mutable; otherwise returns <literal>#f</literal>.</simpara>

</section>
<section id="Err5rsRecordsSyntacticSection">
<title>Syntactic layer</title>
<simpara>This section describes the <literal>(err5rs records syntactic)</literal> library.</simpara>

<simpara>The syntactic layer consists of
<ulink url="http://srfi.schemers.org/srfi-9/">SRFI 9</ulink>
extended with single inheritance and (optional) implicit naming.</simpara>

<simpara>All ERR5RS record-type definitions are generative (unless
Larceny's optional <literal>uid</literal> feature is used), but
ERR5RS drops the SRFI 9 restriction to top level, mainly
because the R6RS allows generative definitions wherever
a definition may appear.</simpara>

<simpara>The syntax of an ERR5RS record-type definition is</simpara>

<screen>    &lt;definition&gt;
      -&gt; &lt;record type definition&gt;           ; addition to 7.1.6 in R5RS

    &lt;record type definition&gt;
      -&gt; (define-record-type &lt;type spec&gt;
           &lt;constructor spec&gt;
           &lt;predicate spec&gt;
           &lt;field spec&gt; ...)

    &lt;type spec&gt;  -&gt; &lt;type name&gt;
                 -&gt; (&lt;type name&gt; &lt;parent&gt;)

    &lt;constructor spec&gt;
                 -&gt; #f
                 -&gt; #t
                 -&gt; &lt;constructor name&gt;
                 -&gt; (&lt;constructor name&gt; &lt;field name&gt; ...)

    &lt;predicate spec&gt;
                 -&gt; #f
                 -&gt; #t
                 -&gt; &lt;predicate name&gt;

    &lt;field spec&gt; -&gt; &lt;field name&gt;
                 -&gt; (&lt;field name&gt;)
                 -&gt; (&lt;field name&gt; &lt;accessor name&gt;)
                 -&gt; (&lt;field name&gt; &lt;accessor name&gt; &lt;mutator name&gt;)

    &lt;parent&gt;           -&gt; &lt;expression&gt;

    &lt;type name&gt;        -&gt; &lt;identifier&gt;
    &lt;constructor name&gt; -&gt; &lt;identifier&gt;
    &lt;predicate name&gt;   -&gt; &lt;identifier&gt;
    &lt;accessor name&gt;    -&gt; &lt;identifier&gt;
    &lt;mutator name&gt;     -&gt; &lt;identifier&gt;
    &lt;field name&gt;       -&gt; &lt;identifier&gt;</screen>
<simpara>The semantics of a record type definition is the same
as in SRFI 9: the record type definition macro-expands
into a cluster of definitions that</simpara>

<itemizedlist>
<listitem>
<simpara>
defines the <literal>&lt;type name&gt;</literal> as the record-type descriptor
for the new record-type;
</simpara>
</listitem>
<listitem>
<simpara>
defines a constructor for instances of the new
record-type (unless the constructor spec is <literal>#f</literal>);
</simpara>
</listitem>
<listitem>
<simpara>
defines a predicate that recognizes instances of the
new record-type and its subtypes (unless the predicate spec is <literal>#f</literal>);
</simpara>
</listitem>
<listitem>
<simpara>
defines an accessor for each field name;
</simpara>
</listitem>
<listitem>
<simpara>
defines a mutator for each mutable field name.
</simpara>
</listitem>
</itemizedlist>
<simpara>An ERR5RS record type definition extends SRFI 9 with the
following additional options:</simpara>

<itemizedlist>
<listitem>
<simpara>
If a <literal>&lt;parent&gt;</literal> expression is specified, then it must
evaluate to an rtd that serves as the parent record-type
for the record-type being defined.
</simpara>
</listitem>
<listitem>
<simpara>
If <literal>#f</literal> is specified for the constructor or predicate,
then no constructor or predicate procedure is defined.
(This is useful when the record-type being defined will
be used as an abstract base class.)
</simpara>
</listitem>
<listitem>
<simpara>
If <literal>#t</literal> is specified for the constructor or predicate,
then the name of the constructor is the type name prefixed
by <literal>make-</literal>, and the name of the predicate is the type name
followed by a question mark (<literal>?</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
If the constructor name is specified as <literal>#t</literal> or as an
identifier, then the constructor's arguments correspond
to the fields of the parent (if any) followed by the new
fields added by this record-type definition.
</simpara>
</listitem>
<listitem>
<simpara>
If a field spec consists of a single identifier, then
</simpara>
<itemizedlist>
<listitem>
<simpara>
the field is immutable;
</simpara>
</listitem>
<listitem>
<simpara>
the name of its accessor is the type name followed by
a hyphen (<literal>-</literal>) followed by the field name.
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
If a field spec consists of a list of one identifier, then
</simpara>
<itemizedlist>
<listitem>
<simpara>
the field is mutable;
</simpara>
</listitem>
<listitem>
<simpara>
the name of its accessor is the type name followed
by a hyphen (<literal>-</literal>) followed by the field name;
</simpara>
</listitem>
<listitem>
<simpara>
the name of its mutator is the type name followed by
a hyphen (<literal>-</literal>) followed by the field name followed by <literal>-set!</literal>.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section id="RecordIdentitySection">
<title>Record identity</title>
<simpara>Two ERR5RS records with fields are <literal>eqv?</literal> if and only if
they were created by the same (dynamic) call to some
record constructor.
Two ERR5RS records are <literal>eq?</literal> if and only if they are <literal>eqv?</literal>.</simpara>

<simpara>Apart from the usual constraint that equivalence according
to <literal>eqv?</literal> implies equivalence according to <literal>equal?</literal>, the
behavior of <literal>equal?</literal> on ERR5RS records is unspecified.
(This is compatible with the R6RS.)</simpara>

<simpara>A <literal>define-record-type</literal> form macro-expands into code that
calls <link linkend="make-rtd"><literal>make-rtd</literal></link> each time the expanded record-type
definition is executed.
Two ERR5RS record-type descriptors are <literal>eqv?</literal> if and only if
they were created by the same (dynamic) call to
<link linkend="make-rtd"><literal>make-rtd</literal></link>.</simpara>

</section>
</section>
</section>
<section id="R6rsChapter">
<title>R6RS standard libraries</title>
<simpara>This chapter explains which features of the R6RS standard
libraries are available in each of Larceny's major modes
of execution.</simpara>

<simpara>Larceny was the first substantially complete implementation
of the R6RS.  Any features that are missing from R6RS modes
are missing because of bugs or because the features are
deprecated in Larceny.
The most up-to-date listing of Larceny's known deviations
from the R6RS standard can be found on the web page
that describes the current status of
<ulink url="https://github.com/larcenists/larceny/wiki/DargoMode">Larceny's R6RS-compatible mode</ulink>.</simpara>

<simpara>Larceny is R6RS-compatible but not R6RS-conforming.
When Larceny is said to support a feature of the R6RS,
that means the feature is present and will behave as
specified by the R6RS so long as no exception is raised.
Larceny does not always raise the specific conditions
specified by the R6RS, and does not perform all of the
checking for portability problems that is mandated by
the R6RS.  These deviations do not affect the execution
of production code, and do not compromise Larceny's
traditional safety.</simpara>

<section id="R6rsBaseSection">
<title>Base library</title>
<simpara>ERR5RS and R6RS modes support all procedures and syntaxes
exported by the <literal>(rnrs base)</literal> library.</simpara>

<simpara>Larceny's R5RS mode does not support <literal>library</literal>, <literal>import</literal>, or
<literal>identifier-syntax</literal>.</simpara>

<note>
<simpara>The semantics of <literal>quasiquote</literal>, <literal>let-syntax</literal>, and <literal>letrec-syntax</literal>
differ between the R5RS and the R6RS.  Larceny's R5RS mode still
supports the R5RS semantics.</simpara>

</note>
</section>
<section id="R6rsUnicodeSection">
<title>Unicode</title>
<simpara>All of Larceny's modes support all features of the <literal>(rnrs unicode)</literal>
library.</simpara>

<simpara>Larceny v0.97 conforms to
<link linkend="Standards">The Unicode Standard</link>, Version 5.0.</simpara>

</section>
<section id="R6rsBytevectorsSection">
<title>Bytevectors</title>
<simpara>ERR5RS and R6RS modes support all procedures and syntaxes
exported by <literal>(rnrs bytevectors)</literal>, but the <literal>endianness</literal>
syntax is deprecated because it is redundant with <literal>quote</literal>.
Larceny's R5RS mode does not support <literal>endianness</literal>.</simpara>

<simpara>In Larceny, any symbol names a supported endianness.
The symbols <literal>big</literal> and <literal>little</literal> have their expected meanings.
All other symbols mean <literal>(native-endianness)</literal> with respect
to integer operations, but mean the opposite of
<literal>(native-endianness)</literal> with respect to
<link linkend="Standards">IEEE-754</link> operations.
For string operations, the endianness must be the symbol
<literal>big</literal> or the symbol <literal>little</literal>.  All of these extensions are
permitted by the R6RS standard.</simpara>

<simpara>Larceny's <literal>utf16-&gt;string</literal> and <literal>utf32-&gt;string</literal> accept one,
two, or three arguments.  The R6RS specification of these
procedures does not allow them to accept a single argument,
but that is believed to be an error in the R6RS.</simpara>

</section>
<section id="R6rsListsSection">
<title>Lists</title>
<simpara>All of Larceny's modes support all features of the
<literal>(rnrs lists)</literal> library.</simpara>

</section>
<section id="R6rsSortingSection">
<title>Sorting</title>
<simpara>All of Larceny's modes support all features of the
<literal>(rnrs sorting)</literal> library.</simpara>

</section>
<section id="R6rsControlSection">
<title>Control</title>
<simpara>All of Larceny's modes support all features of the
<literal>(rnrs control)</literal> library.</simpara>

</section>
<section id="R6rsRecordsSection">
<title>Records</title>
<simpara>ERR5RS and R6RS modes support all procedures and syntaxes
exported by
<literal>(rnrs records procedural)</literal>,
<literal>(rnrs records inspection)</literal>, and
<literal>(rnrs records syntactic)</literal>.</simpara>

<simpara>Those libraries are deprecated, however;
the <literal>make-record-constructor-descriptor</literal> procedure does
not simplify unusually complex cases enough to justify
the complexity it adds to typical cases, and
the entire syntactic layer is gratuitously incompatible
with the procedural layer.</simpara>

<simpara>Larceny's R5RS mode supports all features of the deprecated
<literal>(rnrs records procedural)</literal> and <literal>(rnrs records inspection)</literal>
libraries.  R5RS mode does not support <literal>(rnrs records syntactic)</literal>.</simpara>

<simpara>All of Larceny's modes support all features of the
<link linkend="Err5rsRecordsProceduralSection"><literal>(err5rs records procedural)</literal></link>
and
<link linkend="Err5rsRecordsInspectionSection"><literal>(err5rs records inspection)</literal></link>
libraries.  ERR5RS and R6RS modes also support the
<link linkend="Err5rsRecordsSyntacticSection"><literal>(err5rs records syntactic)</literal></link>
library.
These libraries are equivalent to the
<literal>(srfi :99 records procedural)</literal>,
<literal>(srfi :99 records inspection)</literal>, and
<literal>(srfi :99 records syntactic)</literal> libraries.</simpara>

<simpara>The record definition syntax of
<ulink url="http://srfi.schemers.org/srfi-9/">SRFI 9</ulink>
is a proper subset
of the syntax provided by the <literal>(err5rs records syntactic)</literal>
library.  In R5RS mode, SRFI 9 can be loaded dynamically
using the
<link linkend="require"><literal>require</literal></link> procedure:</simpara>

<screen>    &gt; (require 'srfi-9)</screen>
<simpara>We recommend the ERR5RS and/or SRFI 9 libraries be used instead
of the corresponding R6RS libraries.</simpara>

<warning>
<simpara>The R6RS spouts some tendentious nonsense about procedural
records being slower than syntactic records, but this is not
true of Larceny's records, and is unlikely to be true of other
implementations either.</simpara>

</warning>
<warning>
<simpara>Larceny continues to support its old-style
records, which are almost but not quite compatible
with ERR5RS and R6RS records.  This can be confusing,
since some of Larceny's procedures have the same names
as R6RS procedures.  That has made it necessary to overload
those procedures to work with both old-style and R6RS
records.  We apologize for the mess.</simpara>

</warning>
</section>
<section id="R6rsConditionsSection">
<title>Exceptions and conditions</title>
<simpara>All of Larceny's modes support all features of the
<literal>(rnrs exceptions)</literal> and <literal>(rnrs conditions)</literal> libraries.</simpara>

</section>
<section id="R6rsIoSection">
<title>Input and output</title>
<simpara>ERR5RS and R6RS modes support all names exported by the
<literal>(rnrs io ports)</literal>, <literal>(rnrs io simple)</literal>, and
<literal>(rnrs files)</literal> libraries.</simpara>

<simpara>The <literal>buffer-mode</literal>, <literal>eol-style</literal>, and <literal>error-handling-mode</literal>
syntaxes are deprecated because they are redundant
with <literal>quote</literal>.  These deprecated syntaxes may be provided
in the form of procedures rather than syntax, but this
deviation from R6RS semantics cannot be detected by
portable R6RS programs.</simpara>

<simpara>Larceny's R5RS mode supports all non-deprecated features
of those libraries.</simpara>

<simpara>Larceny supports four distinct buffer modes: <literal>none</literal>,
<literal>line</literal>, <literal>datum</literal>, and <literal>block</literal>.  The R6RS requires
the <literal>buffer-mode</literal> syntax to raise an exception for the
<literal>datum</literal> buffer mode, which is the buffer mode Larceny
uses for interactive output ports.</simpara>

<simpara>In Larceny, any symbol names a supported end-of-line
style.  All end-of-line and error-handling-mode symbols
whose meanings are not described by the R6RS have
locale-dependent meanings, which is an extension
permitted by the R6RS standard.</simpara>

<simpara>Although Larceny supports the UTF-16 codec, it is not
really useful on Windows machines (where it should be
most useful) because Larceny's low-level file system
mimics a byte-oriented Unix file system even on
Windows.  This problem should be addressed in some
future version of Larceny.</simpara>

<simpara>The most up-to-date list of known deviations from R6RS
io semantics can be found on the web page
that describes the current status of
<ulink url="https://github.com/larcenists/larceny/wiki/DargoMode">Larceny's R6RS-compatible mode</ulink>.</simpara>

</section>
<section id="R6rsProgramsSection">
<title>Programs</title>
<simpara>ERR5RS and R6RS modes support the <literal>(rnrs programs)</literal> library.</simpara>

<simpara>Larceny's R5RS mode provides the <literal>exit</literal> procedure but
not the <literal>command-line</literal> procedure of that library.
Larceny's traditional <literal>command-line-arguments</literal> procedure
can be used to implement an approximation to <literal>command-line</literal>.
For a definition, see <literal>lib/R6RS/rnrs/programs.sls</literal>.</simpara>

</section>
<section id="R6rsArithmeticSection">
<title>Arithmetic</title>
<simpara>All of Larceny's modes support all features of the
<literal>(rnrs arithmetic fixnums)</literal>,
<literal>(rnrs arithmetic flonums)</literal>, and
<literal>(rnrs arithmetic bitwise)</literal>
libraries.</simpara>

<note>
<simpara>R6RS fixnum and flonum operations may be slower than the
corresponding generic operations, since the fixnum and flonum
operations are required to check their arguments and may also
have to check their results.
Isolated operations in small micro-benchmarks are likely to
be slower than groups of similar operations in larger programs,
however, because the Twobit compiler removes redundant checks
and propagates type information.</simpara>

</note>
</section>
<section id="R6rsSyntaxCaseSection">
<title>Syntax-case</title>
<simpara>ERR5RS and R6RS modes support the <literal>(rnrs syntax-case)</literal> library.
Larceny's R5RS mode does not.</simpara>

</section>
<section id="R6rsHashtablesSection">
<title>Hashtables</title>
<simpara>All of Larceny's modes support all features of the
<literal>(rnrs hashtables)</literal> library.</simpara>

<note>
<simpara>Larceny's traditional <literal>make-hashtable</literal> procedure has been
renamed to <literal>make-oldstyle-hashtable</literal>.</simpara>

</note>
<note>
<simpara>When you use Larceny's R5RS or ERR5RS mode to dump a heap image
that contains <literal>eq?</literal> or <literal>eqv?</literal> hashtables you have created, they
are automatically reset so they will
rehash themselves whenever you begin a new session with the
dumped heap.</simpara>

</note>
</section>
<section id="R6rsEnumerationsSection">
<title>Enumeration sets</title>
<simpara>ERR5RS and R6RS modes support the <literal>(rnrs enums)</literal> library.
Larceny's R5RS mode provides all of the procedures exported by
<literal>(rnrs enums)</literal> but does not provide the <literal>define-enumeration</literal>
syntax.</simpara>

</section>
<section id="R6rsEvalSection">
<title>Eval</title>
<simpara>ERR5RS and R6RS modes support the <literal>(rnrs eval)</literal> library.
Larceny's R5RS mode provides an R5RS-compatible eval procedure,
not an R6RS-compatible eval procedure, and does not provide the
<literal>environment</literal> procedure.</simpara>

</section>
<section id="R6rsMutableStringsSection">
<title>Mutable pairs and strings</title>
<simpara>All of Larceny's modes support all features of the
<literal>(rnrs mutable-pairs)</literal> and <literal>(rnrs mutable-strings)</literal> libraries.</simpara>

</section>
<section id="R6rsR5rsSection">
<title>R5RS</title>
<simpara>All of Larceny's modes support all features of the
<literal>(rnrs r5rs)</literal> library.</simpara>

</section>
</section>
<section id="LarcenyErr5rsLibrariesChapter">
<title>Larceny's ERR5RS/R6RS libraries</title>
<simpara>Larceny provides libraries for loading and compiling
ERR5RS/R6RS libraries and for timing benchmarks.
Future versions of Larceny will offer more ERR5RS/R6RS
libraries.</simpara>

<section id="LarcenyLoadSection">
<title>Load</title>
<simpara>The <literal>(larceny load)</literal> library exports both the
<literal>load</literal> procedure of <literal>(err5rs load)</literal>
and <literal>r5rs:require</literal>, which is a renaming of
the <link linkend="require"><literal>require</literal></link> procedure used by
Larceny's R5RS mode.</simpara>

<simpara>In Larceny's ERR5RS mode,
the <literal>load</literal> procedure can load
R5RS libraries and programs as well as ERR5RS/R6RS
libraries.</simpara>

<simpara>The <literal>r5rs:require</literal> procedure should be used only for dynamic loading of
R5RS libraries into Larceny's underlying R5RS system.  The
variables defined by that library can be imported into
an ERR5RS session or ERR5RS/R6RS library or program using a
<link linkend="ERR5RSprimitivesSection"><literal>primitives</literal></link>
clause in an <literal>import</literal> form.</simpara>

<warning>
<simpara>These procedures should be used only at an interactive top
level and in files that will be loaded into an interactive top
level.  Calls to these procedures have no effect at compile
time, and should not appear in files that will be compiled
separately; use the <literal>library</literal> and <literal>import</literal> syntaxes instead.</simpara>

</warning>
</section>
<section id="LarcenyCompilerSection">
<title>Compiler</title>
<simpara>The <literal>(larceny compiler)</literal> library exports the
<literal>load</literal> and <literal>r5rs:require</literal> procedures of <literal>(larceny load)</literal>,
the
<link linkend="current-require-path"><literal>current-require-path</literal></link>
procedure, the
<link linkend="compile-file"><literal>compile-file</literal></link>,
<link linkend="compile-library"><literal>compile-library</literal></link>, and
<link linkend="compile-stale-libraries"><literal>compile-stale-libraries</literal></link>
procedures described below,
and the
<link linkend="compiler-switches"><literal>compiler-switches</literal></link> procedure.</simpara>

<simpara>These procedures can be used to compile ERR5RS/R6RS
libraries and top-level programs before they are imported
or executed.
This is especially important for Petit Larceny, which
would otherwise use an interpreter.  For native Larceny,
whose just-in-time compiler generates native machine code
as source libraries and programs are loaded, imported, or
executed, the main advantage of separate compilation is
that compiled libraries and programs will load much
faster than source libraries and programs.</simpara>

<simpara>The main disadvantage of separate compilation is that
compiled libraries and programs go <emphasis>stale</emphasis> when their
source code is changed or when a library on which they
depend is changed or recompiled.  Stale libraries and
programs can be dangerously inconsistent with libraries
on which they depend, so Larceny checks for staleness
and refuses to execute a stale library or program.
The <link linkend="compile-stale-libraries"><literal>compile-stale-libraries</literal></link>
procedure provides a convenient way to recompile stale
libraries and programs.</simpara>

<simpara><simpara><literal>(compile-file <emphasis>sourcefile</emphasis> <emphasis>[slfaslfile]</emphasis>) </literal></simpara></simpara>

<simpara>Compiles <emphasis>sourcefile</emphasis>, which must be a string naming
a file that contains source code for one or more
ERR5RS/R6RS libraries or a top-level program.
If <emphasis>slfaslfile</emphasis> is supplied as a second argument,
then it must be a string naming the file that will
contain the compiled code; otherwise the name of
the compiled file is obtained from <emphasis>sourcefile</emphasis>
by replacing the "<literal>.sls</literal>" suffix with "<literal>.slfasl</literal>".</simpara>

<simpara><anchor id="compile-library" xreflabel="compile-library"></anchor>
<emphasis> Procedure compile-library</emphasis>
<simpara>
<indexterm><primary><code>compile-library</code></primary></indexterm>
<literal>(compile-library <emphasis>sourcefile</emphasis> <emphasis>[slfaslfile]</emphasis>) </literal>
</simpara></simpara>

<simpara>Compiles <emphasis>sourcefile</emphasis>, which must be a string naming
a file that contains source code for one or more
ERR5RS/R6RS libraries.
Apart from its unwillingness to compile top-level
programs, <literal>compile-library</literal> behaves the same as
<literal>compile-file</literal> above.</simpara>

<simpara><anchor id="compile-stale-libraries" xreflabel="compile-stale-libraries"></anchor>
<emphasis> Procedure compile-stale-libraries</emphasis>
<simpara>
<indexterm><primary><code>compile-stale-libraries</code></primary></indexterm>
<literal>(compile-stale-libraries <emphasis></emphasis>) </literal>
</simpara>
<simpara><literal>(compile-stale-libraries <emphasis>changedfile</emphasis>) </literal></simpara></simpara>

<simpara>If no argument is supplied, then all "<literal>.sls</literal>" files that
lie within the current directory or a subdirectory are
recompiled.</simpara>

<simpara>If <emphasis>changedfile</emphasis> is supplied, then it must be a string
giving the absolute pathname of a file.
(In typical usage, <emphasis>changedfile</emphasis> is a source file that
has been modified, making it necessary to recompile all
files that depend upon it.)
Compiles all ERR5RS/R6RS library files that lie within
the same directory as <emphasis>changedfile</emphasis> or a subdirectory,
and have not yet been compiled or whose compiled files
are older than <emphasis>changedfile</emphasis>.</simpara>

<note>
<simpara>In future versions of Larceny, <literal>compile-stale-libraries</literal>
might compile only the source files that depend upon
<emphasis>changedfile</emphasis>.</simpara>

</note>
<simpara><anchor id="compiler-switches" xreflabel="compiler-switches"></anchor>
<emphasis> Procedure compiler-switches</emphasis>
<simpara>
<indexterm><primary><code>compiler-switches</code></primary></indexterm>
<literal>(compiler-switches <emphasis></emphasis>) </literal>
</simpara>
<simpara><literal>(compiler-switches <emphasis>mode</emphasis>) </literal></simpara></simpara>

<simpara>If no argument is supplied, then the current settings
of all compiler switches are displayed.  Each of those
switches is itself a parameter that is exported by the
<literal>(larceny compiler)</literal> library.  Calling any individual
compiler switch with no arguments will return its current
setting.  Calling any individual compiler switch with an
argument (usually a boolean) will change its setting to
that argument.</simpara>

<simpara>The <literal>compiler-switches</literal> procedure may also be called with
one of the following symbols as its argument:</simpara>

<simpara><literal>default</literal>
sets most compiler switches to their default settings.</simpara>

<simpara><literal>fast-safe</literal>
enables all optimizations but continues to generate
code to perform all run-time type and range checks that
are needed for safety
(in the traditional sense, not the R6RS sense).</simpara>

<simpara><literal>fast-unsafe</literal>
enables all optimizations and also disables type and
range checking.  This setting is deprecated because it
compromises safety (in the traditional sense).</simpara>

<simpara><literal>slow</literal>
turns off all optimizations.</simpara>

<simpara><literal>standard</literal>
sets compiler switches for maximal conformance to the
R5RS and R6RS standards.</simpara>

<warning>
<simpara>The <literal>standard</literal> setting is deprecated because it generates
very slow code (because the R5RS makes it difficult to
inline standard procedures), disables most compile-time
checking (because the R6RS forbids rejection of programs
with obvious errors unless the R6RS classifies the errors
as syntactic), and may also compromise the portability or
interoperability of ERR5RS/R6RS libraries and programs
(because the R6RS outlaws several extensions that Larceny
uses to improve its compatibility with other implementations
of the R5RS and R6RS as well as interoperability between
Larceny's own R5RS and ERR5RS/R6RS modes).</simpara>

</warning>
<tip>
<simpara>Selective toggling of compiler switches is almost always
better than using the <literal>standard</literal> setting.
To improve R5RS conformance without sacrificing too much
performance, set the <literal>benchmark-mode</literal> switch to false and
set the <literal>integrate-procedures</literal> switch to false only when
compiling files that need to be sensitive to redefinitions
of standard procedures.
For R6RS libraries and programs, setting the <literal>benchmark-mode</literal>
and <literal>global-optimization</literal> switches to false will eliminate a
couple of minor conformance issues with only a small loss
of performance and without sacrificing compile-time checking
or portability.</simpara>

</tip>
</section>
<section id="LarcenyBenchmarkingSection">
<title>Benchmarking</title>
<simpara>The <literal>(larceny benchmarking)</literal> library exports the
<literal>time</literal> syntax and <literal>run-benchmark</literal> procedure described
below.</simpara>

<simpara><emphasis>Syntax time</emphasis></simpara>

<simpara><literal>(time expression)</literal></simpara>

<simpara>Evaluates <emphasis>expression</emphasis> and returns its result
after printing approximations to the storage
allocated and time taken during evaluation of
<emphasis>expression</emphasis>.</simpara>

<screen>    &gt; (time (fib 30))
    Words allocated: 0
    Words reclaimed: 0
    Elapsed time...: 49 ms (User: 48 ms; System: 0 ms)
    Elapsed GC time: 0 ms (CPU: 0 in 0 collections.)
    832040</screen>
<simpara><simpara><literal>(run-benchmark <emphasis>name iterations thunk predicate</emphasis>) </literal></simpara></simpara>

<simpara>Given the <emphasis>name</emphasis> of a benchmark, the number of
<emphasis>iterations</emphasis> to be performed, a zero-argument
procedure <emphasis>thunk</emphasis> that runs the benchmark,
and a unary <emphasis>predicate</emphasis> that checks the result
of <emphasis>thunk</emphasis>, prints approximations to the storage
allocated and time taken by <emphasis>iterations</emphasis> calls
to <emphasis>thunk</emphasis>.</simpara>

<screen>    &gt; (run-benchmark "fib30"
                     100
                     (lambda () (fib 30))
                     (lambda (x) (= x 832040)))

    --------------------------------------------------------
    fib30
    Words allocated: 0
    Words reclaimed: 0
    Elapsed time...: 4828 ms (User: 4824 ms; System: 4 ms)
    Elapsed GC time: 0 ms (CPU: 0 in 0 collections.)</screen>
</section>
<section id="RecordsPrinterSection">
<title>Records printer</title>
<simpara>The <literal>(larceny records printer)</literal> library exports the
two procedures described below.  These procedures
can be used to override Larceny's usual printing
of records and opaque types that were defined using
the records libraries.</simpara>

<simpara><anchor id="rtd-printer" xreflabel="rtd-printer"></anchor>
<emphasis> Procedure rtd-printer</emphasis>
<simpara>
<indexterm><primary><code>rtd-printer</code></primary></indexterm>
<literal>(rtd-printer <emphasis>rtd</emphasis>)  =&gt; <emphasis>maybe-procedure</emphasis></literal>
</simpara></simpara>

<simpara>Given a record type descriptor, returns its custom
print procedure, or returns false if the rtd has no
custom print procedure.</simpara>

<simpara><anchor id="rtd-printer-set!" xreflabel="rtd-printer-set!"></anchor>
<emphasis> Procedure rtd-printer-set!</emphasis>
<simpara>
<indexterm><primary><code>rtd-printer-set!</code></primary></indexterm>
<literal>(rtd-printer-set! <emphasis>rtd printer</emphasis>) </literal>
</simpara></simpara>

<simpara>Given a record type descriptor <emphasis>rtd</emphasis> and a
<emphasis>printer</emphasis> for instances of that rtd, installs
<emphasis>printer</emphasis> as a custom print procedure for <emphasis>rtd</emphasis>.
The <emphasis>printer</emphasis> should be a procedure that,
given an instance of the rtd and a textual
output port, writes a representation of the
instance to the port.</simpara>

</section>
</section>
<section id="LarcenyR5rsLibrariesChapter">
<title>Larceny's R5RS libraries</title>
<simpara>The procedures described in this chapter are nonstandard.
Some are deprecated after being rendered obsolete by ERR5RS
or R6RS standard libraries.
Others still provide useful capabilities that the standard
libraries don't.</simpara>

<section>
<title>Strings</title>
<simpara>Larceny provides Unicode strings with
<ulink url="http://www.r6rs.org/">R6RS</ulink>
semantics.</simpara>

<simpara>The <literal>string-downcase</literal> and <literal>string-upcase</literal> procedures
perform Unicode-compatible case folding, which can result
in a string whose length is different from that of the original.</simpara>

<simpara>Larceny may still provide <literal>string-downcase!</literal> and <literal>string-upcase!</literal>
procedures, but they are deprecated.</simpara>

</section>
<section>
<title>Bytevectors</title>
<simpara>A <emphasis>bytevector</emphasis> is a data structure that stores bytes &#8212; exact
8-bit unsigned integers. Bytevectors are useful in constructing
system interfaces and other low-level programming. In Larceny,
many bytevector-like structures &#8212; bignums, for example &#8212;
are implemented in terms of a
lower-level <emphasis>bytevector-like</emphasis> data type. The operations on
generic bytevector-like structures are particularly fast but
useful largely in code that manipulates Larceny's data
representations.</simpara>

<simpara>The <link linkend="BytevectorsLibrary"><literal>(rnrs bytevectors)</literal> library</link> now
provides a large set of procedures that, in Larceny, are
defined using the procedures described below.</simpara>

<simpara><anchor id="make-bytevector" xreflabel="make-bytevector"></anchor>
<emphasis> Integrable procedure make-bytevector</emphasis>
<simpara>
<indexterm><primary><code>make-bytevector</code></primary></indexterm>
<literal>(make-bytevector <emphasis>length</emphasis>)  =&gt; <emphasis>bytevector</emphasis></literal>
</simpara>
<simpara><literal>(make-bytevector <emphasis>length fill</emphasis>)  =&gt; <emphasis>bytevector</emphasis></literal></simpara></simpara>

<simpara>Returns a bytevector of the desired length.
If no second argument is given, then the bytevector has not
been initialized and most likely contains garbage.</simpara>

<simpara><emphasis>Operations on bytevector structures</emphasis></simpara>

<simpara><simpara><literal>(bytevector? <emphasis>obj</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(bytevector-length <emphasis>bytevector</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(bytevector-ref <emphasis>bytevector offset</emphasis>)  =&gt; <emphasis>byte</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(bytevector-set! <emphasis>bytevector offset byte</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(bytevector-equal? <emphasis>bytevector1 bytevector2</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(bytevector-fill! <emphasis>bytevector byte</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(bytevector-copy <emphasis>bytevector</emphasis>)  =&gt; <emphasis>bytevector</emphasis></literal></simpara></simpara>

<simpara>These procedures do what you expect.
All are integrable, except <literal>bytevector-equal?</literal> and <literal>bytevector-copy</literal>.
The <literal>bytevector-equal?</literal> name is deprecated, since the
R6RS calls it <literal>bytevector=?</literal>.</simpara>

<simpara><emphasis>Operations on bytevector-like structures</emphasis></simpara>

<simpara><simpara><literal>(bytevector-like? <emphasis>obj</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(bytevector-like-length <emphasis>bytevector</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(bytevector-like-ref <emphasis>bytevector offset</emphasis>)  =&gt; <emphasis>byte</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(bytevector-like-set! <emphasis>bytevector offset byte</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(bytevector-like-equal? <emphasis>bytevector1 bytevector2</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(bytevector-like-copy <emphasis>bytevector</emphasis>)  =&gt; <emphasis>bytevector</emphasis></literal></simpara></simpara>

<simpara>A bytevector-like structure is a low-level representation
for indexed arrays of uninterpreted bytes.  Bytevector-like
structures are used to represent types such as bignums and
flonums.</simpara>

<simpara>There is no way to construct a "generic" bytevector-like
structure; use the constructors for specific bytevector-like
types.</simpara>

<simpara>The bytevector-like operations operate on all bytevector-like
structures.  All are integrable, except <literal>bytevector-like-equal?</literal>
and <literal>bytevector-like-copy</literal>.  All are deprecated because they
violate abstraction barriers and make your code
representation-dependent; they are useful mainly to
Larceny developers, who might otherwise be tempted to
write some low-level operations in C or assembly language.</simpara>

</section>
<section>
<title>Vectors</title>
<simpara><anchor id="vector-copy" xreflabel="vector-copy"></anchor>
<emphasis> Procedure vector-copy</emphasis>
<simpara>
<indexterm><primary><code>vector-copy</code></primary></indexterm>
<literal>(vector-copy <emphasis>vector</emphasis>)  =&gt; <emphasis>vector</emphasis></literal>
</simpara></simpara>

<simpara>Returns a shallow copy of its argument.</simpara>

<simpara><emphasis>Operations on vector-like structures</emphasis></simpara>

<simpara><simpara><literal>(vector-like? <emphasis>object</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal></simpara>
<simpara><literal>(vector-like-length <emphasis>vector-like</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal></simpara>
<simpara><literal>(vector-like-ref <emphasis>vector-like k</emphasis>)  =&gt; <emphasis>object</emphasis></literal></simpara>
<simpara><literal>(vector-like-set! <emphasis>vector-like k object</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara>A vector-like structure is a low-level representation
for indexed arrays of Scheme objects.  Vector-like
structures are used to represent types such as vectors,
records, symbols, and ports.</simpara>

<simpara>There is no way to construct a "generic" vector-like structure;
use the constructors for specific data types.</simpara>

<simpara>The vector-like operations operate on all vector-like structures.
All are integrable.
All are deprecated because they
violate abstraction barriers and make your code
representation-dependent; they are useful mainly to
Larceny developers, who might otherwise be tempted to
write some low-level operations in C or assembly language.</simpara>

</section>
<section>
<title>Procedures</title>
<simpara><emphasis>Operations on procedures</emphasis></simpara>

<simpara><simpara><literal>(make-procedure <emphasis>length</emphasis>)  =&gt; <emphasis>procedure</emphasis></literal></simpara>
<simpara><literal>(procedure-length <emphasis>procedure</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal></simpara>
<simpara><literal>(procedure-ref <emphasis>procedure offset</emphasis>)  =&gt; <emphasis>object</emphasis></literal></simpara>
<simpara><literal>(procedure-set! <emphasis>procedure offset object</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara>These procedures operate on the representations of procedures and
allow user programs to construct, inspect, and alter procedures.</simpara>

<simpara><anchor id="procedure-copy" xreflabel="procedure-copy"></anchor>
<emphasis> Procedure procedure-copy</emphasis>
<simpara>
<indexterm><primary><code>procedure-copy</code></primary></indexterm>
<literal>(procedure-copy <emphasis>procedure</emphasis>)  =&gt; <emphasis>procedure</emphasis></literal>
</simpara></simpara>

<simpara>Returns a shallow copy of the procedure.</simpara>

<simpara>The procedures above are deprecated because they
violate abstraction barriers and make your code
representation-dependent; they are useful mainly to
Larceny developers, who might otherwise be tempted to
write some low-level operations in C or assembly language.</simpara>

<simpara>The rest of this section describes some procedures that
reach through abstraction barriers in a more controlled way
to extract heuristic information from procedures for debugging
purposes.</simpara>

<note>
<simpara>The following
text is copied from a straw proposal authored by Will Clinger and sent
to rrr-authors on 09 May 1996. The text has been edited lightly. See
the end for notes about the Larceny implementation.</simpara>

</note>
<simpara>The procedures that extract heuristic information from procedures are
permitted to return any result whatsoever. If the type of a result is
not among those listed below, then the result represents an
implementation-dependent extension to this interface, which may safely
be interpreted as though no information were available from the
procedure. Otherwise the result is to be interpreted as described
below.</simpara>

<simpara><anchor id="procedure-arity" xreflabel="procedure-arity"></anchor>
<emphasis> Procedure procedure-arity</emphasis>
<simpara>
<indexterm><primary><code>procedure-arity</code></primary></indexterm>
<literal>(procedure-arity <emphasis>proc</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns information about the arity of <emphasis>proc</emphasis>. If the result is <literal>#f</literal>,
then no information is available. If the result is an exact
non-negative integer <emphasis>k</emphasis>, then <emphasis>proc</emphasis> requires exactly <emphasis>k</emphasis>
arguments. If the result is an inexact non-negative integer <emphasis>n</emphasis>, then
<emphasis>proc</emphasis> requires <emphasis>n</emphasis> or more arguments. If the result is a pair, then
it is a list of non-negative integers, each of which indicates a
number of arguments that will be accepted by <emphasis>proc</emphasis>; the list is not
necessarily exhaustive.</simpara>

<simpara><anchor id="procedure-documentation-string" xreflabel="procedure-documentation-string"></anchor>
<emphasis> Procedure procedure-documentation-string</emphasis>
<simpara>
<indexterm><primary><code>procedure-documentation-string</code></primary></indexterm>
<literal>(procedure-documentation-string <emphasis>proc</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns general information about <emphasis>proc</emphasis>. If the result is <literal>#f</literal>, then no
information is available. If the result is a string, then it is to be
interpreted as a "documentation string" (see Common Lisp).</simpara>

<simpara><anchor id="procedure-name" xreflabel="procedure-name"></anchor>
<emphasis> Procedure procedure-name</emphasis>
<simpara>
<indexterm><primary><code>procedure-name</code></primary></indexterm>
<literal>(procedure-name <emphasis>proc</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns information about the name of <emphasis>proc</emphasis>. If the result is <literal>#f</literal>,
then no information is available. If the result is a symbol or string,
then it represents a name. If the result is a pair, then it is a list
of symbols and/or strings representing a path of names; the first
element represents an outer name and the last element represents an
inner name.</simpara>

<simpara><anchor id="procedure-source-file" xreflabel="procedure-source-file"></anchor>
<emphasis> Procedure procedure-source-file</emphasis>
<simpara>
<indexterm><primary><code>procedure-source-file</code></primary></indexterm>
<literal>(procedure-source-file <emphasis>proc</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns information about the name of a file that contains the source
code for <emphasis>proc</emphasis>. If the result is <literal>#f</literal>, then no information is
available. If the result is a string, then the string is the name of a
file.</simpara>

<simpara><anchor id="procedure-source-position" xreflabel="procedure-source-position"></anchor>
<emphasis> Procedure procedure-source-position</emphasis>
<simpara>
<indexterm><primary><code>procedure-source-position</code></primary></indexterm>
<literal>(procedure-source-position <emphasis>proc</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns information about the position of the source code for <emphasis>proc</emphasis>
whithin the source file specified by procedure-source-file. If the
result is <literal>#f</literal>, then no information is available. If the result is an
exact integer <emphasis>k</emphasis>, then <emphasis>k</emphasis> characters precede the opening parenthesis
of the source code for <emphasis>proc</emphasis> within that source file.</simpara>

<simpara><anchor id="procedure-expression" xreflabel="procedure-expression"></anchor>
<emphasis> Procedure procedure-expression</emphasis>
<simpara>
<indexterm><primary><code>procedure-expression</code></primary></indexterm>
<literal>(procedure-expression <emphasis>proc</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns information about the source code for <emphasis>proc</emphasis>. If the result is
<literal>#f</literal>, then no information is available. If the result is a pair, then it
is a lambda expression in the traditional representation of a list.</simpara>

<simpara><anchor id="procedure-environment" xreflabel="procedure-environment"></anchor>
<emphasis> Procedure procedure-environment</emphasis>
<simpara>
<indexterm><primary><code>procedure-environment</code></primary></indexterm>
<literal>(procedure-environment <emphasis>proc</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns information about the environment of <emphasis>proc</emphasis>. If the result is
<literal>#f</literal>, then no information is available. In any case the result may be
passed to any of the <link linkend="SectionEnvironments">environment inquiry functions</link>.</simpara>

<simpara><emphasis role="strong">Notes on the Larceny implementation</emphasis></simpara>

<simpara>Twobit does not yet produce data for all of these functions, so some
of them always return <literal>#f</literal>.</simpara>

</section>
<section>
<title>Pairs and Lists</title>
<simpara>The <literal>(rnrs lists)</literal> library now
provides a set of procedures that may supersede some
of the procedures described below.
If one of Larceny's procedures duplicates the semantics of
an R6RS procedure whose name is different, then Larceny's
name is deprecated.</simpara>

<simpara><anchor id="append!" xreflabel="append!"></anchor>
<emphasis> Procedure append!</emphasis>
<simpara>
<indexterm><primary><code>append!</code></primary></indexterm>
<literal>(append! <emphasis>list1 list2 &#8230; obj</emphasis>)  =&gt; <emphasis>object</emphasis></literal>
</simpara></simpara>

<simpara><literal>append!</literal> destructively appends its arguments, which must be lists, and
returns the resulting list. The last argument can be any object. The
argument lists are appended by changing the cdr of the last pair of
each argument except the last to point to the next argument.</simpara>

<simpara><anchor id="every?" xreflabel="every?"></anchor>
<emphasis> Procedure every?</emphasis>
<simpara>
<indexterm><primary><code>every?</code></primary></indexterm>
<literal>(every? <emphasis>procedure list1 list2 &#8230;</emphasis>)  =&gt; <emphasis>object</emphasis></literal>
</simpara></simpara>

<simpara><literal>every?</literal> applies <emphasis>procedure</emphasis> to each element tuple of <emphasis>list_s in
first-to-last order, and returns <literal>#f</literal> as soon as _procedure</emphasis> returns
<literal>#f</literal>. If <emphasis>procedure</emphasis> does not return <literal>#f</literal> for any element tuple of
<emphasis>list_s, then the value returned by _procedure</emphasis> for the last element
tuple of _list_s is returned.</simpara>

<simpara><anchor id="last-pair" xreflabel="last-pair"></anchor>
<emphasis> Procedure last-pair</emphasis>
<simpara>
<indexterm><primary><code>last-pair</code></primary></indexterm>
<literal>(last-pair <emphasis>list-structure</emphasis>)  =&gt; <emphasis>pair</emphasis></literal>
</simpara></simpara>

<simpara><literal>last-pair</literal> returns the last pair of the <emphasis>list structure</emphasis>, which must be
a sequence of pairs linked through the cdr fields.</simpara>

<simpara><anchor id="list-copy" xreflabel="list-copy"></anchor>
<emphasis> Procedure list-copy</emphasis>
<simpara>
<indexterm><primary><code>list-copy</code></primary></indexterm>
<literal>(list-copy <emphasis>list-copy</emphasis>)  =&gt; <emphasis>list</emphasis></literal>
</simpara></simpara>

<simpara><literal>list-copy</literal> makes a shallow copy of the <emphasis>list</emphasis> and returns that copy.</simpara>

<simpara><anchor id="remove" xreflabel="remove"></anchor>
<emphasis> Procedure remove</emphasis>
<simpara>
<indexterm><primary><code>remove</code></primary></indexterm>
<literal>(remove <emphasis>key list</emphasis>)  =&gt; <emphasis>list</emphasis></literal>
</simpara>
<anchor id="remq" xreflabel="remq"></anchor>
<emphasis> Procedure remq</emphasis>
<simpara>
<indexterm><primary><code>remq</code></primary></indexterm>
<literal>(remq <emphasis>key list</emphasis>)  =&gt; <emphasis>list</emphasis></literal>
</simpara>
<anchor id="remv" xreflabel="remv"></anchor>
<emphasis> Procedure remv</emphasis>
<simpara>
<indexterm><primary><code>remv</code></primary></indexterm>
<literal>(remv <emphasis>key list</emphasis>)  =&gt; <emphasis>list</emphasis></literal>
</simpara>
<anchor id="remp" xreflabel="remp"></anchor>
<emphasis> Procedure remp</emphasis>
<simpara>
<indexterm><primary><code>remp</code></primary></indexterm>
<literal>(remp <emphasis>pred? list</emphasis>)  =&gt; <emphasis>list</emphasis></literal>
</simpara></simpara>

<simpara>Each of these procedures returns a new list which contains all the
elements of <emphasis>list</emphasis> in the original order, except that those elements of
the original list that were equal to <emphasis>key</emphasis> (or that satisfy <emphasis>pred?</emphasis>) are
not in the new list. Remove uses <literal>equal?</literal> as the equivalence predicate;
<literal>remq</literal> uses <literal>eq?</literal>, and <literal>remv</literal> uses <literal>eqv?</literal>.</simpara>

<simpara><anchor id="remove!" xreflabel="remove!"></anchor>
<emphasis> Procedure remove!</emphasis>
<simpara>
<indexterm><primary><code>remove!</code></primary></indexterm>
<literal>(remove! <emphasis>key list</emphasis>)  =&gt; <emphasis>list</emphasis></literal>
</simpara>
<anchor id="remq!" xreflabel="remq!"></anchor>
<emphasis> Procedure remq!</emphasis>
<simpara>
<indexterm><primary><code>remq!</code></primary></indexterm>
<literal>(remq! <emphasis>key list</emphasis>)  =&gt; <emphasis>list</emphasis></literal>
</simpara>
<anchor id="remv!" xreflabel="remv!"></anchor>
<emphasis> Procedure remv!</emphasis>
<simpara>
<indexterm><primary><code>remv!</code></primary></indexterm>
<literal>(remv! <emphasis>key list</emphasis>)  =&gt; <emphasis>list</emphasis></literal>
</simpara>
<anchor id="remp!" xreflabel="remp!"></anchor>
<emphasis> Procedure remp!</emphasis>
<simpara>
<indexterm><primary><code>remp!</code></primary></indexterm>
<literal>(remp! <emphasis>pred? list</emphasis>)  =&gt; <emphasis>list</emphasis></literal>
</simpara></simpara>

<simpara>These procedures are like <literal>remove</literal>, <literal>remq</literal>, <literal>remv</literal>, and <literal>remp</literal>,
except they modify <emphasis>list</emphasis> instead of returning a fresh list.</simpara>

<simpara><anchor id="reverse!" xreflabel="reverse!"></anchor>
<emphasis> Procedure reverse!</emphasis>
<simpara>
<indexterm><primary><code>reverse!</code></primary></indexterm>
<literal>(reverse! <emphasis>list</emphasis>)  =&gt; <emphasis>list</emphasis></literal>
</simpara></simpara>

<simpara><literal>reverse!</literal> destructively reverses its argument and returns the reversed
list.</simpara>

<simpara><anchor id="some?" xreflabel="some?"></anchor>
<emphasis> Procedure some?</emphasis>
<simpara>
<indexterm><primary><code>some?</code></primary></indexterm>
<literal>(some? <emphasis>procedure list1 list2 &#8230;</emphasis>)  =&gt; <emphasis>object</emphasis></literal>
</simpara></simpara>

<simpara><literal>some?</literal> applies <emphasis>procedure</emphasis> to each element tuple of <emphasis>list_s in
first-to-last order, and returns the first non-false value returned by
_procedure.</emphasis> If <emphasis>procedure</emphasis> does not return a true value for any
element tuple of _list_s, then some? returns <literal>#f</literal>.</simpara>

</section>
<section>
<title>Sorting</title>
<simpara>The <literal>(rnrs sorting)</literal> library now
provides a small set of procedures that supersede most
of the procedures described below.
All of the procedures described below are therefore
deprecated.</simpara>

<simpara><emphasis>Procedures sort and sort!</emphasis></simpara>

<simpara><simpara><literal>(sort <emphasis>list less?</emphasis>)  =&gt; <emphasis>list</emphasis></literal></simpara>
<simpara><literal>(sort <emphasis>vector less?</emphasis>)  =&gt; <emphasis>vector</emphasis></literal></simpara>
<simpara><literal>(sort! <emphasis>list less?</emphasis>)  =&gt; <emphasis>list</emphasis></literal></simpara>
<simpara><literal>(sort! <emphasis>vector less?</emphasis>)  =&gt; <emphasis>vector</emphasis></literal></simpara></simpara>

<simpara>These procedures sort their argument (a list or a vector) according to
the predicate <emphasis>less?</emphasis>, which must implement a total order on the
elements in the data structures that are sorted.</simpara>

<simpara><literal>sort</literal> returns a fresh data structure containing the sorted data;
<literal>sort!</literal> sorts the data structure in-place.</simpara>

</section>
<section>
<title>Records</title>
<note>
<simpara>Larceny's records have been extended to implement all
<ulink url="http://scheme-punks.org/wiki/index.php?title=Main_Page">ERR5RS</ulink>
and
<ulink url="http://www.r6rs.org/">R6RS</ulink>
procedures from</simpara>

<literallayout class="monospaced">(err5rs records procedural)
(err5rs records inspection)
(rnrs records procedural)
(rnrs records inspection)</literallayout>
<simpara>We recommend that Larceny programmers use the ERR5RS APIs instead
of the R6RS APIs.  This should entail no loss of portability, since
the standard reference implementation of ERR5RS records should run
efficiently in any implementation of the R6RS that permits new
libraries to defined at all.</simpara>

<simpara>Larceny now has two kinds of records: old-style and ERR5RS/R6RS.
Old-style records cannot be created in R6RS-conforming mode, so
our extension of R6RS procedures to accept old-style records does
not affect R6RS conformance.</simpara>

</note>
<note>
<simpara>The following specification describes Larceny's old-style record API,
which is now deprecated.  It
is based on a proposal posted by Pavel Curtis to
rrrs-authors on 10 Sep 1989, and later re-posted by Norman Adams to
comp.lang.scheme on 5 Feb 1992. The authorship and copyright status of
the original text are unknown to me.</simpara>

<simpara>This document differs from the original proposal in that its record
types are extensible, and that it specifies the type of record-type
descriptors.</simpara>

</note>
<section>
<title>Specification</title>
<simpara><anchor id="make-record-type" xreflabel="make-record-type"></anchor>
<emphasis> Procedure make-record-type</emphasis>
<simpara>
<indexterm><primary><code>make-record-type</code></primary></indexterm>
<literal>(make-record-type <emphasis>type-name field-names</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns a "record-type descriptor", a value representing a new data
type, disjoint from all others. The <emphasis>type-name</emphasis> argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type). The <emphasis>field-names</emphasis>
argument is a list of symbols naming the "fields" of a record of the
new type. It is an error if the list contains any duplicates.</simpara>

<simpara>If the <emphasis>parent-rtd</emphasis> argument is provided, then the new type will be a
subtype of the type represented by <emphasis>parent-rtd</emphasis>, and the field names
of the new type will include all the field names of the parent
type. It is an error if the complete list of field names contains any
duplicates.</simpara>

<simpara>Record-type descriptors are themselves records. In particular,
record-type descriptors have a field printer that is either <literal>#f</literal> or a
procedure. If the value of the field is a procedure, then the
procedure will be called to print records of the type represented by
the record-type descriptor. The procedure must accept two arguments:
the record object to be printed and an output port.</simpara>

<simpara><anchor id="record-constructor" xreflabel="record-constructor"></anchor>
<emphasis> Procedure record-constructor</emphasis>
<simpara>
<indexterm><primary><code>record-constructor</code></primary></indexterm>
<literal>(record-constructor <emphasis>rtd</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns a procedure for constructing new members of the type
represented by <emphasis>rtd.</emphasis> The returned procedure accepts exactly as many
arguments as there are symbols in the given list, <emphasis>field-names</emphasis>; these
are used, in order, as the initial values of those fields in a new
record, which is returned by the constructor procedure. The values of
any fields not named in that list are unspecified. The field-names
argument defaults to the list of field-names in the call to
make-record-type that created the type represented by <emphasis>rtd</emphasis>; if the
<emphasis>field-names</emphasis> argument is provided, it is an error if it contains any
duplicates or any symbols not in the default list.</simpara>

<simpara><anchor id="record-predicate" xreflabel="record-predicate"></anchor>
<emphasis> Procedure record-predicate</emphasis>
<simpara>
<indexterm><primary><code>record-predicate</code></primary></indexterm>
<literal>(record-predicate <emphasis>rtd</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns a procedure for testing membership in the type represented by
<emphasis>rtd.</emphasis> The returned procedure accepts exactly one argument and returns
a true value if the argument is a member of the indicated record type
or one of its subtypes; it returns a false value otherwise.</simpara>

<simpara><anchor id="record-accessor" xreflabel="record-accessor"></anchor>
<emphasis> Procedure record-accessor</emphasis>
<simpara>
<indexterm><primary><code>record-accessor</code></primary></indexterm>
<literal>(record-accessor <emphasis>rtd field-name</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns a procedure for reading the value of a particular field of a
member of the type represented by <emphasis>rtd.</emphasis> The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
<emphasis>field-name</emphasis> in that record. The symbol field-name must be a member of
the list of field-names in the call to make-record-type that created
the type represented by <emphasis>rtd</emphasis>, or a member of the field-names of the
parent type of the type represented by <emphasis>rtd.</emphasis></simpara>

<simpara><anchor id="record-updater" xreflabel="record-updater"></anchor>
<emphasis> Procedure record-updater</emphasis>
<simpara>
<indexterm><primary><code>record-updater</code></primary></indexterm>
<literal>(record-updater <emphasis>rtd field-name</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns a procedure for writing the value of a particular field of a
member of the type represented by <emphasis>rtd.</emphasis> The returned procedure
accepts exactly two arguments: first, a record of the appropriate
type, and second, an arbitrary Scheme value; it modifies the field
named by the symbol <emphasis>field-name</emphasis> in that record to contain the given
value. The returned value of the updater procedure is unspecified. The
symbol <emphasis>field-name</emphasis> must be a member of the list of field-names in the
call to make-record-type that created the type represented by <emphasis>rtd</emphasis>,
or a member of the field-names of the parent type of the type
represented by <emphasis>rtd.</emphasis></simpara>

<simpara><simpara><literal>(record? <emphasis>obj</emphasis>) </literal></simpara></simpara>

<simpara>Returns a true value if <emphasis>obj</emphasis> is a record of any type and a false value
otherwise. Note that <literal>record?</literal> may be true of any Scheme value; of
course, if it returns true for some particular value, then
<literal>record-type-descriptor</literal> is applicable to that value and returns an
appropriate descriptor.</simpara>

<simpara><anchor id="record-type-descriptor" xreflabel="record-type-descriptor"></anchor>
<emphasis> Procedure record-type-descriptor</emphasis>
<simpara>
<indexterm><primary><code>record-type-descriptor</code></primary></indexterm>
<literal>(record-type-descriptor <emphasis>record</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns a record-type descriptor representing the type of the given
record. That is, for example, if the returned descriptor were passed
to record-predicate, the resulting predicate would return a true value
when passed the given record. Note that it is not necessarily the case
that the returned descriptor is the one that was passed to
record-constructor in the call that created the constructor procedure
that created the given record.</simpara>

<simpara><anchor id="record-type-name" xreflabel="record-type-name"></anchor>
<emphasis> Procedure record-type-name</emphasis>
<simpara>
<indexterm><primary><code>record-type-name</code></primary></indexterm>
<literal>(record-type-name <emphasis>rtd</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns the type-name associated with the type represented by <emphasis>rtd.</emphasis>
The returned value is eqv? to the type-name argument given in the call
to make-record-type that created the type represented by rtd.</simpara>

<simpara><anchor id="record-type-field-names" xreflabel="record-type-field-names"></anchor>
<emphasis> Procedure record-type-field-names</emphasis>
<simpara>
<indexterm><primary><code>record-type-field-names</code></primary></indexterm>
<literal>(record-type-field-names <emphasis>rtd</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns a list of the symbols naming the fields in members of the type
represented by <emphasis>rtd.</emphasis></simpara>

<simpara><anchor id="record-type-parent" xreflabel="record-type-parent"></anchor>
<emphasis> Procedure record-type-parent</emphasis>
<simpara>
<indexterm><primary><code>record-type-parent</code></primary></indexterm>
<literal>(record-type-parent <emphasis>rtd</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns a record-type descriptor for the parent type of the type
represented by <emphasis>rtd</emphasis>, if that type has a parent type, or a false value
otherwise. The type represented by <emphasis>rtd</emphasis> has a parent type if the call
to make-record-type that created <emphasis>rtd</emphasis> provided the <emphasis>parent-rtd</emphasis>
argument.</simpara>

<simpara><anchor id="record-type-extends?" xreflabel="record-type-extends?"></anchor>
<emphasis> Procedure record-type-extends?</emphasis>
<simpara>
<indexterm><primary><code>record-type-extends?</code></primary></indexterm>
<literal>(record-type-extends? <emphasis>rtd1 rtd2</emphasis>) </literal>
</simpara></simpara>

<simpara>Returns a true value if the type represented by <emphasis>rtd1</emphasis> is a subtype of
the type represented by <emphasis>rtd2</emphasis> and a false value otherwise. A type <emphasis>s</emphasis>
is a subtype of a type <emphasis>t</emphasis> if <emphasis>s=t</emphasis> or if the parent type of <emphasis>s</emphasis>, if
it exists, is a subtype of <emphasis>t.</emphasis></simpara>

</section>
<section>
<title>Implementation</title>
<simpara>The R6RS spouts some tendentious nonsense about procedural
records being slower than syntactic records, but this is not
true of Larceny's records, and is unlikely to be true of other
implementations either.
Larceny's procedural records are fairly efficient already,
and will become even more efficient in future versions as
interlibrary optimizations are added.</simpara>

</section>
</section>
<section>
<title>Input, Output, and Files</title>
<simpara>The <literal>(rnrs io ports)</literal> and <literal>(rnrs files)</literal> libraries now
provide a set of procedures that may supersede some
of the procedures described below.
If one of Larceny's procedures duplicates the semantics of
an R6RS procedure whose name is different, then Larceny's
name is deprecated.</simpara>

<simpara><anchor id="close-open-files" xreflabel="close-open-files"></anchor>
<emphasis> Procedure close-open-files</emphasis>
<simpara>
<indexterm><primary><code>close-open-files</code></primary></indexterm>
<literal>(close-open-files <emphasis></emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>Closes all open files.</simpara>

<simpara><anchor id="console-input-port" xreflabel="console-input-port"></anchor>
<emphasis> Procedure console-input-port</emphasis>
<simpara>
<indexterm><primary><code>console-input-port</code></primary></indexterm>
<literal>(console-input-port <emphasis></emphasis>)  =&gt; <emphasis>input-port</emphasis></literal>
</simpara></simpara>

<simpara>Returns a character input port such that no read from the port has
signalled an error or returned the end-of-file object.</simpara>

<simpara><emphasis>Rationale:</emphasis> console-input-port and console-output-port are artifacts
of Unix interactive I/O conventions, where an interactive end-of-file
does not mean "quit" but rather "done here". Under these conventions
the console port should be reset following an end-of-file. Resetting
conflicts with the semantics of ports in Scheme, so console-input-port
and console-output-port return a new port if the current port is
already at end-of-file.</simpara>

<simpara>Since it is convenient to handle errors in the same manner as
end-of-file, these procedures also return a new port if an error has
been signalled during an I/O operation on the port.</simpara>

<simpara>Console-input-port and console-output-port simply call the port
generators installed in the parameters console-input-port-factory and
console-output-port-factory, which allow user programs to install
their own console port generators.</simpara>

<simpara><anchor id="console-output-port" xreflabel="console-output-port"></anchor>
<emphasis> Procedure console-output-port</emphasis>
<simpara>
<indexterm><primary><code>console-output-port</code></primary></indexterm>
<literal>(console-output-port <emphasis></emphasis>)  =&gt; <emphasis>output-port</emphasis></literal>
</simpara></simpara>

<simpara>Returns a character output port such that no write to the port has
signalled an error.</simpara>

<simpara>See console-input-port for a full explanation.</simpara>

<simpara><anchor id="console-input-port-factory" xreflabel="[console-input-port-factory]"/>
<indexterm>
  <primary>console-input-port-factory</primary>
</indexterm>
<emphasis>Parameter console-input-port-factory</emphasis></simpara>

<simpara>The value of this parameter is a procedure that returns a character
input port such that no read from the port has signalled an error or
returned the end-of-file object.</simpara>

<simpara>See console-input-port for a full explanation.</simpara>

<simpara><anchor id="console-output-port-factory" xreflabel="[console-output-port-factory]"/>
<indexterm>
  <primary>console-output-port-factory</primary>
</indexterm>
<emphasis>Parameter console-output-port-factory</emphasis></simpara>

<simpara>The value of this parameter is a procedure that returns a character
output port such that no write the port has signalled an error.</simpara>

<simpara>See console-input-port for a full explanation.</simpara>

<simpara><anchor id="current-input-port" xreflabel="[current-input-port]"/>
<indexterm>
  <primary>current-input-port</primary>
</indexterm>
<emphasis>Parameter current-input-port</emphasis></simpara>

<simpara>The value of this parameter is a character input port.</simpara>

<simpara><anchor id="current-output-port" xreflabel="[current-output-port]"/>
<indexterm>
  <primary>current-output-port</primary>
</indexterm>
<emphasis>Parameter current-output-port</emphasis></simpara>

<simpara>The value of this parameter is a character output port.</simpara>

<simpara><anchor id="delete-file" xreflabel="delete-file"></anchor>
<emphasis> Procedure delete-file</emphasis>
<simpara>
<indexterm><primary><code>delete-file</code></primary></indexterm>
<literal>(delete-file <emphasis>filename</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>Deletes the named file. No error is signalled if the file does not
exist.</simpara>

<simpara><anchor id="eof-object" xreflabel="eof-object"></anchor>
<emphasis> Procedure eof-object</emphasis>
<simpara>
<indexterm><primary><code>eof-object</code></primary></indexterm>
<literal>(eof-object <emphasis></emphasis>)  =&gt; <emphasis>end-of-file object</emphasis></literal>
</simpara></simpara>

<simpara><emphasis>Eof-object</emphasis> returns an end-of-file object.</simpara>

<simpara><anchor id="file-exists?" xreflabel="file-exists?"></anchor>
<emphasis> Procedure file-exists?</emphasis>
<simpara>
<indexterm><primary><code>file-exists?</code></primary></indexterm>
<literal>(file-exists? <emphasis>filename</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>File-exists? returns #t if the named file exists at the time the
procedure is called.</simpara>

<simpara><anchor id="file-modification-time" xreflabel="file-modification-time"></anchor>
<emphasis> Procedure file-modification-time</emphasis>
<simpara>
<indexterm><primary><code>file-modification-time</code></primary></indexterm>
<literal>(file-modification-time <emphasis>filename</emphasis>)  =&gt; <emphasis>vector or #f</emphasis></literal>
</simpara></simpara>

<simpara>File-modification-time returns the time of last modification of the
file as a vector, or #f if the file does not exist. The vector has six
elements: year, month, day, hour, minute, second, all of which are
exact nonnegative integers. The time returned is relative to the local
timezone.</simpara>

<simpara><literal>     (file-modification-time "larceny") =&gt; #(1997 2 6 12 51 13)</literal></simpara>

<simpara><literal>     (file-modification-time "geekdom") =&gt; #f</literal></simpara>

<simpara><anchor id="flush-output-port" xreflabel="flush-output-port"></anchor>
<emphasis> Procedure flush-output-port</emphasis>
<simpara>
<indexterm><primary><code>flush-output-port</code></primary></indexterm>
<literal>(flush-output-port <emphasis></emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara>
<simpara><literal>(flush-output-port <emphasis>port</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara>Write any buffered data in the port to the underlying output medium.</simpara>

<simpara><anchor id="get-output-string" xreflabel="get-output-string"></anchor>
<emphasis> Procedure get-output-string</emphasis>
<simpara>
<indexterm><primary><code>get-output-string</code></primary></indexterm>
<literal>(get-output-string <emphasis>string-output-port</emphasis>)  =&gt; <emphasis>string</emphasis></literal>
</simpara></simpara>

<simpara>Retrieve the output string from the given string output port.</simpara>

<simpara><anchor id="open-input-string" xreflabel="open-input-string"></anchor>
<emphasis> Procedure open-input-string</emphasis>
<simpara>
<indexterm><primary><code>open-input-string</code></primary></indexterm>
<literal>(open-input-string <emphasis>string</emphasis>)  =&gt; <emphasis>input-port</emphasis></literal>
</simpara></simpara>

<simpara>Creates an input port that reads from <emphasis>string</emphasis>. The string may be
shared with the caller. A string input port does not need to be
closed, although closing it will prevent further reads from it.</simpara>

<simpara><anchor id="open-output-string" xreflabel="open-output-string"></anchor>
<emphasis> Procedure open-output-string</emphasis>
<simpara>
<indexterm><primary><code>open-output-string</code></primary></indexterm>
<literal>(open-output-string <emphasis></emphasis>)  =&gt; <emphasis>output-port</emphasis></literal>
</simpara></simpara>

<simpara>Creates an output port where any output is written to a string. The
accumulated string can be retrieved with
<xref linkend="get-output-string"/> at any time.</simpara>

<simpara><anchor id="port?" xreflabel="port?"></anchor>
<emphasis> Procedure port?</emphasis>
<simpara>
<indexterm><primary><code>port?</code></primary></indexterm>
<literal>(port? <emphasis>object</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>Tests whether its argument is a port.</simpara>

<simpara><anchor id="port-name" xreflabel="port-name"></anchor>
<emphasis> Procedure port-name</emphasis>
<simpara>
<indexterm><primary><code>port-name</code></primary></indexterm>
<literal>(port-name <emphasis>port</emphasis>)  =&gt; <emphasis>string</emphasis></literal>
</simpara></simpara>

<simpara>Returns the name associated with the port; for file ports, this is the file name.</simpara>

<simpara><anchor id="port-position" xreflabel="port-position"></anchor>
<emphasis> Procedure port-position</emphasis>
<simpara>
<indexterm><primary><code>port-position</code></primary></indexterm>
<literal>(port-position <emphasis>port</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns the number of characters that have been read from or written to the port.</simpara>

<simpara><anchor id="rename-file" xreflabel="rename-file"></anchor>
<emphasis> Procedure rename-file</emphasis>
<simpara>
<indexterm><primary><code>rename-file</code></primary></indexterm>
<literal>(rename-file <emphasis>from to</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>Renames the file <emphasis>from</emphasis> and gives it the name <emphasis>to</emphasis>. No error is
signalled if <emphasis>from</emphasis> does not exist or <emphasis>to</emphasis> exists.</simpara>

<simpara><anchor id="reset-output-string" xreflabel="reset-output-string"></anchor>
<emphasis> Procedure reset-output-string</emphasis>
<simpara>
<indexterm><primary><code>reset-output-string</code></primary></indexterm>
<literal>(reset-output-string <emphasis>port</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>Given a <emphasis>port</emphasis> created with <emphasis>open-output-string</emphasis>, deletes from the
port all the characters that have been output so far.</simpara>

<simpara><anchor id="with-input-from-port" xreflabel="with-input-from-port"></anchor>
<emphasis> Procedure with-input-from-port</emphasis>
<simpara>
<indexterm><primary><code>with-input-from-port</code></primary></indexterm>
<literal>(with-input-from-port <emphasis>input-port thunk</emphasis>)  =&gt; <emphasis>object</emphasis></literal>
</simpara></simpara>

<simpara>Calls <emphasis>thunk</emphasis> with current input bound to <emphasis>input-port</emphasis> in the dynamic
extent of <emphasis>thunk</emphasis>. Returns whatever value was returned from <emphasis>thunk</emphasis>.</simpara>

<simpara><anchor id="with-output-to-port" xreflabel="with-output-to-port"></anchor>
<emphasis> Procedure with-output-to-port</emphasis>
<simpara>
<indexterm><primary><code>with-output-to-port</code></primary></indexterm>
<literal>(with-output-to-port <emphasis>output-port thunk</emphasis>)  =&gt; <emphasis>object</emphasis></literal>
</simpara></simpara>

<simpara>Calls <emphasis>thunk</emphasis> with current output bound to <emphasis>output-port</emphasis> in the
dynamic extent of <emphasis>thunk</emphasis>. Returns whatever value was returned from
<emphasis>thunk</emphasis>.</simpara>

</section>
<section>
<title>Operating System Interface</title>
<simpara><anchor id="command-line-arguments" xreflabel="command-line-arguments"></anchor>
<emphasis> Procedure command-line-arguments</emphasis>
<simpara>
<indexterm><primary><code>command-line-arguments</code></primary></indexterm>
<literal>(command-line-arguments <emphasis></emphasis>)  =&gt; <emphasis>vector</emphasis></literal>
</simpara></simpara>

<simpara>Returns a vector of strings: the arguments supplied to the program by
the user or the operating system.</simpara>

<simpara><anchor id="dump-heap" xreflabel="dump-heap"></anchor>
<emphasis> Procedure dump-heap</emphasis>
<simpara>
<indexterm><primary><code>dump-heap</code></primary></indexterm>
<literal>(dump-heap <emphasis>filename procedure</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>Dump a heap image to the named file that will start up with the
supplied procedure. Before <emphasis>procedure</emphasis> is called, command line
arguments will be parsed and any init procedures registered with
<literal>add-init-procedure!</literal>  will be called.</simpara>

<simpara><emphasis>Note: Currently, heap dumping is only available with the
stop-and-copy collector (<literal>-stopcopy</literal> command line option), although the
heap image can be used with all the other collectors.</emphasis></simpara>

<simpara><anchor id="dump-interactive-heap" xreflabel="dump-interactive-heap"></anchor>
<emphasis> Procedure dump-interactive-heap</emphasis>
<simpara>
<indexterm><primary><code>dump-interactive-heap</code></primary></indexterm>
<literal>(dump-interactive-heap <emphasis>filename</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>Dump a heap image to the named file that will start up with the
standard read-eval-print loop. Before the read-eval-print loop is
called, command line arguments will be parsed and any init procedures
registered with <literal>add-init-procedure!</literal>
will be called.</simpara>

<simpara><emphasis>Note: Currently, heap dumping is only available with the
stop-and-copy collector (<literal>-stopcopy</literal> command line option), although the
heap image can be used with all the other collectors.</emphasis></simpara>

<simpara><anchor id="getenv" xreflabel="getenv"></anchor>
<emphasis> Procedure getenv</emphasis>
<simpara>
<indexterm><primary><code>getenv</code></primary></indexterm>
<literal>(getenv <emphasis>key</emphasis>)  =&gt; <emphasis>string or #f</emphasis></literal>
</simpara></simpara>

<simpara>Returns the operating system environment mapping for the string <emphasis>key</emphasis>,
or <literal>#f</literal> if there is no mapping for <emphasis>key</emphasis>.</simpara>

<simpara><anchor id="system" xreflabel="system"></anchor>
<emphasis> Procedure system</emphasis>
<simpara>
<indexterm><primary><code>system</code></primary></indexterm>
<literal>(system <emphasis>command</emphasis>)  =&gt; <emphasis>status</emphasis></literal>
</simpara></simpara>

<simpara>Send the <emphasis>command</emphasis> to the operating system's command processor and
return the command's exit status, if any. On Unix, <emphasis>command</emphasis> is a
string and <emphasis>status</emphasis> is an exact integer.</simpara>

</section>
<section id="FixnumPrimitives">
<title>Fixnum primitives</title>
<simpara>Fixnums are small exact integers that are likely to be
represented without heap
allocation. Larceny never represents a number that can be
represented as a fixnum any other way, so programs that can use
fixnums will do so automatically. However, operations that work only
on fixnums can sometimes be substantially faster than generic
operations, and the following primitives are provided for use in those
programs that need especially good performance.</simpara>

<simpara>The <literal>(rnrs arithmetic fixnums)</literal> library now
provides a large set of procedures that, in Larceny, are
defined using the procedures described below.
If one of Larceny's procedures duplicates the semantics of
an R6RS procedure whose name is different, then Larceny's
name is deprecated.</simpara>

<simpara>All arguments to the following procedures must be fixnums.</simpara>

<simpara><anchor id="fixnum?" xreflabel="fixnum?"></anchor>
<emphasis> Procedure fixnum?</emphasis>
<simpara>
<indexterm><primary><code>fixnum?</code></primary></indexterm>
<literal>(fixnum? <emphasis>obj</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>Returns <literal>#t</literal> if its argument is a fixnum, and <literal>#f</literal> otherwise.</simpara>

<simpara><anchor id="fx+" xreflabel="fx+"></anchor>
<emphasis> Procedure fx+</emphasis>
<simpara>
<indexterm><primary><code>fx+</code></primary></indexterm>
<literal>(fx+ <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns the fixnum sum of its arguments. If the result is not
representable as a fixnum, then an error is signalled (unless error
checking has been disabled).</simpara>

<simpara><anchor id="fx-" xreflabel="fx-"></anchor>
<emphasis> Procedure fx-</emphasis>
<simpara>
<indexterm><primary><code>fx-</code></primary></indexterm>
</simpara></simpara>

<simpara>Returns the fixnum difference of its arguments. If the result is not
representable as a fixnum, then an error is signalled.</simpara>

<simpara><anchor id="fx&#8212;" xreflabel="fx&#8212;"></anchor>
<emphasis> Procedure fx&#8212;</emphasis>
<simpara>
<indexterm><primary><code>fx&#8212;</code></primary></indexterm>
<literal>(fx&#8212; <emphasis>fix1</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns the fixnum negative of its argument. If the result is not
representable as a fixnum, then an error is signalled.</simpara>

<simpara><anchor id="fx*" xreflabel="fx*"></anchor>
<emphasis> Procedure fx*</emphasis>
<simpara>
<indexterm><primary><code>fx*</code></primary></indexterm>
<literal>(fx* <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns the fixnum product of its arguments. If the result is not
representable as a fixnum, then an error is signalled.</simpara>

<simpara><anchor id="fx=" xreflabel="fx="></anchor>
<emphasis> Procedure fx=</emphasis>
<simpara>
<indexterm><primary><code>fx=</code></primary></indexterm>
<literal>(fx= <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>Returns <literal>#t</literal> if its arguments are equal, and <literal>#f</literal> otherwise.</simpara>

<simpara><anchor id="fx&lt;" xreflabel="fx&lt;"></anchor>
<emphasis> Procedure fx&lt;</emphasis>
<simpara>
<indexterm><primary><code>fx&lt;</code></primary></indexterm>
<literal>(fx&lt; <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>Returns <literal>#t</literal> if <emphasis>fix1</emphasis> is less than <emphasis>fix2</emphasis>, and <literal>#f</literal> otherwise.</simpara>

<simpara><anchor id="fx&lt;=" xreflabel="fx&lt;="></anchor>
<emphasis> Procedure fx&lt;=</emphasis>
<simpara>
<indexterm><primary><code>fx&lt;=</code></primary></indexterm>
<literal>(fx&lt;= <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>Returns <literal>#t</literal> if <emphasis>fix1</emphasis> is less than or equal to <emphasis>fix2</emphasis>, and <literal>#f</literal>
otherwise.</simpara>

<simpara><anchor id="fx&gt;" xreflabel="fx&gt;"></anchor>
<emphasis> Procedure fx&gt;</emphasis>
<simpara>
<indexterm><primary><code>fx&gt;</code></primary></indexterm>
<literal>(fx&gt; <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>Returns <literal>#t</literal> if <emphasis>fix1</emphasis> is greater than <emphasis>fix2</emphasis>, and <literal>#f</literal> otherwise.</simpara>

<simpara><anchor id="fx&gt;=" xreflabel="fx&gt;="></anchor>
<emphasis> Procedure fx&gt;=</emphasis>
<simpara>
<indexterm><primary><code>fx&gt;=</code></primary></indexterm>
<literal>(fx&gt;= <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>Returns <literal>#t</literal> if <emphasis>fix1</emphasis> is greater than or equal to <emphasis>fix2</emphasis>, and <literal>#f</literal>
otherwise.</simpara>

<simpara><anchor id="fxnegative?" xreflabel="fxnegative?"></anchor>
<emphasis> Procedure fxnegative?</emphasis>
<simpara>
<indexterm><primary><code>fxnegative?</code></primary></indexterm>
<literal>(fxnegative? <emphasis>fix</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>Returns <literal>#t</literal> if its argument is less than zero, and <literal>#f</literal> otherwise.</simpara>

<simpara><anchor id="fxpositive?" xreflabel="fxpositive?"></anchor>
<emphasis> Procedure fxpositive?</emphasis>
<simpara>
<indexterm><primary><code>fxpositive?</code></primary></indexterm>
<literal>(fxpositive? <emphasis>fix</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>Returns <literal>#t</literal> if its argument is greater than zero, and <literal>#f</literal> otherwise.</simpara>

<simpara><anchor id="fxzero?" xreflabel="fxzero?"></anchor>
<emphasis> Procedure fxzero?</emphasis>
<simpara>
<indexterm><primary><code>fxzero?</code></primary></indexterm>
<literal>(fxzero? <emphasis>fix</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>Returns <literal>#t</literal> if its argument is zero, and <literal>#f</literal> otherwise.</simpara>

<simpara><anchor id="fxlogand" xreflabel="fxlogand"></anchor>
<emphasis> Procedure fxlogand</emphasis>
<simpara>
<indexterm><primary><code>fxlogand</code></primary></indexterm>
<literal>(fxlogand <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns the bitwise <emphasis>and</emphasis> of its arguments.</simpara>

<simpara><anchor id="fxlogior" xreflabel="fxlogior"></anchor>
<emphasis> Procedure fxlogior</emphasis>
<simpara>
<indexterm><primary><code>fxlogior</code></primary></indexterm>
<literal>(fxlogior <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns the bitwise <emphasis>inclusive or</emphasis> of its arguments.</simpara>

<simpara><anchor id="fxlognot" xreflabel="fxlognot"></anchor>
<emphasis> Procedure fxlognot</emphasis>
<simpara>
<indexterm><primary><code>fxlognot</code></primary></indexterm>
<literal>(fxlognot <emphasis>fix</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns the bitwise <emphasis>not</emphasis> of its argument.</simpara>

<simpara><anchor id="fxlogxor" xreflabel="fxlogxor"></anchor>
<emphasis> Procedure fxlogxor</emphasis>
<simpara>
<indexterm><primary><code>fxlogxor</code></primary></indexterm>
<literal>(fxlogxor <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns the bitwise <emphasis>exclusive or</emphasis> of its arguments.</simpara>

<simpara><anchor id="fxlsh" xreflabel="fxlsh"></anchor>
<emphasis> Procedure fxlsh</emphasis>
<simpara>
<indexterm><primary><code>fxlsh</code></primary></indexterm>
<literal>(fxlsh <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns <emphasis>fix1</emphasis> shifted left <emphasis>fix2</emphasis> places, shifting in zero bits at
the low end. If the shift count exceeds the number of bits in the
machine's word size, then the results are machine-dependent.</simpara>

<simpara><anchor id="most-positive-fixnum" xreflabel="most-positive-fixnum"></anchor>
<emphasis> Procedure most-positive-fixnum</emphasis>
<simpara>
<indexterm><primary><code>most-positive-fixnum</code></primary></indexterm>
<literal>(most-positive-fixnum <emphasis></emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns the largest representable positive fixnum.</simpara>

<simpara><anchor id="most-negative-fixnum" xreflabel="most-negative-fixnum"></anchor>
<emphasis> Procedure most-negative-fixnum</emphasis>
<simpara>
<indexterm><primary><code>most-negative-fixnum</code></primary></indexterm>
<literal>(most-negative-fixnum <emphasis></emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns the smallest representable negative fixnum.</simpara>

<simpara><anchor id="fxrsha" xreflabel="fxrsha"></anchor>
<emphasis> Procedure fxrsha</emphasis>
<simpara>
<indexterm><primary><code>fxrsha</code></primary></indexterm>
<literal>(fxrsha <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns <emphasis>fix1</emphasis> shifted right <emphasis>fix2</emphasis> places, shifting in a copy of the
sign bit at the left end. If the shift count exceeds the number of
bits in the machine's word size, then the results are
machine-dependent.</simpara>

<simpara><anchor id="fxrshl" xreflabel="fxrshl"></anchor>
<emphasis> Procedure fxrshl</emphasis>
<simpara>
<indexterm><primary><code>fxrshl</code></primary></indexterm>
<literal>(fxrshl <emphasis>fix1 fix2</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns <emphasis>fix1</emphasis> shifted right <emphasis>fix2</emphasis> places, shifting in zero bits at
the high end. If the shift count exceeds the number of bits in the
machine's word size, then the results are machine-dependent.</simpara>

</section>
<section>
<title>Numbers</title>
<simpara>Larceny has six representations for numbers: <emphasis>fixnums</emphasis> are small,
exact integers; <emphasis>bignums</emphasis> are unlimited-precision exact integers;
<emphasis>ratnums</emphasis> are exact rationals; <emphasis>flonums</emphasis> are inexact rationals;
<emphasis>rectnums</emphasis> are exact complexes; and <emphasis>compnums</emphasis> are inexact complexes.</simpara>

<simpara><emphasis>Number-representation predicates</emphasis></simpara>

<simpara><simpara><literal>(fixnum? <emphasis>obj</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal></simpara>
<simpara><literal>(bignum? <emphasis>obj</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal></simpara>
<simpara><literal>(ratnum? <emphasis>obj</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal></simpara>
<simpara><literal>(flonum? <emphasis>obj</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal></simpara>
<simpara><literal>(rectnum? <emphasis>obj</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal></simpara>
<simpara><literal>(compnum? <emphasis>obj</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal></simpara></simpara>

<simpara>These predicates test whether an object is a number of a particular
representation and return <literal>#t</literal> if so, <literal>#f</literal> if not.</simpara>

<simpara><anchor id="random" xreflabel="random"></anchor>
<emphasis> Procedure random</emphasis>
<simpara>
<indexterm><primary><code>random</code></primary></indexterm>
<literal>(random <emphasis>limit</emphasis>)  =&gt; <emphasis>exact integer</emphasis></literal>
</simpara></simpara>

<simpara>Returns a pseudorandom nonnegative exact integer in the range 0
through <emphasis>limit</emphasis>-1.</simpara>

</section>
<section>
<title>Hashtables and hash functions</title>
<simpara>Hashtables represent finite mappings from keys to values.
If the hash function is a good one, then the value associated
with a key may be looked up in constant time (on the average).</simpara>

<note>
<simpara>The R6RS hashtables library are a big improvement
over Larceny's traditional hash tables, and should be used
instead of the API described below.</simpara>

</note>
<note>
<simpara>To resolve a clash of names and semantics with the
R6RS <literal>make-hashtable</literal> procedure, Larceny's traditional
<literal>make-hashtable</literal> procedure has been renamed to
<literal>make-oldstyle-hashtable</literal>.</simpara>

</note>
<section>
<title>Hash tables</title>
<simpara><anchor id="make-oldstyle-hashtable" xreflabel="make-oldstyle-hashtable"></anchor>
<emphasis> Procedure make-oldstyle-hashtable</emphasis>
<simpara>
<indexterm><primary><code>make-oldstyle-hashtable</code></primary></indexterm>
<literal>(make-oldstyle-hashtable <emphasis>hash-function bucket-searcher size</emphasis>)  =&gt; <emphasis>hashtable</emphasis></literal>
</simpara></simpara>

<simpara>Returns a newly allocated mutable hash table using <emphasis>hash-function</emphasis> as
the hash function and <emphasis>bucket-searcher</emphasis>, e.g. <literal>assq</literal>, <literal>assv</literal>, <literal>assoc</literal>, to
search a bucket with <emphasis>size</emphasis> buckets at first, expanding the number of
buckets as needed. The <emphasis>hash-function</emphasis> must accept a key and return a
non-negative exact integer.</simpara>

<simpara><simpara><literal>(make-oldstyle-hashtable <emphasis>hash-function bucket-searcher</emphasis>)  =&gt; <emphasis>hashtable</emphasis></literal></simpara></simpara>

<simpara>Equivalent to <literal>(make-oldstyle-hashtable <emphasis>hash-function bucket-searcher n</emphasis>)</literal> for
some value of <emphasis>n</emphasis> chosen by the implementation.</simpara>

<simpara><simpara><literal>(make-oldstyle-hashtable <emphasis>hash-function</emphasis>)  =&gt; <emphasis>hashtable</emphasis></literal></simpara></simpara>

<simpara>Equivalent to <literal>(make-oldstyle-hashtable <emphasis>hash-function</emphasis> assv)</literal>.</simpara>

<simpara><simpara><literal>(make-oldstyle-hashtable <emphasis></emphasis>)  =&gt; <emphasis>hashtable</emphasis></literal></simpara></simpara>

<simpara>Equivalent to <literal>(make-oldstyle-hashtable object-hash assv)</literal>.</simpara>

<simpara><anchor id="hashtable-contains?" xreflabel="hashtable-contains?"></anchor>
<emphasis> Procedure hashtable-contains?</emphasis>
<simpara>
<indexterm><primary><code>hashtable-contains?</code></primary></indexterm>
<literal>(hashtable-contains? <emphasis>hashtable key</emphasis>)  =&gt; <emphasis>bool</emphasis></literal>
</simpara></simpara>

<simpara>Returns true iff the <emphasis>hashtable</emphasis> contains an entry for <emphasis>key</emphasis>.</simpara>

<simpara><anchor id="hashtable-fetch" xreflabel="hashtable-fetch"></anchor>
<emphasis> Procedure hashtable-fetch</emphasis>
<simpara>
<indexterm><primary><code>hashtable-fetch</code></primary></indexterm>
<literal>(hashtable-fetch <emphasis>hashtable key flag</emphasis>)  =&gt; <emphasis>object</emphasis></literal>
</simpara></simpara>

<simpara>Returns the value associated with <emphasis>key</emphasis> in the <emphasis>hashtable</emphasis> if the
<emphasis>hashtable</emphasis> contains <emphasis>key</emphasis>; otherwise returns <emphasis>flag</emphasis>.</simpara>

<simpara><anchor id="hashtable-get" xreflabel="hashtable-get"></anchor>
<emphasis> Procedure hashtable-get</emphasis>
<simpara>
<indexterm><primary><code>hashtable-get</code></primary></indexterm>
<literal>(hashtable-get <emphasis>hashtable key</emphasis>)  =&gt; <emphasis>object</emphasis></literal>
</simpara></simpara>

<simpara>Equivalent to <literal>(hashtable-fetch  #f)</literal>.</simpara>

<simpara><anchor id="hashtable-put!" xreflabel="hashtable-put!"></anchor>
<emphasis> Procedure hashtable-put!</emphasis>
<simpara>
<indexterm><primary><code>hashtable-put!</code></primary></indexterm>
<literal>(hashtable-put! <emphasis>hashtable key value</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>Changes the <emphasis>hashtable</emphasis> to associate <emphasis>key</emphasis> with <emphasis>value</emphasis>, replacing any
existing association for <emphasis>key</emphasis>.</simpara>

<simpara><anchor id="hashtable-remove!" xreflabel="hashtable-remove!"></anchor>
<emphasis> Procedure hashtable-remove!</emphasis>
<simpara>
<indexterm><primary><code>hashtable-remove!</code></primary></indexterm>
<literal>(hashtable-remove! <emphasis>hashtable key</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>Removes any association for <emphasis>key</emphasis> within the <emphasis>hashtable</emphasis>.</simpara>

<simpara><anchor id="hashtable-clear!" xreflabel="hashtable-clear!"></anchor>
<emphasis> Procedure hashtable-clear!</emphasis>
<simpara>
<indexterm><primary><code>hashtable-clear!</code></primary></indexterm>
<literal>(hashtable-clear! <emphasis>hashtable</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>Removes all associations from the <emphasis>hashtable</emphasis>.</simpara>

<simpara><anchor id="hashtable-size" xreflabel="hashtable-size"></anchor>
<emphasis> Procedure hashtable-size</emphasis>
<simpara>
<indexterm><primary><code>hashtable-size</code></primary></indexterm>
<literal>(hashtable-size <emphasis>hashtable</emphasis>)  =&gt; <emphasis>integer</emphasis></literal>
</simpara></simpara>

<simpara>Returns the number of keys contained within the <emphasis>hashtable</emphasis>.</simpara>

<simpara><anchor id="hashtable-for-each" xreflabel="hashtable-for-each"></anchor>
<emphasis> Procedure hashtable-for-each</emphasis>
<simpara>
<indexterm><primary><code>hashtable-for-each</code></primary></indexterm>
<literal>(hashtable-for-each <emphasis>procedure hashtable</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>The <emphasis>procedure</emphasis> must accept two arguments, a key and the value
associated with that key. Calls the <emphasis>procedure</emphasis> once for each
key-value association in <emphasis>hashtable</emphasis>. The order of these calls is
indeterminate.</simpara>

<simpara><anchor id="hashtable-map" xreflabel="hashtable-map"></anchor>
<emphasis> Procedure hashtable-map</emphasis>
<simpara>
<indexterm><primary><code>hashtable-map</code></primary></indexterm>
<literal>(hashtable-map <emphasis>procedure hashtable</emphasis>) </literal>
</simpara></simpara>

<simpara>The <emphasis>procedure</emphasis> must accept two arguments, a key and the value
associated with that key. Calls the <emphasis>procedure</emphasis> once for each
key-value association in <emphasis>hashtable</emphasis>, and returns a list of the
results. The order of the calls is indeterminate.</simpara>

<simpara><anchor id="hashtable-copy" xreflabel="hashtable-copy"></anchor>
<emphasis> Procedure hashtable-copy</emphasis>
<simpara>
<indexterm><primary><code>hashtable-copy</code></primary></indexterm>
<literal>(hashtable-copy <emphasis>hashtable</emphasis>)  =&gt; <emphasis>hashtable</emphasis></literal>
</simpara></simpara>

<simpara>Returns a copy of the <emphasis>hashtable</emphasis>.</simpara>

</section>
<section>
<title>Hash functions</title>
<simpara>The <emphasis>hash values</emphasis> returned by these functions are nonnegative exact
integer suitable as hash values for the hashtable functions.</simpara>

<simpara><anchor id="equal-hash" xreflabel="equal-hash"></anchor>
<emphasis> Procedure equal-hash</emphasis>
<simpara>
<indexterm><primary><code>equal-hash</code></primary></indexterm>
<literal>(equal-hash <emphasis>object</emphasis>)  =&gt; <emphasis>integer</emphasis></literal>
</simpara></simpara>

<simpara>Returns a hash value for <emphasis>object</emphasis> based on its contents.</simpara>

<simpara><anchor id="object-hash" xreflabel="object-hash"></anchor>
<emphasis> Procedure object-hash</emphasis>
<simpara>
<indexterm><primary><code>object-hash</code></primary></indexterm>
<literal>(object-hash <emphasis>object</emphasis>)  =&gt; <emphasis>integer</emphasis></literal>
</simpara></simpara>

<simpara>Returns a hash value for <emphasis>object</emphasis> based on its identity.</simpara>

<warning>
<simpara>This hash function performs extremely poorly on pairs,
vectors, strings, and bytevectors, which are the objects
with which it is mostly likely to be used.
For efficient hashing on object identity, create the
hashtable with <literal>make-eq-hashtable</literal> or <literal>make-eqv-hashtable</literal>
of the <literal>(rnrs hashtables)</literal> library.</simpara>

</warning>
<simpara><anchor id="string-hash" xreflabel="string-hash"></anchor>
<emphasis> Procedure string-hash</emphasis>
<simpara>
<indexterm><primary><code>string-hash</code></primary></indexterm>
<literal>(string-hash <emphasis>string</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns a hash value for <emphasis>string</emphasis> based on its content.</simpara>

<simpara><anchor id="symbol-hash" xreflabel="symbol-hash"></anchor>
<emphasis> Procedure symbol-hash</emphasis>
<simpara>
<indexterm><primary><code>symbol-hash</code></primary></indexterm>
<literal>(symbol-hash <emphasis>symbol</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara>Returns a hash value for <emphasis>symbol</emphasis> based on its print name.
The <literal>symbol-hash</literal>
is very fast, because the hash code is cached in the symbol data
structure.</simpara>

</section>
</section>
<section>
<title>Parameters</title>
<simpara>Parameters are procedures that serve as containers for values; parts
of the system that do not operate in the same namespace can still
share parameters and thereby read and write shared state.</simpara>

<simpara>A parameter takes zero or one arguments. If called with no arguments,
it returns the current value of the parameter. If called with one
argument, it sets the parameter's value to that of the argument and
returns the new value.</simpara>

<simpara><anchor id="make-parameter" xreflabel="make-parameter"></anchor>
<emphasis> Procedure make-parameter</emphasis>
<simpara>
<indexterm><primary><code>make-parameter</code></primary></indexterm>
<literal>(make-parameter <emphasis>name value</emphasis> <emphasis>[predicate]</emphasis>)  =&gt; <emphasis>procedure</emphasis></literal>
</simpara></simpara>

<simpara>Create a parameter with name <emphasis>name,</emphasis> initial value <emphasis>value,</emphasis> and
optional setter predicate <emphasis>predicate.</emphasis> When the parameter is set the
new value is first passed to <emphasis>predicate,</emphasis>, and if it returns <literal>#f</literal> then
an error is signalled. <emphasis>Name</emphasis> can be a symbol or a string.</simpara>

<simpara><emphasis>Syntax parameterize</emphasis></simpara>

<simpara><literal> (parameterize ((parameter0 value0) &#8230;) expr0 expr1 &#8230;)</literal></simpara>

<simpara>Parameterize overrides the values of a set of parameters in a dynamic
scope &#8212; it is like fluid-let for parameters.</simpara>

<section>
<title>Larceny parameters</title>
<simpara>The following list of parameters does not yet include the reader or
compiler switches, which are also parameters.</simpara>

<simpara><ulink url="debugging.html#proc:break-handler">Parameter <literal>break-handler</literal></ulink></simpara>

<simpara><ulink url="io.html#proc:console-input-port-factory">Parameter <literal>console-input-port-factory</literal></ulink></simpara>

<simpara><ulink url="io.html#proc:console-output-port-factory">Parameter <literal>console-output-port-factory</literal></ulink></simpara>

<simpara><ulink url="io.html#proc:current-input-port">Parameter <literal>current-input-port</literal></ulink></simpara>

<simpara><ulink url="io.html#proc:current-output-port">Parameter <literal>current-output-port</literal></ulink></simpara>

<simpara><ulink url="control.html#proc:error-handler">Parameter <literal>error-handler</literal></ulink></simpara>

<simpara><ulink url="control.html#proc:evaluator">Parameter <literal>evaluator</literal></ulink></simpara>

<simpara><ulink url="repl.html#proc:herald">Parameter <literal>herald</literal></ulink></simpara>

<simpara><ulink url="environ.html#proc:interaction-environment">Parameter <literal>interaction-environment</literal></ulink></simpara>

<simpara><ulink url="control.html#proc:keyboard-interrupt-handler">Parameter <literal>keyboard-interrupt-handler</literal></ulink></simpara>

<simpara><ulink url="control.html#proc:load-evaluator">Parameter <literal>load-evaluator</literal></ulink></simpara>

<simpara><ulink url="control.html#proc:quit-handler">Parameter <literal>quit-handler</literal></ulink></simpara>

<simpara><ulink url="repl.html#proc:repl-level">Parameter <literal>repl-level</literal></ulink></simpara>

<simpara><ulink url="repl.html#proc:repl-evaluator">Parameter <literal>repl-evaluator</literal></ulink></simpara>

<simpara><ulink url="repl.html#proc:repl-printer">Parameter <literal>repl-printer</literal></ulink></simpara>

<simpara><ulink url="control.html#proc:reset-handler">Parameter <literal>reset-handler</literal></ulink></simpara>

<simpara><ulink url="control.html#proc:standard-timeslice">Parameter <literal>standard-timeslice</literal></ulink></simpara>

<simpara><ulink url="structures.html#proc:structure-comparator">Parameter <literal>structure-comparator</literal></ulink></simpara>

<simpara><ulink url="structures.html#proc:structure-printer">Parameter <literal>structure-printer</literal></ulink></simpara>

<simpara><ulink url="control.html#proc:timer-interrupt-handler">Parameter <literal>timer-interrupt-handler</literal></ulink></simpara>

</section>
</section>
<section>
<title>Property Lists</title>
<simpara>The <emphasis>property list</emphasis> of a symbol is an association list that is
attached to that symbol. The association list maps <emphasis>properties</emphasis>, which
are themselves symbols, to arbitrary values.</simpara>

<simpara><anchor id="putprop" xreflabel="putprop"></anchor>
<emphasis> Procedure putprop</emphasis>
<simpara>
<indexterm><primary><code>putprop</code></primary></indexterm>
<literal>(putprop <emphasis>symbol property obj</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>If an association exists for <emphasis>property</emphasis> on the property list of
<emphasis>symbol</emphasis>, then its value is replaced by the new value
<emphasis>obj</emphasis>. Otherwise, a new association is added to the property list of
<emphasis>symbol</emphasis> that associates <emphasis>property</emphasis> with <emphasis>obj</emphasis>.</simpara>

<simpara><anchor id="getprop" xreflabel="getprop"></anchor>
<emphasis> Procedure getprop</emphasis>
<simpara>
<indexterm><primary><code>getprop</code></primary></indexterm>
<literal>(getprop <emphasis>symbol property</emphasis>)  =&gt; <emphasis>obj</emphasis></literal>
</simpara></simpara>

<simpara>If an association exists for <emphasis>property</emphasis> on the property list of
<emphasis>symbol</emphasis>, then its value is returned. Otherwise, <literal>#f</literal> is returned.</simpara>

<simpara><anchor id="remprop" xreflabel="remprop"></anchor>
<emphasis> Procedure remprop</emphasis>
<simpara>
<indexterm><primary><code>remprop</code></primary></indexterm>
<literal>(remprop <emphasis>symbol property</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>If an association exists for <emphasis>property</emphasis> on the property list of
<emphasis>symbol</emphasis>, then that association is removed. Otherwise, this is a
no-op.</simpara>

</section>
<section>
<title>Symbols</title>
<simpara><anchor id="gensym" xreflabel="gensym"></anchor>
<emphasis> Procedure gensym</emphasis>
<simpara>
<indexterm><primary><code>gensym</code></primary></indexterm>
<literal>(gensym <emphasis>string</emphasis>)  =&gt; <emphasis>symbol</emphasis></literal>
</simpara></simpara>

<simpara>Gensym returns a new uninterned symbol, the name of which contains the
given <emphasis>string.</emphasis></simpara>

<simpara><anchor id="oblist" xreflabel="oblist"></anchor>
<emphasis> Procedure oblist</emphasis>
<simpara>
<indexterm><primary><code>oblist</code></primary></indexterm>
<literal>(oblist <emphasis></emphasis>)  =&gt; <emphasis>list</emphasis></literal>
</simpara></simpara>

<simpara>Oblist returns the list of interned symbols.</simpara>

<simpara><anchor id="oblist-set!" xreflabel="oblist-set!"></anchor>
<emphasis> Procedure oblist-set!</emphasis>
<simpara>
<indexterm><primary><code>oblist-set!</code></primary></indexterm>
<literal>(oblist-set! <emphasis>list</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara>
<simpara><literal>(oblist-set! <emphasis>list table-size</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara><literal>oblist-set!</literal> sets the list of interned symbols to those in the given
<emphasis>list</emphasis> by clearing the symbol hash table and storing the symbols in
<emphasis>list</emphasis> in the hash table. If the optional <emphasis>table-size</emphasis> is given, it is
taken to be the desired size of the new symbol table.</simpara>

<simpara>See also: <xref linkend="symbol-hash"/>.</simpara>

</section>
<section>
<title>System Control and Performance Measurement</title>
<simpara><anchor id="collect" xreflabel="collect"></anchor>
<emphasis> Procedure collect</emphasis>
<simpara>
<indexterm><primary><code>collect</code></primary></indexterm>
<literal>(collect <emphasis></emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara>
<simpara><literal>(collect <emphasis>generation</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(collect <emphasis>generation method</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara>Collect initiates a garbage collection. If the system has multiple
generations, then the optional arguments are interpreted as
follows. The <emphasis>generation</emphasis> is the generation to collect, where 0 is the
youngest generation. The <emphasis>method</emphasis> determines how the collection is
performed. If <emphasis>method</emphasis> is the symbol collect, then a full collection
is performed in that generation, whatever that means &#8212; in a normal
multi-generational copying collector, it means that all live objects
in the generation's current semispace and all live objects from all
younger generations are copied into the generation's other
semispace. If <emphasis>method</emphasis> is the symbol promote, then live objects are
promoted from younger generations into the target generation &#8212; in our
example collector, that means that the objects are copied into the
target generation's current semispace.</simpara>

<simpara>The default value for <emphasis>generation</emphasis> is 0, and the default value for
<emphasis>method</emphasis> is collect.</simpara>

<simpara>Note that the collector's internal policy settings may cause it to
perform a more major type of collection than the one requested; for
example, an attempt to collect generation 2 could cause the collector
to promote all live data into generation 3.</simpara>

<simpara><anchor id="gc-counter" xreflabel="gc-counter"></anchor>
<emphasis> Procedure gc-counter</emphasis>
<simpara>
<indexterm><primary><code>gc-counter</code></primary></indexterm>
<literal>(gc-counter <emphasis></emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara><emphasis>gc-counter</emphasis> returns the number of garbage collections performed since
startup. On a 32-bit system, the counter wraps around every
1,073,741,824 collections.</simpara>

<simpara><emphasis>gc-counter</emphasis> is a primitive and compiles to a single load instruction
on the SPARC.</simpara>

<simpara><anchor id="major-gc-counter" xreflabel="major-gc-counter"></anchor>
<emphasis> Procedure major-gc-counter</emphasis>
<simpara>
<indexterm><primary><code>major-gc-counter</code></primary></indexterm>
<literal>(major-gc-counter <emphasis></emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara></simpara>

<simpara><emphasis>major-gc-counter</emphasis> returns the number of major garbage collections
performed since startup, where a major collection is defined as a
collection that may change the address of objects that have already
survived a previous collection.
On a 32-bit system, the counter wraps around every
1,073,741,824 collections.</simpara>

<simpara><emphasis>major-gc-counter</emphasis> is a primitive and compiles to a single load
instruction on the SPARC.  Its primary use to implement efficient
hashtables that hash on object identity (make-eq-hashtable and
make-eqv-hashtable).</simpara>

<simpara><anchor id="gcctl" xreflabel="gcctl"></anchor>
<emphasis> Procedure gcctl</emphasis>
<simpara>
<indexterm><primary><code>gcctl</code></primary></indexterm>
<literal>(gcctl <emphasis>heap-number operation operand</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara><emphasis>[GCCTL is largely obsolete in the new garbage collector but may be
resurrected in the future. It can still be used to control the
non-predictive collector.]</emphasis></simpara>

<simpara>gcctl controls garbage collection policy on a heap-wise basis. The
<emphasis>heap-number</emphasis> is the heap to operate on, like for the command line
switches: heap 1 is the youngest. If the given heap number does not
correspond to a heap, gcctl fails silently.</simpara>

<simpara>The <emphasis>operation</emphasis> is a symbol that selects the operation to perform, and
the <emphasis>operand</emphasis> is the operand to that operation, always a number. For
the non-predictive garbage collector, the following operator/operand
pairs are meaningful:</simpara>

<itemizedlist>
<listitem>
<simpara>
j-fixed, <emphasis>n</emphasis>: after a collection, the collector parameter <emphasis>j</emphasis> should be set to the value <emphasis>n</emphasis>, if possible. (Non-predictive heaps only.)
</simpara>
</listitem>
<listitem>
<simpara>
j-percent, <emphasis>n</emphasis>: after a collection, the collector parameter <emphasis>j</emphasis> should be set to be <emphasis>n</emphasis> percent of the number of free steps. (Non-predictive heaps only.)
</simpara>
</listitem>
<listitem>
<simpara>
incr-fixed, <emphasis>n</emphasis>: when growing the heap, the growing should be done in increments of <emphasis>n</emphasis>. In the non-predictive heap, <emphasis>n</emphasis> is the number of steps. In other heaps, <emphasis>n</emphasis> denotes kilobytes.
</simpara>
</listitem>
<listitem>
<simpara>
incr-percent, <emphasis>n</emphasis>: when growing the heap, the growing should be done in increments of <emphasis>n</emphasis> percent.
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Example:</emphasis> if the non-predictive heap is heap number 2, then the expressions</simpara>

<literallayout class="monospaced">(gcctl 2 'j-fixed 0)
(gcctl 2 'incr-fixed 1)</literallayout>
<simpara>makes the non-predictive collector simulate a normal stop-and-copy
collector (because <emphasis>j</emphasis> is always set to 0), and grows the heap only
one step at a time as necessary. This may be useful for certain kinds
of experiments.</simpara>

<simpara><emphasis role="strong">Example:</emphasis> ditto, the expressions</simpara>

<literallayout class="monospaced">(gcctl 2 'j-percent 50)
(gcctl 2 'incr-percent 20)</literallayout>
<simpara>selects the default policy settings.</simpara>

<simpara><emphasis role="strong">Note</emphasis>: The gcctl facility is experimental. A more developed
  facility will allow controlling heap contraction policy, as well as
  setting all the watermarks. Certainly one can envision other uses,
  too. Finally, it needs to be possible to get current values.</simpara>

<simpara><emphasis role="strong">Note</emphasis>: Currently the non-predictive heap (np-sc-heap.c) and the
  standard stop-and-copy "old" heap (old-heap.c) are supported, but
  not the standard "young" heap (young-heap.c), nor the stop-and-copy
  collector (sc-heap.c).</simpara>

<simpara><anchor id="sro" xreflabel="sro"></anchor>
<emphasis> Procedure sro</emphasis>
<simpara>
<indexterm><primary><code>sro</code></primary></indexterm>
<literal>(sro <emphasis>pointer-tag type-tag limit</emphasis>)  =&gt; <emphasis>vector</emphasis></literal>
</simpara></simpara>

<simpara>SRO ("standing room only") is a system primitive that traverses the
entire heap and returns a vector that contains all live objects in the
heap that satisfy the constraints imposed by its parameters:</simpara>

<itemizedlist>
<listitem>
<simpara>
If <emphasis>pointer-tag</emphasis> is -1, then object type is unconstrained;
    otherwise, the object type is constrained to have a pointer tag
    that matches <emphasis>pointer-tag</emphasis>. You can read all about pointer tags
    <link linkend="LarcenyNoteRepr">here</link>, but the short story is that 1=pair, 3=vector-like,
    5=bytevector-like, and 7=procedure-like.
</simpara>
</listitem>
<listitem>
<simpara>
If <emphasis>type-tag</emphasis> is -1, then object type is unconstrained by
    type-tag; otherwise, only objects with a matching type-tag are
    selected (after selection by pointer tag). Pairs don't have
    type-tags, but other objects do. You can read all about type-tags
    <link linkend="LarcenyNoteRepr">here</link>.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>Limit</emphasis> constrains the selected objects by the number of
    references. If <emphasis>limit</emphasis> is -1, then no constraints are imposed;
    otherwise, only objects (selected by pointer-tag and type-tag)
    with no more than <emphasis>limit</emphasis> references to them are selected.
</simpara>
</listitem>
</itemizedlist>
<simpara>For example, (sro -1 -1 -1) returns a vector that contains all live
objects (not including the vector), and (sro 5 2 3) returns a vector
containing all live flonums (bytevector-like, with typetag 2) that are
referred to in no more than 3 places.</simpara>

<simpara><anchor id="stats-dump-on" xreflabel="stats-dump-on"></anchor>
<emphasis> Procedure stats-dump-on</emphasis>
<simpara>
<indexterm><primary><code>stats-dump-on</code></primary></indexterm>
<literal>(stats-dump-on <emphasis>filename</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>Stats-dump-on turns on garbage collection statistics dumping. After
each collection, a complete RTS statistics dump is appended to the
file named by <emphasis>filename</emphasis>.</simpara>

<simpara>The file format and contents are documented in a banner written at the
top of the output file. In addition, accessor procedures for the
output structure are defined in the program Util/process-stats.sch.</simpara>

<simpara>Stats-dump-on does not perform an initial dump when the file is first
opened; only at the first collection is the first set of statistics
dumped. The user might therefore want to initiate a minor collection
just after turning on dumping in order to have a baseline set of data.</simpara>

<simpara><anchor id="stats-dump-off" xreflabel="stats-dump-off"></anchor>
<emphasis> Procedure stats-dump-off</emphasis>
<simpara>
<indexterm><primary><code>stats-dump-off</code></primary></indexterm>
<literal>(stats-dump-off <emphasis></emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>Stats-dump-off turns off garbage collection statistics dumping (which
was turned on with <xref linkend="stats-dump-on"/>). It does not dump a final set
of statistics before closing the file; therefore, the user may wish to
initiate a minor collection before calling this procedure.</simpara>

<simpara><anchor id="system-features" xreflabel="system-features"></anchor>
<emphasis> Procedure system-features</emphasis>
<simpara>
<indexterm><primary><code>system-features</code></primary></indexterm>
<literal>(system-features <emphasis></emphasis>)  =&gt; <emphasis>alist</emphasis></literal>
</simpara></simpara>

<simpara>System-features returns an association lists of system features. Most
entries are self-explanatory. The following are a more subtle:</simpara>

<itemizedlist>
<listitem>
<simpara>
The value of architecture-name is Larceny's notion of the architecture for which it was compiled, not the architecture the program is currently running on. For example, the value of this feature is "Standard-C" if you're running Petit Larceny.
</simpara>
</listitem>
<listitem>
<simpara>
The value of heap-area-info is a vector of vectors, one subvector for each heap area in the running system. The subvector has four entries: the generation number, the area type, the current size, and additional information.
</simpara>
</listitem>
</itemizedlist>
<simpara><anchor id="display-memstats" xreflabel="display-memstats"></anchor>
<emphasis> Procedure display-memstats</emphasis>
<simpara>
<indexterm><primary><code>display-memstats</code></primary></indexterm>
<literal>(display-memstats <emphasis>vector</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara>
<simpara><literal>(display-memstats <emphasis>vector minimal</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(display-memstats <emphasis>vector minimal full</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara>Display-memstats takes as its argument a vector as returned by
<xref linkend="memstats"/> and displays the contents of the vector in
human-readable form on the current output port. By default, not all of
the values in the vector are displayed.</simpara>

<simpara>If the symbol minimal is passed as the second argument, then only a
small number of statistics generally relevant to running benchmarks
are displayed.</simpara>

<simpara>If the symbol full is passed as the second argument, then all
statistics are displayed.</simpara>

<simpara><anchor id="memstats" xreflabel="memstats"></anchor>
<emphasis> Procedure memstats</emphasis>
<simpara>
<indexterm><primary><code>memstats</code></primary></indexterm>
<literal>(memstats <emphasis></emphasis>)  =&gt; <emphasis>vector</emphasis></literal>
</simpara></simpara>

<simpara>Memstats returns a freshly allocated vector containing run-time-system
resource usage statistics. Many of these will make no sense whatsoever
to you unless you also study the RTS sources. A listing of the
contents of the vector is available <link linkend="SectionMemstats">here</link>.</simpara>

<simpara><anchor id="run-with-stats" xreflabel="run-with-stats"></anchor>
<emphasis> Procedure run-with-stats</emphasis>
<simpara>
<indexterm><primary><code>run-with-stats</code></primary></indexterm>
<literal>(run-with-stats <emphasis>thunk</emphasis>)  =&gt; <emphasis>obj</emphasis></literal>
</simpara></simpara>

<simpara>Run-with-stats evaluates <emphasis>thunk</emphasis>, then prints a short summary of
run-time statistics, as with</simpara>

<literallayout class="monospaced">(display-memstats ... 'minimal),</literallayout>
<simpara>and then returns the result of evaluating <emphasis>thunk</emphasis>.</simpara>

<simpara><anchor id="run-benchmark" xreflabel="run-benchmark"></anchor>
<emphasis> Procedure run-benchmark</emphasis>
<simpara>
<indexterm><primary><code>run-benchmark</code></primary></indexterm>
<literal>(run-benchmark <emphasis>name k thunk ok?</emphasis>)  =&gt; <emphasis>obj</emphasis></literal>
</simpara></simpara>

<simpara>Run-benchmark prints a short banner (including the identifying <emphasis>name</emphasis>)
to identify the benchmark, then runs <emphasis>thunk</emphasis> <emphasis>k</emphasis> times, and finally
tests the value returned from the last call to <emphasis>thunk</emphasis> by applying the
predicate <emphasis>ok?</emphasis> to it. If the predicate returns true, then
run-benchmark prints summary statistics, as with</simpara>

<literallayout class="monospaced">([display-memstats][5] ... 'minimal).</literallayout>
<simpara>If the predicate returns false, an error is signalled.</simpara>

</section>
<section>
<title>SRFI Support</title>
<simpara>The SRFIs (Scheme Requests For Implementations) is an Internet-based
collection of Scheme code designed and provided by Scheme
programmers. The SRFI effort is open to anyone, and is described at
<ulink url="http://srfi.schemers.org">http://srfi.schemers.org</ulink>.</simpara>

<simpara>The fundamental SRFI is SRFI-0, "Feature-based conditional expansion
construct", which allows a program to query the underlying
implementation about the available SRFIs (and potentially about other
implementation features) at macro expansion time. The design documents
for this and other SRFIs are available at the web site shown above.</simpara>

<simpara>Larceny currently supports many SRFIs, but not as many as it should.
Some SRFIs are built into Larceny, but most must be loaded dynamically
using Larceny's <literal>require</literal> procedure:</simpara>

<screen>    &gt; (require 'srfi-0)</screen>
<simpara>Larceny provides the following nonstandard SRFI keys for use in
SRFI 0:</simpara>

<screen>    larceny</screen>
</section>
<section>
<title>SLIB support</title>
<simpara><ulink url="http://www-swiss.ai.mit.edu/~jaffer/SLIB.html">SLIB</ulink>
is a large collection of useful libraries that have been
written or collected by Aubrey Jaffer.</simpara>

<simpara>Larceny supports SLIB via
<ulink url="http://srfi.schemers.org/srfi-96/">SRFI 96</ulink>,
but SLIB itself is not shipped with Larceny;
it must be downloaded separately and then installed.
For the most up-to-date information on installing and using
SLIB with Larceny, see <literal>doc/HOWTO-SLIB</literal>.</simpara>

</section>
<section>
<title>Foreign-Function Interface to C</title>
<simpara>Larceny provides a general foreign-function interface (FFI) substrate
on which other FFIs can be built; see
<ulink url="LarcenyNotes/note7-ffi.html">Larceny Note #7</ulink>.
The FFI described in this manual section is a simple example of
a derived FFI. It is not yet fully evolved, but it is useful.</simpara>

<warning>
<simpara>This section has undergone signficant revision, but
not all of the material has been properly vetted.
Some of the information in this section may be out of date.</simpara>

</warning>
<note>
<simpara>Some of the text below is adapted from the 2008 Scheme Workshop
paper, &#8220;The Layers of Larceny's Foreign Function Interface,&#8221;
by Felix S Klock II.  That paper may provide additional insight
for those searching for implementation details and motivations.</simpara>

</note>
<section>
<title>Introducing the FFI</title>
<simpara>There are a number of different potential ways to use the FFI.
One client may want to develop code in C and load it into Larceny.
Another client may want to load native libraries
provided by the host operating system, enabling invocation
of foreign code from Scheme expressions without developing
any C code or even running a C compiler.
Larceny's FFI can be used for both of these cases,
but many of its facilities target a third client
in between the two extremes: a client with a C compiler and
the header files and object code for the foreign libraries,
but who wishes to avoid writing glue code in C to interface
with the libraries.</simpara>

<simpara>There are four main steps to interacting with foreign code:</simpara>

<orderedlist>
<listitem>
<simpara>
identifying the space of values manipulated by the
   foreign code that will also be manipulated in Scheme,
</simpara>
</listitem>
<listitem>
<simpara>
describing how to marshal values between foreign and
   Scheme code,
</simpara>
</listitem>
<listitem>
<simpara>
loading library file(s) holding foreign object code, and
</simpara>
</listitem>
<listitem>
<simpara>
linking procedures from the loaded library.
</simpara>
</listitem>
</orderedlist>
<simpara>Step 1 is conceptual, while steps 2 through 4
yield artifacts in Scheme source code.</simpara>

</section>
<section>
<title>The space of foreign values</title>
<simpara>At the machine code level, foreign values are uninterpreted
sequences of bits.  Often foreign object code is oriented
around manipulating word-sized bit-sequences (<emphasis>words</emphasis>)
or arrays and tuples of words.</simpara>

<simpara>Many libraries are written with a particular
interpretation of such values.  In C code, explicit types are
often used hints to guide such interpretation; for example,
a <literal>0</literal> of type <literal>bool</literal> is usually interpreted as <emphasis>false</emphasis>,
while a <literal>1</literal> (or other non-zero value) of type <literal>bool</literal> is
usually interpreted as <emphasis>true</emphasis>.
Another example are C enumerations (or <emphasis>enums</emphasis>).
An enum declaration defines a set of named
integral constants.  After the C declaration:</simpara>

<screen>enum months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };</screen>
<simpara>a <literal>JAN</literal> in C code now denotes <literal>1</literal>, <literal>FEB</literal> is <literal>2</literal>, and so on.
Furthermore, tools like debuggers may render a variable <literal>x</literal>
dynamically assigned the value <literal>2</literal> (and of static type <literal>enum months</literal>)
as <literal>FEB</literal>.  Thus the enum declaration
intoduces a new interpretation for a finite set of integers.</simpara>

<simpara>This leads to questions for a client of an FFI;
we explore some below.</simpara>

<itemizedlist>
<listitem>
<simpara>
Should foreign words be passed over to
the Scheme world as uninterpreted numbers (and thus
be converted into Scheme integers, usually fixnums),
or should they be marshaled into interpreted values, such as
<literal>#f</literal> and <literal>#t</literal> for the <literal>bool</literal> type, or the Scheme symbols
{<literal>JAN</literal>, <literal>FEB</literal>, <literal>MAR</literal>, <literal>APR</literal>, <literal>MAY</literal>, <literal>JUN</literal>,
 <literal>JUL</literal>, <literal>AUG</literal>, <literal>SEP</literal>, <literal>OCT</literal>, <literal>NOV</literal>, <literal>DEC</literal>}
for the <literal>enum months</literal> type?
</simpara>
</listitem>
<listitem>
<simpara>
Similarly, how should Scheme values be marshaled into
foreign words?
</simpara>
</listitem>
<listitem>
<simpara>
A foreign library might leave the mapping
of names like <literal>FEB</literal> to words like <literal>2</literal> <emphasis>unspecified</emphasis>
in the library interface.
That is, while the C compiler will know <literal>FEB</literal> maps to <literal>2</literal>
according to a particular version of the library's header file,
the library designer may intend to change this mapping
in the future, and clients writing C code should <emphasis>only</emphasis> use
the names to refer to a <literal>enum months</literal> value, and <emphasis>not</emphasis> integer
expressions.
</simpara>
<itemizedlist>
<listitem>
<simpara>
How should this constraint be handled in the FFI; should
 the library client revise their code in reaction to
 such changes to the mapping?
</simpara>
</listitem>
<listitem>
<simpara>
Or should the system derive
 the mapping from the header files, in the same manner that
 the C compiler does?
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Foreign libraries often manipulate
mutable entities, like arrays of words where
modifications can be observed (often by design).
</simpara>
<itemizedlist>
<listitem>
<simpara>
How should such values be marshaled?
</simpara>
</listitem>
<listitem>
<simpara>
Is it sound to copy such values to the Scheme heap?
  If so, is a shallow copy sufficient?
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Will the foreign code hold references to heap-allocated
objects?  Heap-allocated objects that <emphasis>leak</emphasis> out to
foreign memory must be treated with care;
garbage collection presents two main problems.
</simpara>
<itemizedlist>
<listitem>
<simpara>
First, such objects must not move during a garbage collection;
Larceny supports this via special-purpose allocation routines:
 <literal>cons-nonrelocatable</literal>, <literal>make-nonrelocatable-bytevector</literal>,
 and <literal>make-nonrelocatable-vector</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Second, the garbage collector must know to hold on to
(i.e. trace)
such values as long as they are needed by foreign code;
otherwise the objects or their referents may be
collected without the knowledge of the foreign code.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Answering these questions may require deep knowledge
of the intended usage of the foreign library.</simpara>

<simpara>The Larceny FFI attempts to ease interfacing with
foreign code in the presence of the above concerns,
but the nature of the header files included with
most foreign libraries means that the FFI cannot infer
the answers unassisted.</simpara>

<note>
<simpara>Foreign C code developed to work in concert with Larceny
could hypothetically be written to cope with holding
handles for objects managed by the the garbage collector,
but there is currently no significant support
for this use-case.</simpara>

</note>
<note>
<simpara>One class of foreign values is not addressed
by the Larceny FFI: structures passed by value (as
opposed to by reference, ie pointers to structures).
There is no way to describe the interface to a
foreign procedure that accepts or produces a
C <literal>struct</literal> (at least not properly nor portably).</simpara>

<simpara>This tends to not matter for many foreign libraries
(since many C programmers eschew passing structures
by value), but it can arise.</simpara>

<simpara>If the foreign library of interest has procedures that
accept or produce a C <literal>struct</literal>, we currently recommend
either avoiding such procedures, or writing
adapter code in C that marshals between values handled
by the FFI and the C <literal>struct</literal>.</simpara>

</note>
<simpara>The conclusion is: when designing an interface to a foreign
library, you should analyze the values manipulated on the
foreign side and identify their relationship with values
on the Scheme side.
After you have identified the domains of interest,
you then describe how the values will be marshaled
back and forth between the two domains.</simpara>

</section>
<section>
<title>Marshalling via ffi-attributes</title>
<simpara>This section describes the marshalling protocol defined in
<literal>lib/Base/std-ffi.sch</literal>.</simpara>

<simpara>Foreign functions automatically marshal their inputs and outputs
according to type-descriptors attached to each foreign
function.</simpara>

<simpara>Type-descriptors are S-expressons formed according to the following
grammar:</simpara>

<literallayout class="monospaced">TypeDesc ::= CoreAttr | ArrowT | MaybeT | OneOfT

CoreAttr ::= PrimAttr | VoidStar | ---

PrimAttr ::= CurrentPrimAttr | DeprecatedPrimAttr

CurrentPrimAttr
         ::= int | uint | byte | short | ushort | char | uchar
          |  long | ulong | longlong | ulonglong
          |  size_t | float | double |  bool | string | void

DeprecatedPrimAttr
         ::= unsigned | boxed

VoidStar ::= void* | ---

ArrowT   ::= (-&gt; (TypeDesc ...) TypeDesc)

MaybeT   ::= (maybe TypeDesc)

OneOfT   ::= (oneof (Any Fixnum) ... TypeDesc)</literallayout>
<simpara>where <literal>---</literal> represents a user-extensible part of the grammar
(see below),
<literal>Any</literal> represents any Scheme value, and <literal>Fixnum</literal> represents
any word-sized integer.</simpara>

<simpara>A central registry maps <literal>CoreAttr</literal>'s to a foreign
representation and two conversion routines:
one to convert a Scheme value to a foreign argument, and
another to convert a foreign result back back to a Scheme value.
The denoted components are collectively referred to as a <emphasis>type</emphasis>
within the FFI documentation.
The registry is extensible; the <literal>ffi-add-attribute-core-entry!</literal>
procedure adds new <literal>CoreAttr's</literal> to the registry, and
one can alternatively add short-hands for
type-descriptors via the <literal>ffi-add-alias-of-attribute-entry!</literal>
procedure.
Finally, one can add new <literal>VoidStar</literal> productions
(subtypes of the <literal>void*</literal> type-descriptor)
via the <literal>ffi-install-void*-subtype</literal> procedure
(defined in the <literal>lib/Standard/foreign-stdlib.sch</literal> library).</simpara>

<section>
<title>Primitive Attribute Types</title>
<simpara>The following is a list of the accepted types and their conversions
at the boundary between Scheme and foreign code:</simpara>

<variablelist>
<varlistentry>
<term>
<literal>int</literal>
</term>
<listitem>
<simpara>
  Exact integer values in the range [-2<superscript>31</superscript>,2<superscript>31</superscript>-1].
  Scheme integers in that range are converted to and from C "<literal>int</literal>".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>uint</literal>
</term>
<listitem>
<simpara>
  Exact integer values in the range [0,2<superscript>32</superscript>-1].
  Scheme integers in that ranges are converted to and from C "<literal>unsigned int</literal>".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>byte</literal>
</term>
<listitem>
<simpara>
  Synonymous with <literal>int</literal> in the current implementation.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>short</literal>
</term>
<listitem>
<simpara>
  Synonymous with <literal>int</literal> in the current implementation.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>ushort</literal>
</term>
<listitem>
<simpara>
  Synonymous with <literal>unsigned</literal> in the current implementation.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>char</literal>
</term>
<listitem>
<simpara>
  Scheme ASCII characters are converted to and from C "<literal>char</literal>".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>uchar</literal>
</term>
<listitem>
<simpara>
  Scheme ASCII characters are converted to and from C "<literal>unsigned char</literal>".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>long</literal>
</term>
<listitem>
<simpara>
  Synonymous with <literal>int</literal> in the current implementation.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>ulong</literal>
</term>
<listitem>
<simpara>
  Synonymous with <literal>unsigned</literal> in the current implementation.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>longlong</literal>
</term>
<listitem>
<simpara>
  Exact integer values in the range [-2<superscript>63</superscript>,2<superscript>63</superscript>-1].
  Scheme integers in that range are converted
  to and from C "<literal>long long</literal>".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>ulonglong</literal>
</term>
<listitem>
<simpara>
  Exact integer values in the range [0,2<superscript>64</superscript>-1].
  Scheme integers in that range are converted
  to and from C "<literal>unsigned long long</literal>".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>size_t</literal>
</term>
<listitem>
<simpara>
  Synonymous with <literal>uint</literal> in the current implementation.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>float</literal>
</term>
<listitem>
<simpara>
  Scheme flonums are converted to and from C "<literal>float</literal>".
  The conversion to <literal>float</literal> is performed via
  a C <literal>(float)</literal> cast from a C <literal>double</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>double</literal>
</term>
<listitem>
<simpara>
  Scheme flonums are converted to and from C "double".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>bool</literal>
</term>
<listitem>
<simpara>
  Scheme objects are converted to C "<literal>int</literal>";
  <literal>#f</literal> is converted to 0, and all other objects to 1.
  In the reverse direction, 0 is converted to <literal>#f</literal> and
  all other integers to <literal>#t</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>string</literal>
</term>
<listitem>
<simpara>
  A Scheme string holding ASCII characters
  is <emphasis>copied</emphasis> into a NUL-terminated bytevector,
  passing a pointer to its first byte to the foreign procedure;
  <literal>#f</literal> is converted to a C "<literal>(char*)0</literal>" value.
  In the reverse direction, a pointer to a NUL-terminated sequence
  of bytes interpreted as ASCII characters is
  copied into a freshly allocated Scheme string; a NULL pointer is
  converted to <literal>#f</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>void</literal>
</term>
<listitem>
<simpara>
  No return value.
  (Only used in return position for foreign functions;
  all Scheme procedures passed to the FFI are invoked in a context
  expecting one value.)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>unsigned</literal>
</term>
<listitem>
<simpara>
  Synonymous with <literal>uint</literal>; deprecated.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>boxed</literal>
</term>
<listitem>
<simpara>
  Any heap-allocated data structure (pair,
  bytevector-like, vector-like, procedure) is converted to
  a C "<literal>void*</literal>" to the first element of the structure. The
  value <literal>#f</literal> is also acceptable. It is converted to a C "<literal>(void*)0</literal>"
  value.
  (Only used in argument position for foreign functions; foreign
   functions are not expected to return direct references
   to heap-allocated values.)
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section>
<title>Extending the Core Attribute Registry</title>
<simpara>The public interface to many foreign libraries is written
in terms of types defined within that foreign library.
One can introduce new types to the Larceny FFI
by extending the core attribute entry table.</simpara>

<simpara><anchor id="ffi-add-attribute-core-entry!" xreflabel="ffi-add-attribute-core-entry!"></anchor>
<emphasis> Procedure ffi-add-attribute-core-entry!</emphasis>
<simpara>
<indexterm><primary><code>ffi-add-attribute-core-entry!</code></primary></indexterm>
<literal>(ffi-add-attribute-core-entry! <emphasis>entry-name rep-sym marshal unmarshal</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara><xref linkend="ffi-add-attribute-core-entry!"/> extends the
internal registry with the new entry specified by its arguments.</simpara>

<itemizedlist>
<listitem>
<simpara>
<emphasis>entry-name</emphasis> is a symbol (the symbolic type name being
introduced to the ffi).
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>rep-name</emphasis> is a low-level type descriptor symbol, one of
<literal>signed32</literal>, <literal>unsigned32</literal>, <literal>signed64</literal>, <literal>unsigned64</literal>
(representing varieties of fixed width integers),
<literal>ieee32</literal> (representing &#8220;floats&#8221;),
<literal>ieee64</literal> (representing &#8220;doubles&#8221;), or
<literal>pointer</literal> (representing &#8220;<literal>(void*)</literal>&#8221; in C).
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>marshal</emphasis> is a marshaling function that accepts a Scheme object and a symbol
(the name of the invoking procedure); it is responsible for checking
the Scheme object's validity and then producing a corresponding
instance of the low-level representation.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>unmarshal</emphasis> is either <literal>#f</literal> or an unmarshalling function that
accepts an instance of the low-level representation
and produces a corresponding Scheme object.
</simpara>
</listitem>
</itemizedlist>
</section>
<section>
<title>Attribute Type Constructors</title>
<simpara>Core attributes suffice for linking to simple
functions.
Constructured FFI attributes express more complex
marshaling protocols</simpara>

<formalpara><title>Arrow Type Constructors</title><para>A structured FFI attribute
of the form <literal>(-&gt; (<emphasis>s_1</emphasis> &#8230; <emphasis>s_n</emphasis>) <emphasis>s_r</emphasis>)</literal>
(called an <emphasis>arrow type</emphasis>)
allows passing functions from Scheme to C
and back again.  Each of the <emphasis>s_1</emphasis>, &#8230;, <emphasis>s_n</emphasis>, <emphasis>s_r</emphasis>
is an FFI attribute.
When an arrow type describes an input to a foreign
function, it marshals a Scheme procedure to a
C function pointer by generating glue code to hook the two together
and marshal values as described by the FFI attributes
within the arrow type.
Likewise, when an arrow type describes an output from a
foreign function, it marshals a C function pointer
to a Scheme procedure, again by generating glue code.
These two mappings naturally generalize to arbitrary nesting
of arrow types, so one can create callbacks that consume
callouts, return callouts that consume callbacks, and so on.</para></formalpara>

<warning>
<simpara>The current implementation of arrow types introduces an
unnecessary space leak, because none of Larceny's current
garbage collectors attempt to reclaim some of the structure
allocated (in particular, the so-called trampolines)
when functions are marshaled via arrow types.</simpara>

<simpara>The FFI could be revised to reduce the leak
(e.g. it could keep a cache of generated trampolines and
reuse them, but currently do not do so).</simpara>

<simpara>Many foreign libraries have a structure where one only
sets up a fixed set of callbacks, and then all further
computation does not require arrow type marshaling.
This is one reason why fixing this problem
has been a low priority item for the Larceny development
team.</simpara>

</warning>
<formalpara><title>Maybe Type Constructor</title><para><literal>(maybe <emphasis>t</emphasis>)</literal> captures the
pattern of passing <literal>NULL</literal> in C and <literal>#f</literal> in Scheme
to represent the absence of information.
The FFI attribute <emphasis>t</emphasis> within the maybe type
describes the typical information passed;
the constructed maybe type
marshals <literal>#f</literal> to the foreign null pointer or <literal>0</literal> (as appropriate),
and otherwise applies the marshaling of <emphasis>t</emphasis>.
Likewise, it unmarshals the foreign
null pointer and <literal>0</literal> to <literal>#f</literal>, and otherwise applies the
unmarshaling of <emphasis>t</emphasis>.</para></formalpara>

<simpara>(There are a few other built-in type constructors, such as
 the <literal>oneof</literal> type constructor, but they
 are not as fully-developed as the two above, and are intended
 for use only for internal development for now.)</simpara>

</section>
<section>
<title>void* Type Hierarchies</title>
<simpara>Using the <literal>void*</literal> attribute
wraps foreign addresses up in a Larceny record,
so that standard numeric
operations cannot be directly applied by accident.
The FFI uses two features of Larceny's record system:
the record type descriptor is a first class
value with an inspectable name, and
record types are extensible via single-inheritance.</simpara>

<formalpara><title>Basic Operations on <literal>void*</literal></title><para>The FFI provides <literal>void*-rt</literal>, a record type
descriptor with a single field (a wrapped address).
There is also a family of functions for dereferencing the
pointer within a <literal>void*-rt</literal> and manipulating the
state it references.</para></formalpara>

<simpara><anchor id="void*-&gt;address" xreflabel="void*-&gt;address"></anchor>
<emphasis> Procedure void*-&gt;address</emphasis>
<simpara>
<indexterm><primary><code>void*-&gt;address</code></primary></indexterm>
<literal>(void*-&gt;address <emphasis>x</emphasis>)  =&gt; <emphasis>number</emphasis></literal>
</simpara>
Extracts the underlying address held in a <literal>void*</literal>.</simpara>

<simpara><anchor id="void*?" xreflabel="void*?"></anchor>
<emphasis> Procedure void*?</emphasis>
<simpara>
<indexterm><primary><code>void*?</code></primary></indexterm>
<literal>(void*? <emphasis>x</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara>
Distinquishes <literal>void*</literal>'s from other Scheme values.</simpara>

<simpara><anchor id="void*-byte-ref" xreflabel="void*-byte-ref"></anchor>
<emphasis> Procedure void*-byte-ref</emphasis>
<simpara>
<indexterm><primary><code>void*-byte-ref</code></primary></indexterm>
<literal>(void*-byte-ref <emphasis>x idx</emphasis>)  =&gt; <emphasis>number</emphasis></literal>
</simpara>
Extracts byte at offset from address within <emphasis>x</emphasis>.</simpara>

<simpara><anchor id="void*-byte-set!" xreflabel="void*-byte-set!"></anchor>
<emphasis> Procedure void*-byte-set!</emphasis>
<simpara>
<indexterm><primary><code>void*-byte-set!</code></primary></indexterm>
<literal>(void*-byte-set! <emphasis>x idx val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara>
Modifies byte at offset from address within <emphasis>x</emphasis>.</simpara>

<simpara><anchor id="void*-word-ref" xreflabel="void*-word-ref"></anchor>
<emphasis> Procedure void*-word-ref</emphasis>
<simpara>
<indexterm><primary><code>void*-word-ref</code></primary></indexterm>
<literal>(void*-word-ref <emphasis>x idx</emphasis>)  =&gt; <emphasis>number</emphasis></literal>
</simpara>
Extracts word-sized integer at offset from address within <emphasis>x</emphasis>.</simpara>

<simpara><anchor id="void*-word-set!" xreflabel="void*-word-set!"></anchor>
<emphasis> Procedure void*-word-set!</emphasis>
<simpara>
<indexterm><primary><code>void*-word-set!</code></primary></indexterm>
<literal>(void*-word-set! <emphasis>x idx val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara>
Modifies word-sized integer at offset from address within <emphasis>x</emphasis>.</simpara>

<simpara><anchor id="void*-void*-ref" xreflabel="void*-void*-ref"></anchor>
<emphasis> Procedure void*-void*-ref</emphasis>
<simpara>
<indexterm><primary><code>void*-void*-ref</code></primary></indexterm>
<literal>(void*-void*-ref <emphasis>x idx</emphasis>)  =&gt; <emphasis>void*</emphasis></literal>
</simpara>
Extracts address (and wraps it in a <literal>void*</literal>) at offset from address within <emphasis>x</emphasis>.</simpara>

<simpara><anchor id="void*-void*-set!" xreflabel="void*-void*-set!"></anchor>
<emphasis> Procedure void*-void*-set!</emphasis>
<simpara>
<indexterm><primary><code>void*-void*-set!</code></primary></indexterm>
<literal>(void*-void*-set! <emphasis>x idx val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara>
Modifies address at offset from address within <emphasis>x</emphasis>.</simpara>

<simpara><anchor id="void*-double-ref" xreflabel="void*-double-ref"></anchor>
<emphasis> Procedure void*-double-ref</emphasis>
<simpara>
<indexterm><primary><code>void*-double-ref</code></primary></indexterm>
<literal>(void*-double-ref <emphasis>x idx</emphasis>)  =&gt; <emphasis>number</emphasis></literal>
</simpara>
Extracts 64-bit flonum at offset from address within <emphasis>x</emphasis>.</simpara>

<simpara><anchor id="void*-double-set!" xreflabel="void*-double-set!"></anchor>
<emphasis> Procedure void*-double-set!</emphasis>
<simpara>
<indexterm><primary><code>void*-double-set!</code></primary></indexterm>
<literal>(void*-double-set! <emphasis>x idx val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara>
Modifies 64-bit flonum at offset from address within <emphasis>x</emphasis>.</simpara>

<formalpara><title>Type Hierarchies</title><para>Procedures for establishing type hierarchies are provided by the
<literal>lib/Standard/foreign-stdlib.sch</literal> library; see
<xref linkend="ffi-install-void*-subtype"/> and <xref linkend="establish-void*-subhierarchy!"/>.</para></formalpara>

</section>
</section>
<section>
<title>Creating loadable modules</title>
<simpara>You must first compile your C code and create one or more loadable object modules. These object modules may then be loaded into Larceny, and Scheme foreign functions may link to specific functions in the loaded module. Defining foreign functions in Scheme is covered in a later section.</simpara>

<simpara>The method for creating a loadable object module varies from platform to platform. In the following, assume you have to C source files file1.c and file2.c that define functions that you want to make available as foreign functions in Larceny.</simpara>

<section>
<title>SunOS 4</title>
<simpara>Compile your source files and create a shared library. Using GCC, the command line might look like this:</simpara>

<literallayout class="monospaced">gcc -fPIC -shared file1.c file2.c -o my-library.so</literallayout>
<simpara>The command creates my-library.so in the current directory. This library can now be loaded into Larceny using <xref linkend="foreign-file"/>. Any other shared libraries used by your library files should also be loaded into Larceny using <xref linkend="foreign-file"/> before any procedures are linked using <xref linkend="foreign-procedure"/>.</simpara>

<simpara>By default, /lib/libc.so is made available to the dynamic linker and to the foreign function interface, so there is no need for you to load that library explicitly.</simpara>

</section>
<section>
<title>SunOS 5</title>
<simpara>Compile your source files and create a shared library, linking with all the necessary libraries. Using GCC, the command line might look like this:</simpara>

<literallayout class="monospaced">gcc -fPIC -shared file1.c file2.c -lc -lm -lsocket -o my-library.so</literallayout>
<simpara>Now you can use foreign-file to load my-library.so into Larceny.</simpara>

<simpara>By default, /lib/libc.so is made available to the foreign function interface, so there is no need for you to load that library explicitly.</simpara>

</section>
</section>
<section>
<title>The Interface</title>
<section>
<title>Procedures</title>
<simpara><anchor id="foreign-file" xreflabel="foreign-file"></anchor>
<emphasis> Procedure foreign-file</emphasis>
<simpara>
<indexterm><primary><code>foreign-file</code></primary></indexterm>
<literal>(foreign-file <emphasis>filename</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara><xref linkend="foreign-file"/> loads the named object file into Larceny and makes it available for dynamic linking.</simpara>

<simpara>Larceny uses the operating system provided dynamic linker to do dynamic linking. The operation of the dynamic linker varies from platform to platform:</simpara>

<itemizedlist>
<listitem>
<simpara>
On some versions of SunOS 4, if the linker is given a file that does not exist, it will terminate the process. (Most likely this is a bug.) This means you should never call foreign-file with the name of a file that does not exist.
</simpara>
</listitem>
<listitem>
<simpara>
On SunOS 5, if a foreign file is given to foreign-file without a directory specification, then the dynamic linker will search its load path (the <literal>LD_LIBRARY_PATH</literal> environment variable) for the file. Hence, a foreign file in the current directory should be "./file.so", not "file.so".
</simpara>
</listitem>
</itemizedlist>
<simpara><anchor id="foreign-procedure" xreflabel="foreign-procedure"></anchor>
<emphasis> Procedure foreign-procedure</emphasis>
<simpara>
<indexterm><primary><code>foreign-procedure</code></primary></indexterm>
<literal>(foreign-procedure <emphasis>name (arg-type &#8230;) return-type</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara>FIXME: The interface to this function has been extended to support
hooking into Windows procedures that use the Pascal calling convention
instead of the C one.  The way to select which convention to use
should be documented.</simpara>

<simpara>Returns a Scheme procedure <emphasis>p</emphasis> that calls the foreign procedure whose
name is <emphasis>name</emphasis>. When <emphasis>p</emphasis> is called, it will convert its parameters to
representations indicated by the <emphasis>arg-type</emphasis>s and invoke the foreign
procedure, passing the converted values as parameters. When the
foreign procedure returns, its return value is converted to a Scheme
value according to <emphasis>return-type</emphasis>.</simpara>

<simpara>Types are described below.</simpara>

<simpara>The address of the foreign procedure is obtained by searching for <emphasis>name</emphasis> in the symbol tables of the foreign files that have been loaded with <emphasis>foreign-file</emphasis>.</simpara>

<simpara><anchor id="foreign-null-pointer" xreflabel="foreign-null-pointer"></anchor>
<emphasis> Procedure foreign-null-pointer</emphasis>
<simpara>
<indexterm><primary><code>foreign-null-pointer</code></primary></indexterm>
<literal>(foreign-null-pointer <emphasis></emphasis>)  =&gt; <emphasis>integer</emphasis></literal>
</simpara></simpara>

<simpara>Returns a foreign null pointer.</simpara>

<simpara><anchor id="foreign-null-pointer?" xreflabel="foreign-null-pointer?"></anchor>
<emphasis> Procedure foreign-null-pointer?</emphasis>
<simpara>
<indexterm><primary><code>foreign-null-pointer?</code></primary></indexterm>
<literal>(foreign-null-pointer? <emphasis>integer</emphasis>)  =&gt; <emphasis>boolean</emphasis></literal>
</simpara></simpara>

<simpara>Tests whether its argument is a foreign null pointer.</simpara>

</section>
</section>
<section>
<title>Foreign Data Access</title>
<section>
<title>Raw memory access</title>
<simpara>The two primitives <emphasis>peek-bytes</emphasis> and <emphasis>poke-bytes</emphasis> are provided for reading and writing memory at specific addresses. These procedures are typically used for copying data from foreign data structures into Scheme bytevectors for subsequent decoding.</simpara>

<simpara>(The use of <emphasis>peek-bytes</emphasis> and <emphasis>poke-bytes</emphasis> can often be avoided by keeping foreign data in a Scheme bytevector and passing the bytevector to a call-out using the <emphasis role="strong">boxed</emphasis> parameter type. However, this technique is inappropriate if the foreign code retains a pointer to the Scheme datum, which may be moved by the garbage collector.)</simpara>

<simpara><anchor id="peek-bytes" xreflabel="peek-bytes"></anchor>
<emphasis> Procedure peek-bytes</emphasis>
<simpara>
<indexterm><primary><code>peek-bytes</code></primary></indexterm>
<literal>(peek-bytes <emphasis>addr bytevector count</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara><emphasis>Addr</emphasis> must be an exact nonnegative integer. <emphasis>Count</emphasis> must be a fixnum. The bytes in the range from <emphasis>addr</emphasis> through <emphasis>addr+count-1</emphasis> are copied into <emphasis>bytevector</emphasis>, which must be long enough to hold that many bytes.</simpara>

<simpara>If any address in the range is not an address accessible to the process, unpredictable things may happen. Typically, you'll get a segmentation fault. Larceny does not yet catch segmentation faults.</simpara>

<simpara><anchor id="poke-bytes" xreflabel="poke-bytes"></anchor>
<emphasis> Procedure poke-bytes</emphasis>
<simpara>
<indexterm><primary><code>poke-bytes</code></primary></indexterm>
<literal>(poke-bytes <emphasis>addr bytevector count</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara><emphasis>Addr</emphasis> must be an exact nonnegative integer. <emphasis>Count</emphasis> must be a fixnum. The <emphasis>count</emphasis> first bytes from <emphasis>bytevector</emphasis> are copied into memory in the range from <emphasis>addr</emphasis> through <emphasis>addr+count-1</emphasis>.</simpara>

<simpara>If any address in the range is not an address accessible to the process, unpredictable things may happen. Typically, you'll get a segmentation fault. Larceny does not yet catch segmentation faults.</simpara>

<simpara>Also, it's possible to corrupt memory with <emphasis>poke-bytes</emphasis>. Don't do that.</simpara>

</section>
<section>
<title>Foreign data sizes</title>
<simpara>The following variables constants define the sizes of basic C data types:</simpara>

<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong">sizeof:short</emphasis> The size of a "short int".
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">sizeof:int</emphasis> The size of an "int".
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">sizeof:long</emphasis> The size of a "long int".
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">sizeof:pointer</emphasis> The size of any pointer type.
</simpara>
</listitem>
</itemizedlist>
</section>
<section>
<title>Decoding foreign data</title>
<simpara>Foreign data is visible to a Scheme program either as an object pointed to by a memory address (which is itself represented as an integer), or as a bytevector that contains the bytes of the foreign datum.</simpara>

<simpara>A number of utility procedures that make reading and writing data of common C primitive types have been written for both these kinds of foreign objects.</simpara>

<simpara><emphasis>Bytevector accessor procedures</emphasis></simpara>

<simpara><simpara><literal>(%get16 <emphasis>bv i</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%get16u <emphasis>bv i</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%get32 <emphasis>bv i</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%get32u <emphasis>bv i</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%get-int <emphasis>bv i</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%get-unsigned <emphasis>bv i</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%get-short <emphasis>bv i</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%get-ushort <emphasis>bv i</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%get-long <emphasis>bv i</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%get-ulong <emphasis>bv i</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%get-pointer <emphasis>bv i</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara></simpara>

<simpara>These procedures decode bytevectors that contain the bytes of foreign objects. In each case, <emphasis>bv</emphasis> is a bytevector and <emphasis>i</emphasis> is the offset of the first byte of a field in that bytevector. The field is fetched and returned as an integer (signed or unsigned as appropriate).</simpara>

<simpara><emphasis>Bytevector updater procedures</emphasis></simpara>

<simpara><simpara><literal>(%set16 <emphasis>bv i val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%set16u <emphasis>bv i val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%set32 <emphasis>bv i val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%set32u <emphasis>bv i val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%set-int <emphasis>bv i val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%set-unsigned <emphasis>bv i val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%set-short <emphasis>bv i val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%set-ushort <emphasis>bv i val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%set-long <emphasis>bv i val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%set-ulong <emphasis>bv i val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%set-pointer <emphasis>bv i val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara>These procedures update bytevectors that contain the bytes of foreign objects. In each case, <emphasis>bv</emphasis> is a bytevector, <emphasis>i</emphasis> is an offset of the first byte of a field in that bytevector, and <emphasis>val</emphasis> is a value to be stored in that field. The values must be exact integers in a range implied by the data type.</simpara>

<simpara><emphasis>Foreign-pointer accessor procedures</emphasis></simpara>

<simpara><simpara><literal>(%peek8 <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek8u <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek16 <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek16u <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek32 <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek32u <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(%peek-int <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek-long <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek-unsigned <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek-ulong <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek-short <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek-ushort <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek-pointer <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara>
<simpara><literal>(%peek-string <emphasis>addr</emphasis>)  =&gt; <emphasis>integer</emphasis></literal></simpara></simpara>

<simpara>These procedures read raw memory. In each case, <emphasis>addr</emphasis> is an address, and the value stored at that address (the size of which is indicated by the name of the procedure) is fetched and returned as an integer.</simpara>

<simpara><emphasis>%Peek-string</emphasis> expects to find a NUL-terminated string of 8-bit bytes at the given address. It is returned as a Scheme string.</simpara>

<simpara><emphasis>Foreign-pointer updater procedures</emphasis></simpara>

<simpara><simpara><literal>(%poke8 <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%poke8u <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%poke16 <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%poke16u <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%poke32 <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%poke32u <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara><simpara><literal>(%poke-int <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%poke-long <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%poke-unsigned <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%poke-ulong <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%poke-short <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%poke-ushort <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara>
<simpara><literal>(%poke-pointer <emphasis>addr val</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal></simpara></simpara>

<simpara>These procedures update raw memory. In each case, <emphasis>addr</emphasis> is an address, and <emphasis>val</emphasis> is a value to be stored at that address.</simpara>

</section>
</section>
<section>
<title>Heap dumping and the FFI</title>
<simpara>If foreign functions are linked into Larceny using the FFI, and a
Larceny heap image is subsequently dumped (with
<xref linkend="dump-interactive-heap"/> or
<xref linkend="dump-heap"/>), then the foreign functions are not saved as
part of the heap image. When the heap image is subsequently loaded
into Larceny at startup, the FFI will attempt to re-link all the
foreign functions in the heap image.</simpara>

<simpara>During the relinking phase, foreign files will again be loaded into Larceny, and Larceny's FFI will use the file names <emphasis>as they were originally given to the FFI</emphasis> when it tries to load the files. In particular, if relative pathnames were used, Larceny will not have converted them to absolute pathnames.</simpara>

<simpara>An error during relinking will result in Larceny aborting with an error message and returning to the operating system. This is considered a feature.</simpara>

</section>
<section>
<title>Examples</title>
<section>
<title>Change directory</title>
<simpara>This procedure uses the chdir() system call to set the process's current working directory. The string parameter type is used to pass a Scheme string to the C procedure.</simpara>

<literallayout class="monospaced">(define cd
  (let ((chdir (foreign-procedure "chdir" '(string) 'int)))
    (lambda (newdir)
      (if (not (zero? (chdir newdir)))
      (error "cd: " newdir " is not a valid directory name."))
      (unspecified))))</literallayout>
</section>
<section>
<title>Print Working Directory</title>
<simpara>This procedure uses the getcwd() (get current working directory) system call to retrieve the name of the process's current working directory. A bytevector is created and passed in as a buffer in which to store the return value &#8212; a 0-terminated ASCII string. Then the FFI utility function ffi/asciiz-&gt;string is called to convert the bytevector to a string.</simpara>

<literallayout class="monospaced">(define pwd
  (let ((getcwd (foreign-procedure "getcwd" '(boxed int) 'int)))
    (lambda ()
      (let ((s (make-bytevector 1024)))
    (getcwd s 1024)
    (ffi/asciiz-&gt;string s)))))</literallayout>
</section>
<section>
<title>Quicksort</title>
<warning><simpara>this example is bogus.  It is not safe to pass a collectable
object into a C procedure when the callback invocation might cause a
garbage collection, thus moving the object and invalidating the
address stored in the C machine context.</simpara></warning>
<simpara>This demonstrates how to use a callback such as the comparator argument to qsort.
It is specified in the type signature using -&gt; as a type constructor.
(Note that one should probably use the built-in sort routines rather than call out
 like this; this example is for demonstrating callbacks, not how to sort.)</simpara>

<literallayout class="monospaced">(define qsort!
  (foreign-procedure "qsort" '(boxed ushort ushort (-&gt; (void* void*) int)) 'void))</literallayout>
<literallayout class="monospaced">(let ((bv (list-&gt;vector '(40 10 30 20 1 2 3 4))))
  (qsort! bv 8 4
          (lambda (x y)
            (let ((x (/ (void*-word-ref x 0) 4))
                  (y (/ (void*-word-ref y 0) 4)))
              (- x y))))
  bv)</literallayout>
<literallayout class="monospaced">(let ((bv (list-&gt;bytevector '(40 10 30 20 1 2 3 4))))
  (qsort! bv 8 1
          (lambda (x y)
            (let ((x (void*-byte-ref x 0))
                  (y (void*-byte-ref y 0)))
              (- x y))))
  bv)</literallayout>
</section>
<section>
<title>Other examples</title>
<simpara>The Experimental directory contains several examples of use of the FFI. See in particular the files unix.sch (Unix system calls) and socket.sch (procedures for communicating over sockets).</simpara>

</section>
</section>
<section>
<title>Higher level layers</title>
<simpara>The general foreign-function interface functionality described above
is powerful but awkward to use in practice.  A user might be tempted
to hard code values of offsets or constants that are compiler
dependent.  Also, the FFI will marshall some low-level values such
as strings or integers, but other values such as enumerations
which could be naturally mapped to sets of symbols are not marshalled
since the host environment does not provide the necessary type
information to the FFI.</simpara>

<simpara>This section documents a collection of libraries to mitigate these and
other problems.</simpara>

<section>
<title>foreign-ctools</title>
<simpara>Foreign data access is performed by peeking at manually calculated
addresses, but in practice one often needs to inspect fields of C
structures, whose offsets are dependant on the application binary
interface (ABI) of the host environment.  Similarly, C programs often
use refer to values via constant macro definitions; since the values
of such names are not provided by the object code and Scheme programs
do not have a C preprocessor run on them prior to execution, it is
difficult to refer to the same value without encoding "magic numbers"
into the Scheme source code.</simpara>

<simpara>The foreign-ctools library is meant to mitigate problems like the two
described above.  It provides special forms for introducing global
definitions of values typically available at compile-time for a C
program.  The library assumes the presence of a C compiler (such as
<emphasis>cc</emphasis> on Unix systems or <emphasis>cl.exe</emphasis> on Windows systems).  The special
forms work by dynamically generating, compiling, and running C code at
expansion time to determine the desired values of structure offsets or
macro constants.</simpara>

<simpara>Here is a grammar for the <literal>define-c-info</literal> form provided by
the <literal>foreign-ctools</literal> library.</simpara>

<literallayout class="monospaced">&lt;exp&gt;     ::= (define-c-info &lt;c-decl&gt; ... &lt;c-defn&gt; ...)

&lt;c-decl&gt;  ::= (compiler &lt;cc-spec&gt;)
           |  (path &lt;include-path&gt;)
           |  (include &lt;header&gt;)
           |  (include&lt;&gt; &lt;header&gt;)

&lt;cc-spec&gt; ::= cc | cl

&lt;c-defn&gt;  ::= (const &lt;id&gt; &lt;c-type&gt; &lt;c-expr&gt;)
           |  (sizeof &lt;id&gt; &lt;c-type-expr&gt;)
           |  (struct &lt;c-name&gt; &lt;field-clause&gt; ...)
           |  (fields &lt;c-name&gt; &lt;field-clause&gt; ...)
           |  (ifdefconst &lt;id&gt; &lt;c-type&gt; &lt;c-name&gt;)

&lt;c-type&gt;  ::= int | uint | long | ulong

&lt;include-path&gt;
          ::= &lt;string-literal&gt;

&lt;header&gt;  ::= &lt;string-literal&gt;

&lt;field-clause&gt;
          ::= (&lt;offset-id&gt; &lt;c-field&gt;)
           |  (&lt;offset-id&gt; &lt;c-field&gt; &lt;size-id&gt;)

&lt;c-expr&gt;  ::= &lt;string-literal&gt;

&lt;c-type-expr&gt;
          ::= &lt;string-literal&gt;

&lt;c-name&gt;  ::= &lt;string-literal&gt;

&lt;c-field&gt; ::= &lt;string-literal&gt;</literallayout>
<simpara><emphasis>Syntax define-c-info</emphasis></simpara>

<simpara><literal> (define-c-info &lt;c-decl&gt; &#8230; &lt;c-defn&gt; &#8230;)</literal></simpara>

<simpara>The <literal>&lt;c-decl&gt;</literal> clauses of <literal>define-c-info</literal>
control how header files are processed.
The <literal>compiler</literal> clause selects between <literal>cc</literal>
(the default UNIX system compiler) and <literal>cl</literal>
(the compiler included with Microsoft's Windows SDK).
The <literal>path</literal> clause adds a directory to search when
looking for header files.
The <literal>include</literal> and <literal>include&lt;&gt;</literal> clauses indicate
header files to include when executing the
<literal>&lt;c-defn&gt;</literal> clauses;
the two variants correspond to the quoted and bracketed
forms of the C preprocessor's <literal>#include</literal> directive.</simpara>

<simpara>The <literal>&lt;c-defn&gt;</literal> clauses bind identifiers.
A <literal>(const <emphasis>x</emphasis> <emphasis>t</emphasis> "<emphasis>ae</emphasis>")</literal> clause binds <emphasis>x</emphasis> to
the integer value of <emphasis>ae</emphasis> according to the C language;
<emphasis>ae</emphasis> can be any C arithmetic expression that evaluates
to a value of type <emphasis>t</emphasis>.
(The expected usage is for <emphasis>ae</emphasis> to be an
expression that the C preprocessor expands to an arithmetic expression.)</simpara>

<simpara>The remaining clauses provide similar functionality:</simpara>

<itemizedlist>
<listitem>
<simpara>
<literal>(sizeof <emphasis>x</emphasis> "<emphasis>te</emphasis>")</literal>
 binds <emphasis>x</emphasis> to the size occupied by values
 of type <emphasis>te</emphasis>, where <emphasis>te</emphasis> is any C type expression.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>(struct "<emphasis>cn</emphasis>" &#8230; (<emphasis>x</emphasis> "<emphasis>cf</emphasis>" <emphasis>y</emphasis>) &#8230;)</literal>
 binds <emphasis>x</emphasis> to the offset from the start of a
 structure of type <literal>struct <emphasis>cn</emphasis></literal> to its
 <emphasis>cf</emphasis> field, and binds <emphasis>y</emphasis>, if present, to the field's size.
 A <literal>fields</literal> clause is similar, but it applies
 to structures of type <literal><emphasis>cn</emphasis></literal> rather than <literal>struct <emphasis>cn</emphasis></literal>.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>(ifdefconst <emphasis>x</emphasis> <emphasis>t</emphasis> "<emphasis>cn</emphasis>")</literal>
 binds <emphasis>x</emphasis> to the value of <literal><emphasis>cn</emphasis></literal> if <literal><emphasis>cn</emphasis></literal> is defined;
 <emphasis>x</emphasis> is otherwise bound to Larceny's unspecified value.
</simpara>
</listitem>
</itemizedlist>
</section>
<section>
<title>foreign-sugar</title>
<simpara>The <xref linkend="foreign-procedure"/> function is sufficient to link in
dynamically loaded C procedures, but it can be annoying to
use when there are many procedures to define that all follow
a regular pattern where one could infer a mapping between
Scheme identifiers and C function names.</simpara>

<simpara>For example, some libraries follow a naming convention where a words
within a name are separated by underscores; such functions could be
immediately mapped to Scheme names where the underscores have been
replaced by dashes.</simpara>

<simpara>The foreign-sugar library provides a special form, <literal>define-foreign</literal>,
which gives the user a syntax for defining foreign functions using
a syntax where one provides only the Scheme name, the argument types,
and the return type.  The <literal>define-foreign</literal> form then attempts to
infer what C function the name was meant to refer to.</simpara>

<simpara><emphasis>Syntax define-foreign</emphasis></simpara>

<simpara><literal> (define-foreign (name arg-type &#8230;) result-type)</literal></simpara>

<note><simpara>There is other functionality provided allowing the user to
introduce new rules for inferring C function names, but they are
undocumented because they will probably have to change when we switch
to an R6RS macro expander.</simpara></note>
</section>
<section>
<title>foreign-stdlib</title>
<simpara><anchor id="stdlib/malloc" xreflabel="stdlib/malloc"></anchor>
<emphasis> Procedure stdlib/malloc</emphasis>
<simpara>
<indexterm><primary><code>stdlib/malloc</code></primary></indexterm>
<literal>(stdlib/malloc <emphasis>rtd</emphasis> <emphasis>[ctor]</emphasis>)  =&gt; <emphasis>procedure</emphasis></literal>
</simpara></simpara>

<simpara>Given a record extension of <emphasis>void*-rt</emphasis>, returns an allocator that uses
the C <literal>malloc</literal> procedure to allocate instances of such an object.
Note that the client is responsible for eventually freeing such
objects with <xref linkend="stdlib/free"/>.</simpara>

<simpara><anchor id="stdlib/free" xreflabel="stdlib/free"></anchor>
<emphasis> Procedure stdlib/free</emphasis>
<simpara>
<indexterm><primary><code>stdlib/free</code></primary></indexterm>
<literal>(stdlib/free <emphasis>void*-obj</emphasis>) </literal>
</simpara></simpara>

<simpara>Frees objects produced by allocators returned from <xref linkend="stdlib/malloc"/>.</simpara>

<simpara><anchor id="ffi-install-void*-subtype" xreflabel="ffi-install-void*-subtype"></anchor>
<emphasis> Procedure ffi-install-void*-subtype</emphasis>
<simpara>
<indexterm><primary><code>ffi-install-void*-subtype</code></primary></indexterm>
</simpara>
<simpara><literal>(ffi-install-void*-subtype <emphasis>rtd</emphasis>)  =&gt; <emphasis>rtd</emphasis></literal></simpara>
<simpara><literal>(ffi-install-void*-subtype <emphasis>string</emphasis> <emphasis>[parent-rtd]</emphasis>)  =&gt; <emphasis>rtd</emphasis></literal></simpara>
<simpara><literal>(ffi-install-void*-subtype <emphasis>symbol</emphasis> <emphasis>[parent-rtd]</emphasis>)  =&gt; <emphasis>rtd</emphasis></literal></simpara></simpara>

<simpara><xref linkend="ffi-install-void*-subtype"/>
extends the core attribute registry with a new primitive
entry for <emphasis>subtype</emphasis>.
The <emphasis>parent-rtd</emphasis> argument should be a subtype of <literal>void*-rt</literal>
and defaults to <literal>void*-rt</literal>.
In the case of the <emphasis>symbol</emphasis> or <emphasis>string</emphasis> inputs, the
procedure constructs a new record type subtyping the <emphasis>parent</emphasis> argument.
In the case of the <emphasis>rtd</emphasis> input, the <emphasis>rtd</emphasis> record type
must extend <literal>void*-rt</literal>.
<xref linkend="ffi-install-void*-subtype"/> returns the subtype record type.</simpara>

<simpara>The returned record type represents a tagged wrapped C pointer,
allowing one to encode type hierarchies.</simpara>

<simpara><anchor id="establish-void*-subhierarchy!" xreflabel="establish-void*-subhierarchy!"></anchor>
<emphasis> Procedure establish-void*-subhierarchy!</emphasis>
<simpara>
<indexterm><primary><code>establish-void*-subhierarchy!</code></primary></indexterm>
<literal>(establish-void*-subhierarchy! <emphasis>symbol-tree</emphasis>)  =&gt; <emphasis>unspecified</emphasis></literal>
</simpara></simpara>

<simpara><xref linkend="establish-void*-subhierarchy!"/> is a convenience function
for constructing large object hierarchies.
It descends the <emphasis>symbol-tree</emphasis>,
creates a record type descriptor for each symbol
(where the root of the tree has the parent <literal>void*-rt</literal>),
and invokes <xref linkend="ffi-install-void*-subtype"/> on all
of the introduced types.</simpara>

<simpara><emphasis>Type char*</emphasis> extends <emphasis>void*</emphasis>
<anchor id="string-&gt;char*" xreflabel="string-&gt;char*"></anchor>
<emphasis> Procedure string-&gt;char*</emphasis>
<simpara>
<indexterm><primary><code>string-&gt;char*</code></primary></indexterm>
<literal>(string-&gt;char* <emphasis>string</emphasis>)  =&gt; <emphasis>char*</emphasis></literal>
</simpara>
<anchor id="char*-strlen" xreflabel="char*-strlen"></anchor>
<emphasis> Procedure char*-strlen</emphasis>
<simpara>
<indexterm><primary><code>char*-strlen</code></primary></indexterm>
<literal>(char*-strlen <emphasis>char*</emphasis>)  =&gt; <emphasis>fixnum</emphasis></literal>
</simpara>
<anchor id="char*-&gt;string" xreflabel="char*-&gt;string"></anchor>
<emphasis> Procedure char*-&gt;string</emphasis>
<simpara>
<indexterm><primary><code>char*-&gt;string</code></primary></indexterm>
<literal>(char*-&gt;string <emphasis>char*</emphasis>)  =&gt; <emphasis>string</emphasis></literal>
</simpara>
<simpara><literal>(char*-&gt;string <emphasis>char* len</emphasis>)  =&gt; <emphasis>string</emphasis></literal></simpara>
<anchor id="CallWithCharStar" xreflabel="CallWithCharStar"></anchor>
<emphasis> Procedure call-with-char*</emphasis>
<simpara>
<indexterm><primary><code>call-with-char*</code></primary></indexterm>
<literal>(call-with-char* <emphasis>string string-function</emphasis>)  =&gt; <emphasis>value</emphasis></literal>
</simpara>
<emphasis>Type char**</emphasis> extends <emphasis>void*</emphasis>
<anchor id="CallWithCharStarStar" xreflabel="CallWithCharStarStar"></anchor>
<emphasis> Procedure call-with-char**</emphasis>
<simpara>
<indexterm><primary><code>call-with-char**</code></primary></indexterm>
<literal>(call-with-char** <emphasis>string-vector function</emphasis>)  =&gt; <emphasis>value</emphasis></literal>
</simpara>
<emphasis>Type int*</emphasis> extends <emphasis>void*</emphasis>
<anchor id="CallWithIntStar" xreflabel="CallWithIntStar"></anchor>
<emphasis> Procedure call-with-int*</emphasis>
<simpara>
<indexterm><primary><code>call-with-int*</code></primary></indexterm>
<literal>(call-with-int* <emphasis>fixnum-vector function</emphasis>)  =&gt; <emphasis>value</emphasis></literal>
</simpara>
<emphasis>Type short*</emphasis> extends <emphasis>void*</emphasis>
<anchor id="CallWithShortStar" xreflabel="CallWithShortStar"></anchor>
<emphasis> Procedure call-with-short*</emphasis>
<simpara>
<indexterm><primary><code>call-with-short*</code></primary></indexterm>
<literal>(call-with-short* <emphasis>fixnum-vector function</emphasis>)  =&gt; <emphasis>value</emphasis></literal>
</simpara>
<emphasis>Type double*</emphasis> extends <emphasis>void*</emphasis>
<anchor id="CallWithDoubleStar" xreflabel="CallWithDoubleStar"></anchor>
<emphasis> Procedure call-with-double*</emphasis>
<simpara>
<indexterm><primary><code>call-with-double*</code></primary></indexterm>
<literal>(call-with-double* <emphasis>num-vector function</emphasis>)  =&gt; <emphasis>value</emphasis></literal>
</simpara></simpara>

<simpara>FIXME: (There are other functions, but I want to test and document the
ones above first&#8230;)</simpara>

</section>
<section>
<title>foreign-cstructs</title>
<simpara>The <literal>foreign-cstructs</literal> library provides a
more direct interface to C structures.
It provides the <literal>define-c-struct</literal> special form.
This form is layered on top of <literal>define-c-info</literal>;
the latter provides the structure field offsets
and sizes used to generate constructors
(which produce appropriately sized bytevectors,
not record instances).
The <literal>define-c-struct</literal> form combines these
with marshaling and unmarshaling procedures to
provide high-level access to a structure.</simpara>

<simpara>The grammar for the <literal>define-c-struct</literal> form is presented below.</simpara>

<literallayout class="monospaced">&lt;exp&gt;    ::= (define-c-struct (&lt;struct-type&gt; &lt;ctor-id&gt; &lt;c-decl&gt; ...)
                &lt;field-clause&gt; ...)

&lt;field-clause&gt;
         ::= (&lt;c-field&gt; &lt;getter&gt;) | (&lt;c-field&gt; &lt;getter&gt; &lt;setter&gt;)

&lt;getter&gt; ::= (&lt;id&gt;) | (&lt;id&gt; &lt;unmarshal&gt;)

&lt;setter&gt; ::= (&lt;id&gt;) | (&lt;id&gt; &lt;marshal&gt;)

&lt;marshal&gt; ::= &lt;ffi-attr-symbol&gt; | &lt;marshal-proc-exp&gt;

&lt;unmarshal&gt; ::= &lt;ffi-attr-symbol&gt; | &lt;unmarshal-proc-exp&gt;

&lt;struct-type&gt; ::= &lt;string-literal&gt;</literallayout>
</section>
<section>
<title>foreign-cenums</title>
<simpara>This library provides the special forms
 <literal>define-c-enum</literal> and <literal>define-c-enum-set</literal>,
which associate the identifiers of
a C <literal>enum</literal> type declaration
with the integer values they denote.</simpara>

<simpara>The <literal>define-c-enum</literal> form describes enums
encoding a discriminated sum;
<literal>define-c-enum-set</literal> describes bitmasks,
mapping them to R<superscript>6</superscript>RS enum-sets in Scheme.</simpara>

<simpara>The <literal>(define-c-enum <emphasis>en</emphasis> (&lt;c-decl&gt; &#8230;)  (<emphasis>x</emphasis> "<emphasis>cn</emphasis>") &#8230;)</literal>
form adds the <literal><emphasis>en</emphasis></literal> FFI attribute.
The attribute marshals each symbol <literal><emphasis>x</emphasis></literal> to
the integer value that <literal><emphasis>cn</emphasis></literal> denotes in C;
unmarshaling does the inverse translation.</simpara>

<simpara>The <literal>(define-c-enum-set <emphasis>ens</emphasis> (&lt;c-decl&gt; &#8230;) (<emphasis>x</emphasis> "<emphasis>cn</emphasis>") &#8230;)</literal>
form binds <emphasis>ens</emphasis> to an R<superscript>6</superscript>RS enum-set constructor
with universe resulting from
<literal>(make-enumeration '(<emphasis>x</emphasis> &#8230;))</literal>; it also adds the <literal><emphasis>ens</emphasis></literal>
FFI attribute.  The attribute marshals an
enum-set <emphasis>s</emphasis> constructed by <emphasis>ens</emphasis>
to the corresponding bitmask in C (that is,
the integer one would get by logically or'ing
all <emphasis>cn</emphasis> such that the corresponding <emphasis>x</emphasis> is in <emphasis>s</emphasis>).
Unmarshaling attempts to do the inverse translation.</simpara>

<simpara>The grammar for the two forms is presented below.</simpara>

<literallayout class="monospaced">&lt;exp&gt; ::= (define-c-enum &lt;enum-id&gt; (&lt;c-decl&gt; ...)
            (&lt;id&gt; &lt;c-name&gt;) ...)

&lt;exp&gt; ::= (define-c-enum-set &lt;enum-id&gt; (&lt;c-decl&gt; ...)
            (&lt;id&gt; &lt;c-name&gt;) ...)

&lt;enum-id&gt; ::= &lt;id&gt;</literallayout>
</section>
</section>
</section>
</section>
<section>
<title>Debugging</title>
<simpara>Larceny's debugging functionality is implemented in Scheme, using some
of Larceny's extensions for catching exceptions and inspecting the
continuation structure.</simpara>

<section>
<title>Entering the debugger</title>
<simpara>When Larceny detects an error or a keyboard interrupt, or when it hits
a breakpoint, it signals the condition by printing a message on the
console. Larceny then enters the debugger, which signals its presence
with a short banner and the debugger prompt:</simpara>

<literallayout class="monospaced">Entering debugger; type "?" for help.
debug&gt;</literallayout>
<simpara>You can also re-enter the debugger by evaluating (debug).</simpara>

</section>
<section>
<title>Debugger commands</title>
<simpara>The debugger is still in an immature state. The following commands are available (commands can be typed in upper or lower case):</simpara>

<simpara><emphasis role="strong">B</emphasis>     Print backtrace of continuation.</simpara>

<simpara><emphasis role="strong">C</emphasis>     Print source code of procedure, if available.</simpara>

<simpara><emphasis role="strong">D</emphasis>     Move down to previous (earlier) activation record.</simpara>

<simpara><emphasis role="strong">E <emphasis>n expr</emphasis></emphasis>      <emphasis>Expr</emphasis> is evaluated in the current
interaction environment and must evaluate to a procedure.
It is passed the contents of slot <emphasis>n</emphasis> from the current
activation record, and the result, if not unspecified,
is printed.</simpara>

<simpara><emphasis role="strong">E <emphasis>(n1 &#8230; nk) expr</emphasis></emphasis>      <emphasis>Expr</emphasis> is evaluated in the current
interaction environment and must evaluate to a procedure. It is
passed the contents of slots <emphasis>n1</emphasis> through <emphasis>nk</emphasis> from the current
activation record, and the result, if not unspecified, is printed.</simpara>

<simpara><emphasis role="strong">I <emphasis>n</emphasis></emphasis>      Inspect the procedure in slot <emphasis>n</emphasis> of the current
activation record.</simpara>

<simpara><emphasis role="strong">I @_</emphasis>      Inspect the active procedure.</simpara>

<simpara><emphasis role="strong">Q</emphasis>      Quit the debugger and abort the computation.</simpara>

<simpara><emphasis role="strong">R</emphasis>      Return from the debugger and continue the computation.</simpara>

<simpara><emphasis role="strong">S</emphasis>      Summarize the contents of the current activation record.</simpara>

<simpara><emphasis role="strong">U</emphasis>      Up to the next (later) activation record.</simpara>

<simpara><emphasis role="strong">X</emphasis>      Examine the contents of the current activation record.</simpara>

<simpara>The <emphasis role="strong">B</emphasis>, <emphasis role="strong">D</emphasis>, and <emphasis role="strong">U</emphasis> commands can be prefixed with a count, for example, 5 U moves up five activation records, and 10 B displays the next 10 activation records. The default for <emphasis role="strong">B</emphasis> is to display all the activations; the default count for <emphasis role="strong">D</emphasis> and <emphasis role="strong">U</emphasis> is 1.</simpara>

</section>
<section>
<title>Breakpoints</title>
<simpara>You can set breakpoints either in program text with the break primitive or interactively at the start of a procedure with the break-entry procedure. When Larceny reaches a breakpoint during execution, the program is suspended and the debugger is entered to allow you to inspect the program.</simpara>

<simpara><anchor id="larceny-break" xreflabel="larceny-break"></anchor>
<emphasis> Procedure larceny-break</emphasis>
<simpara>
<indexterm><primary><code>larceny-break</code></primary></indexterm>
<literal>(larceny-break <emphasis></emphasis>) </literal>
</simpara></simpara>

<simpara>Invokes the breakpoint handler.</simpara>

<simpara><anchor id="break-entry" xreflabel="break-entry"></anchor>
<emphasis> Procedure break-entry</emphasis>
<simpara>
<indexterm><primary><code>break-entry</code></primary></indexterm>
<literal>(break-entry <emphasis>procedure</emphasis>) </literal>
</simpara></simpara>

<simpara>Set a breakpoint at the start of the <emphasis>procedure</emphasis>.</simpara>

<simpara><anchor id="unbreak" xreflabel="unbreak"></anchor>
<emphasis> Procedure unbreak</emphasis>
<simpara>
<indexterm><primary><code>unbreak</code></primary></indexterm>
<literal>(unbreak <emphasis>procedure &#8230;</emphasis>) </literal>
</simpara></simpara>

<simpara><simpara><literal>(unbreak <emphasis></emphasis>) </literal></simpara></simpara>

<simpara>In the first form, remove any breakpoint set by break-entry at the start of the <emphasis>procedure_s. In the second form, remove all breakpoints set by _break-entry</emphasis>.</simpara>

</section>
<section>
<title>Tracing</title>
<simpara><anchor id="trace-entry" xreflabel="trace-entry"></anchor>
<emphasis> Procedure trace-entry</emphasis>
<simpara>
<indexterm><primary><code>trace-entry</code></primary></indexterm>
<literal>(trace-entry <emphasis>procedure</emphasis>) </literal>
</simpara></simpara>

<simpara>Set a trace point on entry to the <emphasis>procedure</emphasis>, removing any other trace points on the procedure. When the <emphasis>procedure</emphasis> is entered, information about the call is printed on the console: the name of the procedure and the actual arguments.</simpara>

<simpara><anchor id="trace-exit" xreflabel="trace-exit"></anchor>
<emphasis> Procedure trace-exit</emphasis>
<simpara>
<indexterm><primary><code>trace-exit</code></primary></indexterm>
<literal>(trace-exit <emphasis>procedure</emphasis>) </literal>
</simpara></simpara>

<simpara>Set a trace point on exit from the <emphasis>procedure</emphasis>, removing any other trace points on the procedure. When the <emphasis>procedure</emphasis> returns, information about the return is printed on the console: the name of the procedure and the returned values.</simpara>

<simpara>Note that trace-exit destroys the tail recursion properties of the instrumented procedure. Where the <emphasis>procedure</emphasis> would normally "return" by tail-calling another procedure, the instrumented procedure will call the other procedure by a non-tail call and then return, at which point the procedure name and return values will be printed. Thus use of trace-exit may destroy the space properties of the program.</simpara>

<simpara><anchor id="trace" xreflabel="trace"></anchor>
<emphasis> Procedure trace</emphasis>
<simpara>
<indexterm><primary><code>trace</code></primary></indexterm>
<literal>(trace <emphasis>procedure</emphasis>) </literal>
</simpara></simpara>

<simpara>Set trace points on <emphasis>procedure</emphasis> both at entry and exit.</simpara>

<simpara><anchor id="untrace" xreflabel="untrace"></anchor>
<emphasis> Procedure untrace</emphasis>
<simpara>
<indexterm><primary><code>untrace</code></primary></indexterm>
<literal>(untrace <emphasis>procedure &#8230;</emphasis>) </literal>
</simpara></simpara>

<simpara><simpara><literal>(untrace <emphasis></emphasis>) </literal></simpara></simpara>

<simpara>The first form removes any trace points from the specified procedures.
The second form removes all untrace points.</simpara>

</section>
<section>
<title>Other functionality</title>
<simpara><anchor id="break-handler" xreflabel="[break-handler]"/>
<indexterm>
  <primary>break-handler</primary>
</indexterm>
<emphasis>Parameter break-handler</emphasis></simpara>

<simpara>The value of break-handler is a procedure that is called when a breakpoint or tracepoint is encountered. The procedure takes two arguments: the procedure in which the breakpoint was set, and the byte offset within the procedure's code vector of the breakpoint.</simpara>

</section>
</section>
<section id="Standards">
<title>Standards</title>
<section>
<title>Scheme standards</title>
<simpara>IEEE Standard 1178-1990,
"IEEE Standard for the Scheme Programming Language",
IEEE, 1991. ISBN 1-55937-125-0.
May be ordered from IEEE by calling 1-800-678-IEEE or 908-981-1393
or writing
IEEE Service Center, 445 Hoes Lane, P.O. Box 1331,
Piscataway, NJ 08855-1331, and using order number SH14209.</simpara>

<simpara>Richard Kelsey, William Clinger, and Jonathan Rees [editors].
<ulink url="http://www.brics.dk/~hosc/11-1/">Revised^5 Report
on the Algorithmic Language Scheme</ulink>.
<emphasis>Journal of Higher Order and Symbolic Computation</emphasis>,
11(1), 1998, pages 7-105.
Also appears in <emphasis>ACM SIGPLAN Notices</emphasis> 33(9), September 1998.
Available online
<ulink url="http://www.schemers.org/Documents/Standards/R5RS/">in various formats</ulink>.</simpara>

<simpara>Michael Sperber, R Kent Dybvig, Matthew Flatt, and Anton van Straaten
[editors].
<ulink url="http://www.r6rs.org/">Revised^6 Report
on the Algorithmic Language Scheme</ulink>.</simpara>

<simpara>Various SchemePunks [editors].
<ulink url="http://scheme-punks.org/wiki/index.php?title=Main_Page">ERR5RS</ulink>
is under construction.</simpara>

</section>
<section>
<title>Other relevant standards</title>
<simpara>IEEE Standard 754-1985,
"IEEE Standard for Binary Floating-Point Arithmetic",
IEEE, 1985.</simpara>

<simpara>A
<ulink url="http://en.wikipedia.org/wiki/IEEE_754r">revision of IEEE Std 754-1985</ulink>
has been underway since 2000.
The IEEE Microprocessor Standards Committee (MSC)
accepted a candidate draft on 9 October 2006.
The candidate draft 1.2.6 was approved by 79% of 70 votes,
which exceeded the required supermajority of 75%.
Because there were negative votes and several hundred comments,
however, a revised draft 1.3.0 was prepared and approved by
84% of 73 votes.
Since there were over a hundred comments on the
second candidate draft as well, a third candidate draft 1.4.0 was
prepared and another vote taken in April 2007.
After a total of eight ballots, with the last four being
approved by more than 90% of the voters, the Ballot Review
Committee decided in May 2008 that
<ulink url="http://www.validlab.com/754R/">maximum possible timely
consensus has been obtained</ulink>, and the consensus draft was
submitted to IEEE-SA RevCom.
IEEE-754r was approved on 12 June 2008.</simpara>

<simpara>The Unicode Consortium.
<ulink url="http://www.unicode.org/">The Unicode 5.0 Standard</ulink>.
Addison-Wesley Professional, 2006.</simpara>

</section>
</section>
<index>
<title>Index</title>
</index>
</article>
