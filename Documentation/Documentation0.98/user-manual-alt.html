<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.0.0" />
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
}

strong {
  font-weight: bold;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1 {
  border-bottom: 2px solid silver;
}
h2 {
  border-bottom: 2px solid silver;
  padding-top: 0.5em;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.2em;
}
span#email {
}
span#revision {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble,
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-right: 10%;
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.5em;
  margin-bottom: 2.5em;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock {
  margin-right: 0%;
}
div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock > div.content {
  padding-left: 2.0em;
}

div.attribution {
  text-align: right;
}
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 2px solid silver;
}

div.exampleblock > div.content {
  border-left: 2px solid silver;
  padding: 0.5em;
}

div.verseblock div.content {
  white-space: pre;
}

div.imageblock div.content { padding-left: 0; }
div.imageblock img { border: 1px solid silver; }
span.image img { border-style: none; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: italic;
}
dd > *:first-child {
  margin-top: 0;
}

ul, ol {
    list-style-position: outside;
}
ol.olist2 {
  list-style-type: lower-alpha;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}

div.hlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
td.hlist1 {
  vertical-align: top;
  font-style: italic;
  padding-right: 0.8em;
}
td.hlist2 {
  vertical-align: top;
}

@media print {
  div#footer-badges { display: none; }
}
/* Workarounds for IE6's broken and incomplete CSS2. */

div.sidebar-content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}
div.sidebar-title, div.image-title {
  font-family: sans-serif;
  font-weight: bold;
  margin-top: 0.0em;
  margin-bottom: 0.5em;
}

div.listingblock div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock-content {
  padding-left: 2.0em;
}

div.exampleblock-content {
  border-left: 2px solid silver;
  padding-left: 0.5em;
}
</style>
<title>Larceny User Manual</title>
</head>
<body>
<div id="header">
<h1>Larceny User Manual</h1>
</div>
<div id="preamble">
<div class="sectionbody">
</div>
</div>
<h2><a id="LarcenyChapter"></a>1. Larceny</h2>
<div class="sectionbody">
<p>Larceny
implements the Scheme programming language
as defined by
the
<a href="#Standards">Revised<sup>7</sup> Report</a>,
the
<a href="#Standards">Revised<sup>6</sup> Report</a>,
the
<a href="#Standards">Revised<sup>5</sup> Report</a>,
and
<a href="#Standards">IEEE Standard 1178-1990</a>.
Those language standards serve as Larceny's primary documentation.</p>
<p>This manual describes aspects of Larceny that are not described
by the Revised Reports or IEEE-1178.
For the most current version of this manual, please see
<a href="http://larceny.ccs.neu.edu/doc">Larceny's online documentation page</a>.
For links to the Common Larceny User Manual and the Larceny
mailing list, please visit
<a href="http://www.larcenists.org/">Larceny's main web page</a>.</p>
<p>To report bugs, please send email to the Larceny
developers at <tt>&lt;larceny@ccs.neu.edu&gt;</tt>, or submit a
bug ticket at Larceny's
<a href="https://github.com/larcenists/larceny">GitHub site</a>.</p>
</div>
<h2><a id="InstallationChapter"></a>2. Installing Larceny</h2>
<div class="sectionbody">
<h3><a id="VarietiesSection"></a>2.1. Varieties of Larceny</h3>
<p>There are two main varieties of Larceny.</p>
<p>Native Larceny is the fastest and most convenient variety
of Larceny.  It compiles directly to native machine code
for Intel x86 microprocessors running Linux, Apple OS X,
or Windows operating systems.</p>
<p>Petit Larceny compiles to C instead of machine code.  It
can be made to run on most Unix machines.</p>
<h3><a id="SystemRequirementsSection"></a>2.2. System requirements</h3>
<p>Binary distributions of native Larceny are available for
just about any Intel x86-compatible microprocessor
running a Linux, Apple OS X, or Windows operating system.
Although Larceny still uses 32-bit pointers, it will run
on 64-bit machines provided the appropriate 32-bit
libraries have been installed.</p>
<p>Binary distributions of Petit Larceny are available for
x86 machines running Linux.  Petit Larceny requires the <tt>gcc</tt>
compiler as well as the appropriate 32-bit libraries.</p>
<p>For more details, see
<a href="http://larceny.ccs.neu.edu/doc/HOWTO-INSTALL"><tt>doc/HOWTO-INSTALL</tt></a>.
If you want to build Larceny or Petit Larceny from source code, see
<a href="http://larceny.ccs.neu.edu/doc/HOWTO-BUILD"><tt>doc/HOWTO-BUILD</tt></a>.</p>
<h3><a id="DownloadingSection"></a>2.3. Downloading</h3>
<p>The current versions of Larceny are available for
download at
<a href="http://www.larcenists.org/">Larceny's main web page</a>.</p>
<p>Larceny is distributed in two forms: as a precompiled
binary, or as source code that can be used to reconstruct
any of the precompiled binary distributions.
Unless you intend to modify Larceny yourself, you do not
need to download the source code.</p>
<h3><a id="InstallationSection"></a>2.4. Installing the programs</h3>
<p>Unpack the distribution files with an appropriate command such
as one of the following, substituting the version number (such
as 0.98) for "X.Y":</p>
<div class="literalblock">
<div class="content">
<pre><tt>tar -xzf larceny-X.Y-bin-native-ia32-linux86.tar.gz
tar -xzf larceny-X.Y-bin-native-ia32-macosx.tar.gz
tar -xzf larceny-X.Y-bin-native-ia32-win32.tar.gz
tar -xzf larceny-X.Y-bin-petit-stdc-macosx.tar.gz
tar -xzf larceny-X.Y-src.tar.gz</tt></pre>
</div></div>
<p>That will create a directory with a similar name (but without
the <tt>.tar.gz</tt> suffix) in your current working directory.
That is the Larceny root directory, which you may rename
to something shorter, such as <tt>larceny</tt>; the rest of this
section will refer to it by that name.</p>
<p>Assuming you have unpacked a binary distribution for Linux or
OS X, the <tt>larceny</tt> directory will contain the following files:</p>
<div class="literalblock">
<div class="content">
<pre><tt>larceny.bin         Run-time system
larceny.heap        Heap image with preloaded libraries and compiler
larceny             Shell script that runs the two files listed above
scheme-script       Shell script that runs Scheme scripts
compile-stale       Scheme script that compiles R7RS/R6RS libraries
startup.sch         Pathnames for the autoload and require features</tt></pre>
</div></div>
<p>If you unpacked a binary distribution, then you should be able to
run it immediately by making the <tt>larceny</tt> directory your current
working directory and invoking <tt>./larceny</tt>.
(If that does not work, you may need to install some 32-bit libraries
on your machine.  See
<a href="http://larceny.ccs.neu.edu/doc/HOWTO-INSTALL"><tt>doc/HOWTO-INSTALL</tt></a>.)</p>
<p>Binary distributions for Windows will include a <tt>larceny.bat</tt> file
in addition to the files listed above, so you can run Larceny by
invoking <tt>larceny</tt>.
(If that does not work, you may need to tell the
<a href="http://www.thewindowsclub.com/turn-off-data-execution-prevention-dep">DEP
 feature</a>
to let Larceny opt out.)</p>
<p>If you unpacked the source code there will be many other files and
directories, but <tt>larceny.bin</tt> and <tt>larceny.heap</tt> will not be present.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<p>You can reconstruct the <tt>larceny.bin</tt> and <tt>larceny.heap</tt> files from their
source code, but that process requires a working version of Larceny.
Unless you're porting Larceny or Petit Larceny to a
brand new target architecture, it's easier to obtain those
files from a binary distribution of Larceny.</p>
</td>
</tr></table>
</div>
<p>You may add the <tt>larceny</tt> directory to your standard path,
or you may install Larceny into a directory that is already
part of your standard path.</p>
<p>Suppose, for example, that you want to install Larceny
in <tt>/usr/local/bin</tt> and <tt>/usr/local/lib/larceny</tt>.
Copy the <tt>larceny</tt> and <tt>scheme-script</tt> files to <tt>/usr/local/bin</tt>
and edit the definition of <tt>LARCENY_ROOT</tt> at the head
of each file to point to the correct directory:</p>
<div class="literalblock">
<div class="content">
<pre><tt>LARCENY_ROOT=/usr/local/lib/larceny</tt></pre>
</div></div>
<p>Then move the entire <tt>larceny</tt> directory to <tt>/usr/local/lib/larceny</tt>.</p>
<p>You should now be able to run Larceny from any directory
by typing "<tt>larceny</tt>" at a prompt.</p>
<h3><a id="CompilingStdLibSection"></a>2.5. Compiling the R7RS/R6RS standard libraries</h3>
<p>If you are installing Petit Larceny, then you will have to
compile the R7RS/R6RS runtime and standard libraries before
you can run Larceny in R7RS or R6RS modes.</p>
<p>This step is also required if you are building any variety of
Larceny from source code.
With the prebuilt native varieties of Larceny, however, this step
should not be necessary unless you change one of the files in
<tt>lib/R7RS</tt>, <tt>lib/R6RS</tt>, or <tt>lib/SRFI</tt>.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<p>If the <tt>lib/R7RS</tt>, <tt>lib/R6RS</tt>, and <tt>lib/SRFI</tt> directories are
read-only, you will be less likely to touch, modify, or compile
the standard libraries by accident.</p>
</td>
</tr></table>
</div>
<p>Compiling the R7RS/R6RS runtime and standard libraries is
accomplished as follows:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    $ ./larceny
    Larceny v0.98 "General Ripper" (...)
    &gt; (require 'r7rsmode)
    &gt; (larceny:compile-r7rs-runtime)
    &gt; (exit)</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>Compiling the R7RS/R6RS runtime as shown above causes
all previously compiled R7RS/R6RS libraries and top-level
programs to become <a href="#CompilingChapter">stale</a>.  That means
those previously compiled files will need to be recompiled
or removed.</p>
</td>
</tr></table>
</div>
</div>
<h2><a id="RunningChapter"></a>3. Running Larceny</h2>
<div class="sectionbody">
<p>Larceny can run in any of these distinct modes:</p>
<div class="literalblock">
<div class="content">
<pre><tt>R5RS              traditional read/eval/print loop (the default)
R6RS              batch execution of R6RS top-level programs
R7RS              R7RS read/eval/print loop or batch execution
Scheme script     batch execution of R7RS/R6RS Scheme scripts</tt></pre>
</div></div>
<p><a href="#R5rsSection">R5RS mode</a>
extends the Scheme language described by the R5RS and
IEEE/ANSI Std 1178 by adding R7RS/R6RS lexical syntax and most
of the procedures described by the newer R6RS and R7RS standards.</p>
<p><a href="#R6rsSection">R6RS mode</a>
is largely redundant with Larceny's R7RS mode (because
every reasonable R6RS library and program could just as well be
executed in R7RS mode).  There is only one difference between
those two modes: R6RS mode enforces the R6RS mandates that, among
other things, forbid read/eval/print loops and most extensions
to R6RS lexical syntax.</p>
<p><a href="#R7rsSection">R7RS mode</a>
will accept any combination of R7RS and R6RS libraries
and programs.  In Larceny, R6RS Scheme becomes a proper subset of
R7RS Scheme.</p>
<p><a href="#SchemeScriptsSection">Scheme scripts</a>
are directly executable R7RS/R6RS programs.</p>
<h3><a id="R5rsSection"></a>3.1. R5RS mode</h3>
<p>When you start Larceny in R5RS mode (the default), you
will be presented with a banner message and the
read-eval-print loop's prompt:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    % larceny
    Larceny vX.Y "&lt;version_name&gt;" (MMM DD YYYY HH:MM:SS, ...)
    larceny.heap, built ...

    &gt;</tt></pre>
</div></div>
<p>You can enter a Scheme expression at the prompt.
After a complete expression has been read, it will
be evaluated and its results printed.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>In native Larceny, the expression is evaluated by
compiling it to native machine code, which is then executed.
In Petit Larceny, the expression is evaluated by
an interpreter because compiling to C, running the
C compiler, and loading the compiled C code would
take too long.  Interpreted code behaves like compiled code,
so most of what this manual says about the compiler is also
true of Petit Larceny's interpreter.</p>
</td>
</tr></table>
</div>
<h3><a id="R6rsSection"></a>3.2. R6RS mode</h3>
<p>To execute a top-level R6RS program that is contained
within a file named <tt>pgm</tt>, type:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    larceny -r6rs -program pgm</tt></pre>
</div></div>
<p>The <tt>-program</tt> option can be omitted, in which case
Larceny will read the top-level program from standard
input:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    larceny -r6rs &lt; pgm</tt></pre>
</div></div>
<p>If you omit the <tt>-program</tt> option and do not redirect
standard input, then Larceny will wait patiently
for you to type a complete top-level program into
standard input, terminating it with an end-of-file.</p>
<p>You probably don't want to do that.  Had you wanted to
type R6RS code at Larceny, you'd be using Larceny's R7RS
read/eval/print loop instead.</p>
<h3><a id="R7rsSection"></a>3.3. R7RS mode</h3>
<p>To execute a top-level R7RS/R6RS program that is contained
within a file named <tt>pgm</tt>, type:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    larceny -r7rs -program pgm</tt></pre>
</div></div>
<p>To interact with Larceny's R7RS read/eval/print loop,
omit the <tt>-program</tt> option:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    % larceny -r7rs
    Larceny v0.98 "General Ripper" (...)</tt></pre>
</div></div>
<p>The <tt>(scheme base)</tt> library has already been imported,
but you may want to import other libraries as well.
For example:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    &gt; (import (scheme read)
              (scheme write)
              (scheme file)
              (scheme cxr)
              (scheme inexact)
              (scheme complex)
              (scheme char)
              (scheme load))</tt></pre>
</div></div>
<p>If you'd rather have Larceny import all of the standard R7RS and
R6RS libraries at startup, along with a few Larceny-specific
procedures, you can use the <tt>-r7r6</tt> option instead of <tt>r7rs</tt>:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    % larceny -r7r6
    Larceny v0.98 "General Ripper" (...)</tt></pre>
</div></div>
<p>Using the <tt>-r7r6</tt> option is equivalent to using the <tt>-r7rs</tt>
option and then importing the <tt>(larceny r7r6)</tt> library.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>One name conflict could not be resolved by adding R7RS extensions
to the conflicting R6RS procedure or syntax.  When the <tt>-r7r6</tt>
option is used, the <tt>bytevector-copy!</tt> procedure is imported with
R7RS semantics, and the older R6RS version of that procedure is
renamed to <tt>r6rs:bytevector-copy!</tt>.</p>
</td>
</tr></table>
</div>
<p>The <tt>features</tt> procedure will return a list of all <tt>cond-expand</tt>
features and libraries available to you.  That procedure reads
the source code for all library files found in your current
<a href="#R7rsLibraryPathSection">Larceny library path</a>, so don't be
surprised if it takes a few seconds.</p>
<div class="listingblock">
<div class="content">
<pre><tt>    &gt; (features)
    (r7rs r6rs larceny larceny-0.98
     exact-closed ratios exact-complex complex ieee-float
     full-unicode full-unicode-strings unicode-7
     posix unix gnu-linux i386 ilp32 little-endian
     ...
     (rnrs arithmetic bitwise (6))
     (rnrs arithmetic fixnums (6))
     (rnrs arithmetic flonums (6))
     (rnrs bytevectors (6))
     ...
     (rnrs (6))
     (scheme base)
     (scheme case-lambda)
     (scheme char)
     (scheme complex)
     (scheme cxr)
     (scheme eval)
     (scheme file)
     (scheme inexact)
     (scheme lazy)
     (scheme load)
     (scheme process-context)
     (scheme r5rs)
     (scheme read)
     (scheme repl)
     (scheme time)
     (scheme write)
     (srfi 1)
     (srfi 1 lists)
     ...)</tt></pre>
</div></div>
<h4><a id="R7rsAutomaticLoadingSection"></a>3.3.1. Automatic loading</h4>
<p>As an extension to the R7RS and R6RS, Larceny attempts to load
libraries automatically when they are first imported.
Autoloading makes interactive development and
<a href="#CompilingChapter">separate compilation</a>
much more convenient.</p>
<p>All of Larceny's
<a href="#R7rsPreDefinedSection">predefined libraries</a>
can be autoloaded.</p>
<p>To enable autoloading of other R7RS/R6RS libraries,
including libraries you've written yourself, you can:</p>
<ul>
<li>
<p>
use the <a href="#R7rsLibraryPathSection"><tt>-path</tt> command-line option</a>
</p>
</li>
<li>
<p>
use the <a href="#R7rsLibraryVariableSection"><tt>LARCENY_LIBPATH</tt></a> environment variable
</p>
</li>
<li>
<p>
use <a href="#current-require-path"><tt>current-require-path</tt></a>
</p>
</li>
<li>
<p>
edit <tt>startup.sch</tt> in Larceny's root directory
</p>
</li>
<li>
<p>
add the libraries to Larceny's <tt>lib</tt> directory
</p>
</li>
</ul>
<h4><a id="R7rsDynamicLoadingSection"></a>3.3.2. Explicit loading</h4>
<p>Larceny automatically loads R7RS/R6RS libraries when
they are first imported.  This is usually the most
convenient way to load a library, but autoloading
can't be used to load a top-level program.  Explicit
loading is needed for top-level programs, for libraries
that don't reside in Larceny's
<a href="#current-require-path"><tt>current-require-path</tt></a>,
and for libraries that are defined in files whose names
do not follow Larceny's
<a href="#NamingChapter">standard naming conventions</a>.</p>
<p>In theory, explicit loading is the only portable way for R7RS
programs to load a library.
<a href="#LibraryResolutionSection">There is no portable way for R6RS programs to load or import libraries</a>,
so R6RS programs must rely upon implementation-specific
mechanisms such as Larceny's autoloading.</p>
<p>For explicit loading of nonstandard libraries, top-level
programs, or unadorned R5RS-style code from a file, you
must first import a suitable load procedure:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    &gt; (import (scheme load))</tt></pre>
</div></div>
<p>Loading a library does not automatically import it.
To use the variables and syntax that are exported by a
library, you must import that library explicitly:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    &gt; (load "lib/R6RS/larceny/benchmarking.sls")
    &gt; (import (larceny benchmarking))
    &gt; (time (vector-for-each + (make-vector 1000000 0)))
    Words allocated: 3053286
    Elapsed time...: 25 ms (User: 25 ms; System: 0 ms)
    Elapsed GC time: 3 ms (CPU: 2 in 2 collections (1 minor).)</tt></pre>
</div></div>
<p>In Larceny, you may omit the call to <tt>load</tt> because the
<tt>(larceny benchmarking)</tt> library will be autoloaded when
it is imported.  In other implementations of the R7RS, you
may have to load all of the nonstandard libraries that will
be imported by a top-level program or library before you
load that top-level program or library.</p>
<h4><a id="R7rsPreDefinedSection"></a>3.3.3. Predefined libraries</h4>
<p>Larceny predefines several nonstandard libraries in addition
to the standard R7RS and R6RS libraries, and autoloads them
for your convenience.  The predefined, autoloadable libraries
include:</p>
<p>Composite library:</p>
<div class="literalblock">
<div class="content">
<pre><tt>(larceny r7r6)                         ; all R7RS/R6RS standard libraries</tt></pre>
</div></div>
<p>R7RS standard libraries:</p>
<div class="literalblock">
<div class="content">
<pre><tt>(scheme base)
(scheme case-lambda)
(scheme char)
(scheme complex)
(scheme cxr)
(scheme eval)
(scheme file)
(scheme inexact)
(scheme lazy)
(scheme load)
(scheme process-context)
(scheme r5rs)
(scheme read)
(scheme repl)
(scheme time)
(scheme write)</tt></pre>
</div></div>
<p>R6RS standard libraries:</p>
<div class="literalblock">
<div class="content">
<pre><tt>(rnrs base (6))                        ; R6RS chapter 9
(rnrs unicode (6))                     ; R6RS library chapter 1
(rnrs bytevectors (6))                 ; R6RS library chapter 2
(rnrs lists (6))                       ; R6RS library chapter 3
(rnrs sorting (6))                     ; R6RS library chapter 4
(rnrs control (6))                     ; R6RS library chapter 5
(rnrs exceptions (6))                  ; R6RS library section 7.1
(rnrs conditions (6))                  ; R6RS library sections 7.2 and 7.3
(rnrs io ports (6))                    ; R6RS library sections 8.1 and 8.2
(rnrs io simple (6))                   ; R6RS library sections 8.1 and 8.3
(rnrs files (6))                       ; R6RS library chapter 9
(rnrs programs (6))                    ; R6RS library chapter 10
(rnrs arithmetic fixnums (6))          ; R6RS library section 11.2
(rnrs arithmetic flonums (6))          ; R6RS library section 11.3
(rnrs arithmetic bitwise (6))          ; R6RS library section 11.4
(rnrs syntax-case (6))                 ; R6RS library chapter 12
(rnrs hashtables (6))                  ; R6RS library chapter 13
(rnrs enums)                           ; R6RS library chapter 14
(rnrs (6))                             ; R6RS library chapter 15
(rnrs eval (6))                        ; R6RS library chapter 16
(rnrs mutable-pairs (6))               ; R6RS library chapter 17
(rnrs mutable-strings (6))             ; R6RS library chapter 18
(rnrs r5rs (6))                        ; R6RS library chapter 19</tt></pre>
</div></div>
<p>R6RS standard libraries that are autoloadable but deprecated in Larceny
because they have been superseded by the R7RS and SRFI 99 record
facilities:</p>
<div class="literalblock">
<div class="content">
<pre><tt>(rnrs records procedural (6))          ; R6RS library section 6.3
(rnrs records inspection (6))          ; R6RS library section 6.4
(rnrs records syntactic (6))           ; R6RS library section 6.2</tt></pre>
</div></div>
<p>SRFI libraries:</p>
<div class="literalblock">
<div class="content">
<pre><tt>(srfi 1 lists)                         ; list library
(srfi 2 and-let*)                      ; extended `and` and `let*`
(srfi 5 let)                           ; extended version of `let`
(srfi 6 basic-string-ports)            ; basic string ports
(srfi 8 receive)                       ; binding to multiple values
(srfi 9 records)                       ; defining record types
(srfi 11 let-values)                   ; syntax for multiple values
(srfi 13 strings)                      ; string libraries
(srfi 14 char-sets)                    ; character-set library (default)
(srfi 14 unicode)                      ;   for all Unicode characters
(srfi 14 bmp)                          ;   for the Basic Multilingual Plane
(srfi 14 latin-1)                      ;   for ISO 8859-1 (Latin-1)
(srfi 16 case-lambda)                  ; syntax for variable arity
(srfi 17 generalized-set!)             ; generalized set!
(srfi 19 time)                         ; time data types and procedures
(srfi 23 error)                        ; error reporting mechanism
(srfi 25 multi-dimensional-arrays)     ; multi-dimensional array primitives
(srfi 26 cut)                          ; specializing without currying
(srfi 27 random-bits)                  ; sources of random bits
(srfi 28 basic-format-strings)         ; basic format strings
(srfi 29 localization)                 ; localization
(srfi 38 with-shared-structure)        ; i/o for data with shared structure
(srfi 39 parameters)                   ; parameter objects
(srfi 41 streams)                      ; streams
(srfi 42 eager-comprehensions)         ; eager comprehensions
(srfi 43 vectors)                      ; vector library
(srfi 45 lazy)                         ; iterative lazy algorithms
(srfi 48 intermediate-format-strings)  ; format
(srfi 51 rest-values)                  ; rest values hackery
(srfi 54 cat)                          ; still more formatting
(srfi 59 vicinities)                   ; vicinity
(srfi 61 cond)                         ; a more general cond clause
(srfi 63 arrays)                       ; homogeneous, heterogeneous arrays
(srfi 64 testing)                      ; an API for test suites
(srfi 67 compare-procedures)           ; three-way comparison procedures
(srfi 78 lightweight-testing)          ; lightweight testing
(srfi 87 case)                         ; a more general case clause
(srfi 98 os-environment-variables)     ; environment variables
(srfi 99 records)                      ; (composite library)
(srfi 99 records procedural)           ; (procedural API)
(srfi 99 records inspection)           ; (inspection API)
(srfi 99 records syntactic)            ; (syntactic API)
(srfi 101 random-access-lists)         ; fast and purely functional lists
(srfi 111 boxes)                       ; boxes
(srfi 112)                             ; environment inquiry
(srfi 113 sets)                        ; sets and bags
(srfi 114 comparators)                 ; comparators
(srfi 115 regexp)                      ; regular expressions
(srfi 116 ilists)                      ; immutable lists</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>For backward compatibility,
<tt>(srfi 1 lists)</tt> through <tt>(srfi 101 random-access-lists)</tt> are also
available with the SRFI 97 naming convention in which the number is
preceded by a colon, as in <tt>(srfi :1 lists)</tt>.
With the more liberal R7RS syntax, that SRFI 97 naming convention
is now unnecessary.
Larceny has extended the R6RS <tt>library</tt> syntax to allow R6RS libraries
to import R7RS libraries that follow the R7RS naming convention shown
in the list above.</p>
</td>
</tr></table>
</div>
<p>SRFI libraries that are autoloadable but deprecated in Larceny,
usually because they have been superseded in whole or in part by
R6RS syntax or libraries:</p>
<div class="literalblock">
<div class="content">
<pre><tt>(srfi 60 integer-bits)                 ; integers as bits
(srfi 66 octet-vectors)                ; octet vectors
(srfi 69 basic-hash-tables)            ; basic hash tables
(srfi 71 let)                          ; extensions of let, let*, letrec
(srfi 74 blobs)                        ; octet-addressed binary blocks
(srfi 95 sorting-and-merging)          ; sorting and merging</tt></pre>
</div></div>
<p>ERR5RS libraries that are autoloadable but deprecated in Larceny
because they have been superseded by the R7RS and SRFI 99 record
facilities:</p>
<div class="literalblock">
<div class="content">
<pre><tt>(err5rs records procedural)            ; ERR5RS records (procedural API)
(err5rs records inspection)            ; ERR5RS records (inspection API)
(err5rs records syntactic)             ; ERR5RS records (syntactic API)
(err5rs load)                          ; ERR5RS load procedure</tt></pre>
</div></div>
<p>Other autoloadable libraries:</p>
<div class="literalblock">
<div class="content">
<pre><tt>(larceny load)                         ; extension of (err5rs load)
(larceny compiler)                     ; separate compilation (R7RS/R6RS)
(larceny benchmarking)                 ; timing facilities
(larceny profiling)                    ; profiling of Scheme code
(larceny r7r6)                         ; all R7RS/R6RS standard libraries
(larceny records printer)              ; custom printing of records
(larceny shivers-syntax)               ; syntax favored by Olin Shivers
(r5rs)                                 ; approximates the R5RS top level
(explicit-renaming)                    ; macros with explicit renaming</tt></pre>
</div></div>
<h4><a id="R7rsLibraryVariableSection"></a>3.3.4. Library path</h4>
<p>Larceny's autoload feature locates R7RS/R6RS libraries
by performing a
<a href="#LibraryTranslationSection">depth-first search</a>
of the directories that belong to Larceny's
<a href="#current-require-path"><tt>current-require-path</tt></a>.
Libraries will not be autoloaded unless they are defined
in files whose names follow
<a href="#NamingChapter">Larceny's standard conventions</a>.</p>
<p>The
<a href="#current-require-path"><tt>current-require-path</tt></a>
is initialized by the <tt>startup.sch</tt> file in Larceny's root
directory.</p>
<p><a href="#R6rsLibraryPathSection">Larceny's <tt>-path</tt> command-line option</a>
adds one or more directories to the directories in the
<a href="#current-require-path"><tt>current-require-path</tt></a>.
On most systems, you can specify multiple directories
by separating them with a colon; under Windows, use a
semicolon as separator instead.  The first directory
listed will be searched first.</p>
<p>The <a href="#R6rsLibraryVariableSection"><tt>LARCENY_LIBPATH</tt></a>
environment variable can also be used to add one or more directories
to the directories in the
<a href="#current-require-path"><tt>current-require-path</tt></a>.
Multiple directories should be specified as with the <tt>-path</tt> option.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<p>If you have a set of portable libraries that run under more than
one implementation of the R7RS, and you want to have a special
version of some of those libraries for Larceny, you can put all
your portable versions in one directory and the Larceny-specific
versions in another.  When you run Larceny, use the <tt>-path</tt>
option and specify the Larceny-specific directory first.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>The <tt>-path</tt> option cannot be used by Scheme scripts,
because command-line options are passed along to the Scheme
script without being interpreted by the <tt>scheme-script</tt> processor.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>We emphasize that these extensions are non-portable.
Other implementations of the R7RS or R6RS may not provide
anything comparable to Larceny's <tt>-path</tt> option or
<tt>LARCENY_LIBPATH</tt> environment variable.
Even if they do, their mappings from library names
to file names may be incompatible with Larceny's.</p>
</td>
</tr></table>
</div>
<h4><a id="DefiningLibrariesSection"></a>3.3.5. Defining libraries</h4>
<p>As an extension to the R7RS and R6RS, Larceny allows a top-level
program or Scheme script to define R7RS/R6RS libraries within
the file that contains the top-level program or Scheme
script, before the import form that begins the top-level
program.  These libraries must be arranged so that no
library depends upon libraries that come later in the
file.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>We emphasize that this extension is non-portable.</p>
</td>
</tr></table>
</div>
<h4><a id="R7rsPrimitivesSection"></a>3.3.6. Importing procedures from Larceny's underlying R5RS system</h4>
<p>Any of Larceny's R5RS-mode top-level procedures can be imported
into an R7RS or R6RS library or program by using an import
declaration with a <tt>primitives</tt> clause that names the R5RS
procedures to be imported.  For example:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    (import (primitives random current-seconds
                        getenv setenv system
                        current-directory file-modification-time)
            (scheme time))</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>This feature is highly non-portable.
Other implementations of the R7RS or R6RS may not even
have an underlying implementation of the R5RS.</p>
</td>
</tr></table>
</div>
<h3><a id="SchemeScriptsSection"></a>3.4. Scheme scripts</h3>
<p>On most Unix systems (including Linux and Apple's OS X), Larceny's
<tt>scheme-script</tt> will execute Scheme scripts as described in R6RS
non-normative appendix D, with or without the optional script
header.  To make Scheme scripts executable in their own
right, without executing <tt>scheme-script</tt> directly, add Larceny's
root directory to your path as described in <tt>doc/HOWTO-INSTALL</tt>,
or edit <tt>scheme-script</tt> to define <tt>LARCENY_ROOT</tt> and copy that
edited <tt>scheme-script</tt> to a directory in your path.</p>
<p>Suppose, for example, that <tt>/home/myself/hello</tt> is an R7RS/R6RS
Scheme script whose first line is the optional script header
shown below:</p>
<div class="listingblock">
<div class="content">
<pre><tt>#!/usr/bin/env scheme-script</tt></pre>
</div></div>
<p>If you do not have execute permission for this script,
or Larceny's root directory is not in your path,
you can still run the script from
Larceny's root directory as follows:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    % ./scheme-script /home/myself/hello</tt></pre>
</div></div>
<p>If you have execute permission for the script, and Larceny's
root directory is in your path, you can also run the
script as follows:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    % /home/myself/hello</tt></pre>
</div></div>
<p>If, in addition, the directory that contains the script is
in your path, you can run the script as follows:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    % hello</tt></pre>
</div></div>
<p>You may also pass command-line arguments to a Scheme script.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>We emphasize that Scheme scripts are not portable.
Scheme scripts are specified only by a non-binding appendix
to the R6RS, not by the R6RS proper.
Other implementations of the R7RS or R6RS may not support Scheme
scripts at all, or may give them a semantics incompatible
with Larceny's.</p>
</td>
</tr></table>
</div>
<p>On Unix systems, standard input and output can be redirected
in the usual way.  In Larceny, standard input corresponds to
the textual port initially returned by <tt>current-input-port</tt>,
and standard output corresponds to the textual port initially
returned by <tt>current-output-port</tt>.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>We emphasize that redirection of standard input and output
is non-portable.
Other implementations of the R7RS or R6RS may not allow redirection,
or may identify the standard input and output with ports
other than those initially returned by <tt>current-input-port</tt>
and <tt>current-output-port</tt>.</p>
</td>
</tr></table>
</div>
<h3><a id="R5rsScriptSection"></a>3.5. R5RS scripting</h3>
<p>Suppose <tt>hello.sch</tt> contains the following R5RS code:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    (display "Hello world!")
    (newline)
    (exit)</tt></pre>
</div></div>
<p>You can run <tt>hello.sch</tt> as a script by executing Larceny as
follows:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    % larceny -nobanner -- hello.sch</tt></pre>
</div></div>
<p>You can redirect Larceny's standard input, in which case
you may want to eliminate the herald announcement and the
read/eval/print loop's prompt:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    % larceny -nobanner -- -e "(begin (herald #f) (repl-prompt values))" \
              &lt; hello.sch</tt></pre>
</div></div>
<p>For an explanation of why that works, which may suggest other
creative uses of Larceny, ask for help:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    % larceny -help</tt></pre>
</div></div>
<h3><a id="ErrorsSection"></a>3.6. Errors</h3>
<p>In R6RS mode, which is batch-only, errors should result in an
error message followed by a clean exit from the program.</p>
<p>If your program encounters an error in an interactive mode
(R5RS or R75RS), it will enter the debugger; this is
believed to be a feature.</p>
<p>Despite its crudity, and to some extent because of it,
Larceny's debugger works at least as well with optimized
compiled code as with interpreted code.</p>
<p>If you type a question mark at the debugger prompt, the
debugger will print a help message.  That message is more
helpful if you understand the Twobit compiler and
Larceny's internal representations and invariants, but
this manual is not the place to explain those things.</p>
<p>The debugging context is saved so you can exit the debugger
and re-enter it from the main read/eval/print loop's prompt:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    &gt; (debug)</tt></pre>
</div></div>
<p>The debugger is pretty much a prototype; you don't need to
tell us how bad it is.</p>
<h3>3.7. Troubleshooting</h3>
<h4>3.7.1. Errors when starting Larceny</h4>
<p>Although Larceny runs on x86-64 machines, it requires 32-bit
libraries that are not always installed on Linux and MacOS X
machines.  If those libraries are absent, the operating system
will probably give you a mysterious or misleading error message
when you try to run Larceny.  For example, the operating system's
loader may tell you "larceny.bin not found" even though it's
perfectly obvious that <tt>larceny.bin</tt> is present within Larceny's
root directory.  To install the necessary 32-bit libraries on
Linux machines with x86-compatible processors, someone with
superuser privileges must incant</p>
<div class="listingblock">
<div class="content">
<pre><tt>    sudo apt-get install lib32z1
    sudo apt-get install libc6-i386</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>The names of those 32-bit packages have changed over time, and
may change again.</p>
</td>
</tr></table>
</div>
<p>For Macintosh machines, someone with administrative privileges
must install the
<a href="https://developer.apple.com/opensource/">Apple Developer Command Line Tools</a>.</p>
<p>When attempting to run an R7RS/R6RS program, you may see
a warning about "<tt>loading source in favor of stale
fasl file</tt>",
following by a long series of error messages about
syntactic keywords used as a variable, ending with
the kind of error you'd expect to see when a large
R7RS/R6RS program is fed to a Scheme compiler that was
expecting to see R5RS-compatible code.  That means
the R7RS/R6RS runtime and standard libraries were not
installed correctly, or their source files have been
touched or modified since they were last compiled.
To fix the problem,
<a href="#CompilingStdLibSection">recompile the R7RS standard libraries</a>.</p>
<p>The precompiled binary forms of Larceny should run on
most machines that use an appropriate processor and operating
system, but the executable program "<tt>larceny.bin</tt>" may be
incompatible with very old or with very new versions of
the processor or operating system.  If that appears to be
the case, you should see whether a newer version of Larceny
fixes the problem.  If not, please report the problem
to us at <tt>larceny@ccs.neu.edu</tt>.
Please report success stories as well.</p>
<h4>3.7.2. Errors when compiling the R7RS runtime</h4>
<p>If something goes wrong while
<a href="#CompilingStdLibSection">compiling the R7RS runtime</a>,
make sure you are running the copy of Larceny you think
you are running and have read and write permission
for <tt>lib/R7RS</tt>, <tt>lib/R6RS</tt>, <tt>lib/SRFI</tt>,
and all their subdirectories and files.
If you get an error message about something being
"<tt>expanded against a different build of this library</tt>",
then one or more of the compiled files in
<tt>lib/R7RS</tt> or <tt>lib/R6RS</tt> or <tt>lib/SRFI</tt>
or its subdirectories has gone
<a href="#CompilingChapter">stale</a>.
Removing all <tt>.slfasl</tt> files from <tt>lib/R6RS</tt> and <tt>lib/SRFI</tt> and
their subdirectories will eliminate the stale file(s).</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>Don't remove the <tt>.sch</tt>, <tt>.scm</tt>, <tt>.sls</tt>, or <tt>.sld</tt> files.</p>
</td>
</tr></table>
</div>
<h4><a id="AutoLoadErrorsSection"></a>3.7.3. Autoloading errors</h4>
<p>If Larceny attempts to autoload an imported R7RS/R6RS
library but cannot find the library, then the library
may be defined in a file that doesn't follow
<a href="#NamingChapter">Larceny's standard naming conventions</a>.
Another possibility is that the <tt>-path</tt> option was
omitted or incorrect.</p>
<p>If an R7RS/R6RS library is recompiled, then all compiled
libraries and top-level programs that depend upon it must
also be recompiled.  In particular, recompiling the standard
R7RS runtime will invalidate all compiled libraries and
top-level programs.  Larceny's <tt>compile-stale</tt> script
and the
<a href="#compile-stale-libraries"><tt>compile-stale-libraries</tt></a>
procedure of <tt>(larceny compiler)</tt> make it convenient
to recompile all of the libraries and top-level
programs within any given directory in an order
consistent with their dependencies.</p>
<h4><a id="CrashesSection"></a>3.7.4. Crashes</h4>
<p>Please report all crashes with as much information is possible;
a backtrace from a debugger or a core dump is ideal (but please
do not mail the core dump without contacting us first).
Larceny's run-time system is compiled with full debugging
information by default and a debugger like GDB should be able
to provide at least some clues.</p>
<h3><a id="PerformanceSection"></a>3.8. Performance</h3>
<p>By default, Larceny's Twobit compiler performs several optimizations
that are fully compatible with the R7RS but may not be fully compatible
with the older R6RS, R5RS, and IEEE-1178 standards.</p>
<p>When compiling R5RS code, Larceny's Twobit compiler normally
makes several assumptions that allow it to generate faster code;
for example, the compiler assumes Scheme's standard
procedures will not be redefined.</p>
<p>To obtain strict conformance to R5RS semantics at
the expense of slower code, use R5RS mode and
evaluate the expression</p>
<div class="listingblock">
<div class="content">
<pre><tt>    (compiler-switches 'standard)</tt></pre>
</div></div>
<p>To make the compiler generate faster code, you can promise not to
redefine standard procedures <em>and</em> not to redefine any top-level
procedure while it is running. To make this promise, evaluate</p>
<div class="listingblock">
<div class="content">
<pre><tt>        (compiler-switches 'fast-safe)</tt></pre>
</div></div>
<p>To view the current settings of Twobit's numerous compiler switches,
evaluate</p>
<div class="listingblock">
<div class="content">
<pre><tt>        (compiler-switches)</tt></pre>
</div></div>
<p>All of Twobit's compiler switches are procedures whose setting
can be changed by passing the new value of the switch as an
argument.</p>
<p>For more information, evaluate</p>
<div class="listingblock">
<div class="content">
<pre><tt>        (help)</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>That <tt>help</tt> procedure is predefined only in R5RS mode, and
some of the help information that will be printed may be
irrelevant to the heap image you are using.</p>
</td>
</tr></table>
</div>
<p>To alter the compiler switches from R7RS mode, or
to disable certain compiler optimizations that are
incompatible with the R6RS, see the section that
describes the
<a href="#LarcenyCompilerSection"><tt>(larceny compiler)</tt> library</a>.</p>
</div>
<h2><a id="LexicalChapter"></a>4. Lexical syntax</h2>
<div class="sectionbody">
<p>Larceny's default lexical syntax extends the lexical syntax
required by the R5RS, R6RS, and R7RS <a href="#Standards">standards</a>.</p>
<p>The R6RS forbids most lexical extensions, however, so Larceny
provides several mechanisms for turning its lexical extensions
on and off.</p>
<h3><a id="FlagsSection"></a>4.1. Flags</h3>
<p>By default, Larceny recognizes several Larceny-specific flags
of the form permitted by the R6RS.  The flag you are most
likely to encounter represents one of Larceny's unspecified
values:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    #!unspecified</tt></pre>
</div></div>
<p>Certain other flags have special meanings to Larceny's
<tt>read</tt> and <tt>get-datum</tt> procedures.  They are described below.</p>
<h3><a id="CaseFoldingSection"></a>4.2. Case-sensitivity</h3>
<p>By default, Larceny is case-sensitive.
This global default can be overridden by specifying
<tt>&#8212;foldcase</tt> or <tt>&#8212;nofoldcase</tt> on Larceny's command line,
or by changing the value of Larceny's <tt>case-sensitive?</tt> parameter.</p>
<p>The case-sensitivity of a particular textual input port
is affected by reading one of the following flags from
the port using the <tt>read</tt> or <tt>get-datum</tt> procedures:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    #!fold-case
    #!no-fold-case</tt></pre>
</div></div>
<p>The <tt>#!fold-case</tt> flag enables case-folding on data read from
the port by the <tt>read</tt> and <tt>get-datum</tt> procedures, while the
<tt>#!no-fold-case</tt> flag disables case-folding.  The behavior
established by one of these flags extends to the next such flag
read from the port by <tt>read</tt> or <tt>get-datum</tt>.</p>
<p>Both <tt>#!fold-case</tt> and <tt>#!no-fold-case</tt> are treated as comments
by Larceny's <tt>read</tt> and <tt>get-datum</tt> procedures.  (This is a change
from Larceny v0.97.)</p>
<h3><a id="LexicalExtensionsSection"></a>4.3. Lexical extensions</h3>
<p>When a port is first opened, the Larceny-specific lexical
extensions that are accepted on the port are determined
by Larceny's <a href="#LexicalParametersSection">lexical parameters</a>.</p>
<p>The following flags change the case-sensitivity and lexical
extensions on the specific port from which they are read:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    #!r7rs         ; implies #!no-fold-case, enables R7RS syntax
    #!r6rs         ; implies #!no-fold-case, negates other flags
    #!r5rs         ; implies #!fold-case, enables R7RS syntax
    #!err5rs       ; enables R7RS/R6RS syntax with extensions
    #!larceny      ; implies #!no-fold-case and #!err5rs</tt></pre>
</div></div>
<p>All of those flags are treated as comments by Larceny's <tt>read</tt>
and <tt>get-datum</tt> procedures.  (This is a change from Larceny
v0.97.)</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>The <tt>#!r6rs</tt> flag is the only flag that <em>disables</em> lexical
extensions.  To disable R6RS lexical extensions when new ports
are created, use the
<a href="#LexicalParametersSection"><tt>read-r6rs-weirdness?</tt> parameter</a>
described below.</p>
</td>
</tr></table>
</div>
<h3><a id="LexicalParametersSection"></a>4.4. Lexical parameters</h3>
<p>When given no argument, these parameters return the current
default for some aspects of the lexical syntax that will be
accepted on newly created input ports or written to newly
created output ports.
When given an argument, these procedures change the default
as specified by the argument.</p>
<p>The initial values of these parameters are determined by the
<tt>-r7r6</tt>, <tt>-r7rs</tt>, <tt>-r6rs</tt>, or <tt>-r5rs</tt> options on Larceny's
command line.  The <tt>-r6rs</tt> option disables non-R6RS lexical
syntax; the <tt>-r7r6</tt>, <tt>-r7rs</tt>, and <tt>-r5rs</tt> options allow both
R7RS and R6RS syntax.</p>
<p><a id="case-sensitive?"></a>
<em> Procedure case-sensitive?</em>
<p><tt>(case-sensitive? <em></em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(case-sensitive? <em>boolean</em>) </tt></p></p>
<p>If true, newly created textual input ports behave as though they
began with <tt>!fold-case</tt>.  If false, newly created textual input
ports behave as though they began with <tt>!no-fold-case</tt>.</p>
<p><a id="read-r6rs-flags?"></a>
<em> Procedure read-r6rs-flags?</em>
<p><tt>(read-r6rs-flags? <em></em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(read-r6rs-flags? <em>boolean</em>) </tt></p></p>
<p>If true, allows flags other than <tt>!r6rs</tt> to be read from
newly created ports.
If false, flags other than <tt>!r6rs</tt> raise exceptions when
read.</p>
<p><a id="read-r7rs-weirdness?"></a>
<em> Procedure read-r7rs-weirdness?</em>
<p><tt>(read-r7rs-weirdness? <em></em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(read-r7rs-weirdness? <em>boolean</em>) </tt></p></p>
<p>If true, newly created textual input ports behave as though they
began with <tt>#!r7rs</tt>, and R7RS lexical syntax will be used when
writing external representations to newly created textual output
ports.
If false, R7RS-specific extensions to R5RS/R6RS lexical syntax
may raise exceptions.</p>
<p><a id="read-r6rs-weirdness?"></a>
<em> Procedure read-r6rs-weirdness?</em>
<p><tt>(read-r6rs-weirdness? <em></em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(read-r6rs-weirdness? <em>boolean</em>) </tt></p></p>
<p>If true, allows all R6RS lexical syntax on newly created ports
without disabling other lexical syntax on those ports (so
newly created textual input ports <em>do not</em> behave as though
they began with <tt>#!r6rs</tt>).
If false, R6RS-specific extensions to R5RS/R7RS lexical syntax
may raise exceptions.</p>
<p>If <tt>read-r6rs-weirdness?</tt> is true and <tt>read-r7rs-weirdness?</tt>
is false, then the R6RS bytevector syntax will be used when
writing to newly opened textual output ports.  If neither
or both are true, then R7RS bytevector syntax will be used.</p>
<p><a id="read-larceny-weirdness?"></a>
<em> Procedure read-larceny-weirdness?</em>
<p><tt>(read-larceny-weirdness? <em></em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(read-larceny-weirdness? <em>boolean</em>) </tt></p></p>
<p>Determines whether newly created textual ports allow
Larceny's usual extensions to R5RS lexical syntax.
In addition, this parameter determines whether newly created
ports allow <tt>#</tt> as an insignificant digit, which is
required by the R5RS but disallowed by the R6RS and not
required by the R7RS.</p>
<p><a id="read-traditional-weirdness?"></a>
<em> Procedure read-traditional-weirdness?</em>
<p><tt>(read-traditional-weirdness? <em></em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(read-traditional-weirdness? <em>boolean</em>) </tt></p></p>
<p>Determines whether newly created textual ports allow
certain lexical extensions that are deprecated in Larceny.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>The semantics of <tt>read-larceny-weirdness?</tt> and
<tt>read-traditional-weirdness?</tt> will change over time as
deprecated misfeatures are added or dropped in response to
popular demand or apathy.
For the current semantics of these parameters, please consult
the Larceny developers' web page that describes
<a href="https://github.com/larcenists/larceny/wiki/LexicalConversion">Larceny's
lexical syntax</a>.</p>
</td>
</tr></table>
</div>
</div>
<h2><a id="NamingChapter"></a>5. File naming conventions</h2>
<div class="sectionbody">
<h3><a id="SuffixSection"></a>5.1. Suffixes</h3>
<p>In Larceny, file names generally follow Unix conventions,
even on Windows.  The following suffixes have special
meanings to some components of Larceny.</p>
<dl>
<dt>
<tt>.sld</tt>
</dt>
<dd>
<p>
is the preferred suffix for files that contain libraries
defined by the R7RS <tt>define-library</tt> syntax.
</p>
</dd>
<dt>
<tt>.sls</tt>
</dt>
<dd>
<p>
is the preferred suffix for files that contain libraries
defined by the R6RS <tt>library</tt> syntax.
</p>
</dd>
<dt>
<tt>.sps</tt>
</dt>
<dd>
<p>
is the preferred suffix for files that contain R7RS/R6RS
top-level programs (which consist of an <tt>import</tt> declaration
followed by definitions and expressions).
</p>
</dd>
<dt>
<tt>.scm</tt>
</dt>
<dd>
<p>
is the preferred suffix for files that contain R7RS/R5RS
definitions and expressions but don't contain any <tt>import</tt>
declarations and don't define any R7RS/R6RS libraries.
</p>
</dd>
<dt>
<tt>.sch</tt>
</dt>
<dd>
<p>
is an alternative to <tt>.scm</tt> used by Larceny developers.
</p>
</dd>
<dt>
<tt>.slfasl</tt>
</dt>
<dd>
<p>
is the suffix for files that contain the compiled form of
a <tt>.sld</tt>, <tt>.sls</tt>, or <tt>.sps</tt> file.
</p>
</dd>
<dt>
<tt>.fasl</tt>
</dt>
<dd>
<p>
is the suffix for files that contain the compiled form of
R5RS source code (usually <tt>.scm</tt> or <tt>.sch</tt>).
</p>
</dd>
<dt>
<tt>.mal</tt>
</dt>
<dd>
<p>
is the preferred suffix for files that contain MacScheme
assembly language in symbolic form.
</p>
</dd>
<dt>
<tt>.lap</tt>
</dt>
<dd>
<p>
is the suffix for files that contain MacScheme assembly language.
</p>
</dd>
<dt>
<tt>.lop</tt>
</dt>
<dd>
<p>
is the suffix for files that contain machine code
segments in the form expected by Larceny's heap linker.
</p>
</dd>
<dt>
<tt>.heap</tt>
</dt>
<dd>
<p>
is the suffix for files that contain an executable heap
image (must be combined with the
<a href="#InstallationSection"><tt>larceny.bin</tt></a> runtime).
</p>
</dd>
</dl>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>In Larceny, R7RS <tt>define-library</tt> and R6RS <tt>library</tt> syntaxes
are mostly interchangeable.  The R6RS <tt>for</tt> and <tt>meta</tt> keywords
may be needed when defining <tt>syntax-case</tt> macros, but the R7RS
syntax is otherwise more versatile because of its <tt>include</tt> and
<tt>cond-expand</tt> features.  For new code, we recommend the R7RS
<tt>define-library</tt> syntax.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>Although the R7RS <tt>define-library</tt> syntax allows <tt>export</tt> and
<tt>import</tt> declarations to be placed anywhere at the top level of
the syntax, it is standard practice to use only one <tt>export</tt>
declaration per library, placed immediately following the name
of the library, and to use only one <tt>import</tt> declaration per
library, placed immediately following the <tt>export</tt> declaration.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>Some of Larceny's compilation tools rely upon the convention
described within the note above, and may not work if that
convention is not followed.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<p>An R7RS library definition may be split into two or more files,
with the primary <tt>.sld</tt> file containing one or more <tt>include</tt>
declarations that include <tt>.scm</tt> files.  If <tt>foo.sld</tt> is the
primary file, then the included file is ordinarily named
<tt>foo.body.scm</tt> and placed within the same directory as <tt>foo.sld</tt>.
If more than one <tt>.scm</tt> file is included, we recommend
<tt>foo.body1.scm</tt>, <tt>foo.body2.scm</tt>, and so on.  A Larceny-specific
version of <tt>foo.body2.scm</tt> that's conditionally included using
the <tt>cond-expand</tt> feature might be named <tt>foo.body2.larceny.scm</tt>.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<p>Portable source code can be tailored to Larceny and other
implementations of the R7RS by combining implementation-specific
mechanisms such as Larceny's <tt>-path</tt> option with the <tt>include</tt>
and <tt>cond-expand</tt> features of R7RS libraries.</p>
</td>
</tr></table>
</div>
<h3><a id="DirectorySection"></a>5.2. Directories</h3>
<p>Larceny's root directory should contain the following
files:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    larceny
    scheme-script
    larceny.bin
    larceny.heap
    startup.sch</tt></pre>
</div></div>
<p>The following subdirectories are also essential for correct
operation of some features of some modes in some varieties of
Larceny:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    include
    lib
    lib/Base
    lib/Debugger
    lib/Ffi
    lib/MzScheme
    lib/R6RS
    lib/SRFI
    lib/Standard
    lib/TeachPacks</tt></pre>
</div></div>
<p>The <tt>include</tt> subdirectory is used when compiling files with
Petit Larceny.</p>
<p>The <tt>startup.sch</tt> file tells Larceny's <tt>require</tt> procedure to
search some of the <tt>lib</tt> subdirectories for libraries that are
loaded dynamically.</p>
<h3><a id="LibraryResolutionSection"></a>5.3. Resolving references to libraries</h3>
<p>The R7RS and R6RS standards do not specify any mapping from
library names to files or other locations at which the code
for a library might be found.</p>
<p>R6RS non-normative appendix E emphasizes the arbitrariness of
such mappings:</p>
<div class="quoteblock">
<div class="quoteblock-content">
<p>Implementations may take radically different approaches to
storing source code for libraries, among them: files in the
file system where each file contains an arbitrary number of
library forms, files in the file system where each file
contains exactly one library form, records in a database,
and data structures in memory.</p>
<p>Similarly, programs and scripts may be stored in a variety of
formats. Platform constraints may restrict the choices available
to an implementation, which is why the report neither mandates
nor recommends a specific method for storage.</p>
<p>Implementations may provide a means for importing libraries&#8230;.</p>
<p>Similarly, implementations may provide a means for executing a
program represented as a UTF-8 text file containing its source
code&#8230;.</p>
<div class="attribution">
</div></div></div>
<p>To put it more starkly:</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>Although implementations of the R6RS <em>may</em> "provide a means for
importing libraries" or "executing a program", they don't have
to.</p>
</td>
</tr></table>
</div>
<p>R7RS section 5.1 urges implementations to be reasonable:</p>
<div class="quoteblock">
<div class="quoteblock-content">
<p>Implementations which store libraries in files should document
the mapping from the name of a library to its location in the
file system.</p>
<div class="attribution">
</div></div></div>
<p>Fortunately, <em>de facto</em> standards have been emerging.
Larceny supports those <em>de facto</em> standards by providing these
Larceny-specific mechanisms:</p>
<ol>
<li>
<p>
R7RS/R6RS standard libraries may be imported.
Their code is located automagically.
</p>
</li>
<li>
<p>
Nonstandard libraries, such as <tt>(larceny compiler)</tt>,
may be placed in one of the directories searched
by Larceny's
<a href="#R7rsLibraryPathSection">autoload</a> feature, provided
those libraries are located in files that follow Larceny's
standard naming conventions as described in
<a href="#LibraryTranslationSection">the next section</a>.
</p>
</li>
<li>
<p>
R7RS/R6RS top-level programs may use
<a href="#R7rsLibraryPathSection">Larceny's <tt>-path</tt> option</a>
to specify directories that contain other libraries
the program may import, provided those libraries are
located in files that follow Larceny's standard naming
conventions as described in
<a href="#LibraryTranslationSection">the next section</a>.
</p>
</li>
<li>
<p>
R7RS/R6RS top-level programs may use
<a href="#R7rsLibraryVariableSection">Larceny's <tt>LARCENY_LIBPATH</tt> environment variable</a>
to specify directories that contain other libraries
the program may import, provided those libraries are
located in files that follow Larceny's standard naming
conventions as described in
<a href="#LibraryTranslationSection">the next section</a>.
</p>
</li>
<li>
<p>
R7RS/R6RS top-level programs and Scheme scripts may
<a href="#DefiningLibrariesSection">define their own libraries</a>
in the same file that contains the top-level program or
Scheme script.
</p>
</li>
</ol>
<p>R7RS programs may use any of those five mechanisms,
and may also use a sixth mechanism:
An R7RS program can be written as a little configuration
program that loads the program's libraries from files
before any libraries are imported.  This sixth mechanism
appears to be portable, but is not available to
R6RS programs executing in Larceny's R6RS mode because
it mixes execution with macro expansion, which is
explicitly forbidden by one of the R6RS standard's
"absolute requirements".</p>
<h3><a id="LibraryTranslationSection"></a>5.4. Mapping library names to files (R7RS/R6RS)</h3>
<p>Suppose Larceny's <tt>-path</tt> option is used to specify
a certain <em>directory</em>, and the program imports a
nonstandard library whose name is of the form
<tt>(<em>name1</em> <em>name2</em> &#8230; <em>lastname</em>)</tt>.
Larceny will search for that library in the following
files:</p>
<ul>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>/&#8230;/<em>lastname</em>.larceny.slfasl</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>/&#8230;/<em>lastname</em>.larceny.sld</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>/&#8230;/<em>lastname</em>.larceny.sls</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>/&#8230;/<em>lastname</em>.slfasl</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>/&#8230;/<em>lastname</em>.sld</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>/&#8230;/<em>lastname</em>.sls</tt>
</p>
</li>
<li>
<p>
&#8230;
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>.larceny.slfasl</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>.larceny.sld</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>.larceny.sls</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>.slfasl</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>.sld</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>/<em>name2</em>.sls</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>.larceny.slfasl</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>.larceny.sld</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>.larceny.sls</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>.slfasl</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>.sld</tt>
</p>
</li>
<li>
<p>
<tt><em>directory</em>/<em>name1</em>.sls</tt>
</p>
</li>
</ul>
<p>The search starts with the first of those file names,
continues with the following file names in order,
and ends when a file with one of those names is found.
The imported library <em>must</em> be one of the libraries
defined within the first file found by this search,
since the search is not continued after that first file
is found (except as noted in the next paragraph).</p>
<p>If the search ends by finding a file whose name ends
with <tt>.slfasl</tt>, then Larceny checks to see whether
there is a file in the same directory with the same
root name but ending with <tt>.sld</tt> or <tt>.sls</tt> instead of <tt>.slfasl</tt>.
If the <tt>.sld</tt> or <tt>.sls</tt> file has been modified since the <tt>.slfasl</tt>
file was last modified, then a warning is printed and
the <tt>.sld</tt> or <tt>.sls</tt> file is loaded instead of the <tt>.slfasl</tt> file.
Otherwise the <tt>.slfasl</tt> file is loaded.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>The R6RS allows arbitrary mappings from library names to library
code.  Larceny takes advantage of this by ignoring version
numbers when mapping library names to files, and by (virtually)
rewriting any version number that may be specified in the
definition of a library so it matches any version specification
that appears within the <tt>import</tt> form.  Furthermore Larceny
allows different versions of the same library to be imported,
but Larceny's algorithm for resolving library references
ensures that the different versions of a library will be
identical except for their version numbers, which have no
meaningful semantics.  Although Larceny's treatment of versions
conforms to the R6RS specification, it should be clear that
version numbers serve no purpose in Larceny.  Since the R6RS
version feature has no usefully portable semantics and has
been ignored by most implementations of the R6RS, it is
deprecated.</p>
</td>
</tr></table>
</div>
<h3><a id="RequireLibraryTranslationSection"></a>5.5. Mapping library names to files (R5RS)</h3>
<p>In R5RS mode, Larceny's <tt>-path</tt> option
and <tt>LARCENY_LIBPATH</tt> environment variable
may be used to
specify directories to be searched by the <tt>require</tt>
procedure, which takes a single symbol <em>libname</em> as
its argument.
The <tt>require</tt> procedure will search for the following
files in every directory that is part of the current
require path, starting with the directories specified
by LARCENY_LIBPATH and the <tt>-path</tt> option:</p>
<ul>
<li>
<p>
<tt><em>libname</em>.fasl</tt>
</p>
</li>
<li>
<p>
<tt><em>libname</em>.sch</tt>
</p>
</li>
<li>
<p>
<tt><em>libname</em>.scm</tt>
</p>
</li>
</ul>
<p>These files are expected to contain R5RS code, not
library definitions.  Otherwise the search proceeds
much the same as when searching for an R7RS/R6RS
library.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>The <tt>require</tt> path is specified by <tt>startup.sch</tt> in Larceny's
root directory, but may be changed dynamically using the
<tt>current-require-path</tt> parameter.  Changing the <tt>require</tt> path
is not recommended, however, because Larceny relies on the
<tt>require</tt> path for dynamic loading of libraries used by several
important features of Larceny, notably R7RS and R6RS modes.</p>
</td>
</tr></table>
</div>
<p><a id="require"></a>
<em> Procedure require</em>
<p><tt>(require <em>libname</em>) </tt></p></p>
<p><em>libname</em> must be a symbol that names an R5RS-compatible
library within the current require path.</p>
<p>If the library has not already been loaded, then it is
located and loaded.  If the library is found and loaded
successfully, then <tt>require</tt> returns true; otherwise an
error is signalled.</p>
<p>If the library has already been loaded, then <tt>require</tt>
returns false without loading the library a second time.</p>
<p><a id="current-require-path"></a>
<em> Procedure current-require-path</em>
<p><tt>(current-require-path <em></em>)  =&gt; <em>stringlist</em></tt></p>
<p><tt>(current-require-path <em>stringlist</em>) </tt></p></p>
<p>The optional argument is a list of directory names
(without slashes at the end) that should be searched
by <a href="#require"><tt>require</tt></a> and (in R7RS/R6RS modes)
by Larceny's <a href="#ERR5RSLibraryPathSection">autoload</a>
feature.
Returns the list of directory names that will be
searched.</p>
</div>
<h2><a id="CompilingChapter"></a>6. Compiling files and libraries</h2>
<div class="sectionbody">
<p>This chapter explains how you can use Larceny to compile
Scheme source code to native machine code.</p>
<p>The native varieties of Larceny have a just-in-time
compiler that compiles to native code automatically
whenever you evaluate an expression, load a source
file, or import a source library.  Even so, files
will load faster if they are compiled ahead of time.</p>
<p>Petit Larceny does not have a just-in-time compiler,
so compiling ahead of time is the only way to enjoy
the speed of native machine code in Petit Larceny.</p>
<p>The main disadvantage of compiling files and libraries
is that compiled code goes <em>stale</em> when its original
source code is changed or when a library on which
the compiled code depends is changed or recompiled.
Stale compiled code can be dangerously inconsistent
with libraries on which it depends, so Larceny checks
for staleness and refuses to execute a stale library
or program.</p>
<h3><a id="CompilingR7rsSection"></a>6.1. Compiling R7RS/R6RS libraries</h3>
<p>On Unix machines, the most convenient way to compile
a group of R7RS/R6RS libraries and top-level programs
is to use the <tt>compile-stale</tt> script in Larceny's root
directory.
If Larceny's root directory is in your execution path,
then there are just two steps:</p>
<ol>
<li>
<p>
Use <tt>cd</tt> to change to the directory that contains
the R7RS/R6RS files you want to compile.  (Files
that lie within subdirectories of that directory will
be compiled also.)
</p>
</li>
<li>
<p>
Run the <tt>compile-stale</tt> script.
</p>
</li>
</ol>
<p>For example:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    % cd lib/R7RS
    % compile-stale</tt></pre>
</div></div>
<p>On non-Unix machines, you can accomplish the same thing
using Larceny's R7RS mode and the <tt>(larceny compiler)</tt>
library:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    % pushd lib\R7RS
    % ../../larceny -r7rs
    Larceny v0.98 "General Ripper"

    &gt; (import (larceny compiler))

    &gt; (compile-stale-libraries)</tt></pre>
</div></div>
<p>To compile individual files, use the <tt>compile-file</tt> or
<tt>compile-library</tt> procedures that are exported by
<a href="#LarcenyCompilerSection"><tt>(larceny compiler)</tt></a>.</p>
<h3><a id="CompilingR5rsSection"></a>6.2. Compiling R5RS source files</h3>
<p><a id="compile-file"></a>
<em> Procedure compile-file</em>
<p><tt>(compile-file <em>sourcefile</em>) </tt></p></p>
<p>Compiles <em>sourcefile</em>, which must be a string naming
a file that contains R5RS source code.
If <em>faslfile</em> is supplied as a second argument,
then it must be a string naming the file that will
contain the compiled code; otherwise the name of
the compiled file is obtained from <em>sourcefile</em>
by replacing the "<tt>.sch</tt>" or "<tt>.scm</tt>" suffix with
"<tt>.fasl</tt>".</p>
<p>For R7RS/R6RS libraries and top-level programs,
<a href="#CompilingErr5rsSection">see above</a>.</p>
</div>
<h2><a id="R7rsChapter"></a>7. R7RS standard libraries</h2>
<div class="sectionbody">
<p>The R7RS standard libraries are described by
<a href="#Standards">the R7RS (small) standard</a> approved in 2013.</p>
<p>Larceny provides all of the R7RS standard libraries,
supports the full numeric tower, and can represent all
Unicode characters.</p>
<p>Binary releases of Larceny also support Unicode strings.
(When built from source code, Larceny can be configured to
use Latin-1 strings instead of Unicode.)</p>
<p>When Larceny is invoked with the <tt>-r7r6</tt> option on its
command line, all of the standard R7RS and R6RS libraries
are imported at startup.  When invoked with the <tt>-r7rs</tt>
option, only <tt>(scheme base)</tt> is imported at startup.</p>
<h3>7.1. Known deviations from the R7RS standard</h3>
<p>Larceny v0.98 does not implement these features of
the R7RS standard:</p>
<ul>
<li>
<p>
the second (arbitrary ellipsis) form of <tt>syntax-rules</tt>
  described in R7RS section 4.3.2
</p>
</li>
<li>
<p>
<tt>include</tt> and <tt>include-ci</tt> at expression level
</p>
</li>
<li>
<p>
<tt>cond-expand</tt> at expression level
</p>
</li>
</ul>
<p><tt>include</tt>, <tt>include-ci</tt>, and <tt>cond-expand</tt> are fully supported
at the top-level declaration and definition levels of R7RS
libraries.</p>
<p>To simplify interoperability with R6RS libraries and
programs, the <tt>integer?</tt>, <tt>rational?</tt>, and <tt>real?</tt>
procedures exported by <tt>(scheme base)</tt> have R6RS semantics.
It is not clear whether that is fully compatible with the
R7RS (small) standard, because the R7RS specification of
those procedures appears to contradict itself.</p>
<p>If any other R7RS feature is missing or incompatible with
the R7RS (small) standard, it's a bug.</p>
</div>
<h2><a id="R6rsChapter"></a>8. R6RS standard libraries</h2>
<div class="sectionbody">
<p>This chapter explains which features of the R6RS standard
libraries are available in each of Larceny's major modes
of execution.</p>
<p>Larceny was the first substantially complete implementation
of the R6RS.  Any features that are missing from R6RS modes
are missing because of bugs or because the features are
deprecated in Larceny.</p>
<p>Larceny is R6RS-compatible but not R6RS-conforming.
When Larceny is said to support a feature of the R6RS,
that means the feature is present and will behave as
specified by the R6RS so long as no exception is raised
or expected.
Larceny does not always raise the specific conditions
specified by the R6RS, and does not perform all of the
checking for portability problems that is mandated by
the R6RS.  These deviations do not affect the execution
of production code, and do not compromise Larceny's
traditional safety.</p>
<p>For example, Larceny has extended the R6RS <tt>library</tt> syntax to
allow R6RS libraries to import R7RS libraries even when the
names of those imported libraries use the more liberal R7RS
syntax.</p>
<p>Furthermore, Larceny has extended several R6RS procedures so
they behave as specified by the newer R7RS (small) standard.
In Larceny, for example, the <tt>utf8-&gt;string</tt> procedure
accepts one, two, or three arguments,
and the <tt>finite?</tt> procedure accepts any object as its argument.
According to the R6RS, <tt>utf8-&gt;string</tt> <em>must</em> raise an
exception when passed more than one argument, and
<tt>finite?</tt> <em>must</em> raise an exception if it detects an
argument that is not a real number.  Although the R6RS
says these exceptions are "absolute requirements", they
interfere with interoperability between R6RS and R7RS code,
and are best honored in the breach.</p>
<h3><a id="R6rsBaseSection"></a>8.1. Base library</h3>
<p>R7RS and R6RS modes support all procedures and syntaxes
exported by the <tt>(rnrs base)</tt> library.</p>
<p>Larceny's R5RS mode does not support <tt>library</tt>, <tt>import</tt>, or
<tt>identifier-syntax</tt>.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>The semantics of <tt>quasiquote</tt>, <tt>let-syntax</tt>, and <tt>letrec-syntax</tt>
differ between the R5RS, R6RS, and R7RS.  Larceny's R5RS mode
still supports the R5RS semantics.  R7RS and R6RS modes support
the R6RS semantics.</p>
</td>
</tr></table>
</div>
<h3><a id="R6rsUnicodeSection"></a>8.2. Unicode</h3>
<p>All of Larceny's modes support all features of the <tt>(rnrs unicode)</tt>
library.</p>
<p>Larceny v0.98 tries to conform to
<a href="#Standards">The Unicode Standard</a>, Version 7.0.</p>
<h3><a id="R6rsBytevectorsSection"></a>8.3. Bytevectors</h3>
<p>R7RS and R6RS modes support all procedures and syntaxes
exported by <tt>(rnrs bytevectors)</tt>, but the <tt>endianness</tt>
syntax is deprecated because it is redundant with <tt>quote</tt>.
Larceny's R5RS mode does not support <tt>endianness</tt>.</p>
<p>In Larceny, any symbol names a supported endianness.
The symbols <tt>big</tt> and <tt>little</tt> have their expected meanings.
All other symbols mean <tt>(native-endianness)</tt> with respect
to integer operations, but mean the opposite of
<tt>(native-endianness)</tt> with respect to
<a href="#Standards">IEEE-754</a> operations.
For string operations, the endianness must be the symbol
<tt>big</tt> or the symbol <tt>little</tt>.  All of these extensions are
permitted by the R6RS standard.</p>
<p>Larceny's <tt>utf16-&gt;string</tt> and <tt>utf32-&gt;string</tt> accept one,
two, or three arguments.  The R6RS specification of these
procedures does not allow them to accept a single argument,
but that is believed to be an error in the R6RS.</p>
<h3><a id="R6rsListsSection"></a>8.4. Lists</h3>
<p>All of Larceny's modes support all features of the
<tt>(rnrs lists)</tt> library.</p>
<h3><a id="R6rsSortingSection"></a>8.5. Sorting</h3>
<p>All of Larceny's modes support all features of the
<tt>(rnrs sorting)</tt> library.</p>
<h3><a id="R6rsControlSection"></a>8.6. Control</h3>
<p>All of Larceny's modes support all features of the
<tt>(rnrs control)</tt> library.</p>
<h3><a id="R6rsRecordsSection"></a>8.7. Records</h3>
<p>R7RS and R6RS modes support all procedures and syntaxes
exported by
<tt>(rnrs records procedural)</tt>,
<tt>(rnrs records inspection)</tt>, and
<tt>(rnrs records syntactic)</tt>.</p>
<p>Those libraries are deprecated, however;
the <tt>make-record-constructor-descriptor</tt> procedure does
not simplify unusually complex cases enough to justify
the complexity it adds to typical cases, and
the entire syntactic layer is gratuitously incompatible
with the procedural layer.</p>
<p>Larceny extends the R7RS <tt>define-record-type</tt> syntax exported
by <tt>(scheme base)</tt> to accept the deprecated R6RS syntax, and
extends the deprecated <tt>define-record-type</tt> syntax exported
by <tt>(rnrs records syntactic)</tt> to accept R7RS syntax.
Larceny's unification of the two syntaxes within a single
implementation of <tt>define-record-type</tt> allows libraries and
programs to import both <tt>(scheme base)</tt> and <tt>(rnrs)</tt> without
having to rename one version of <tt>define-record-type</tt>.</p>
<p>Larceny also extends its unified R7RS/R6RS <tt>define-record-type</tt>
to support all features of <tt>(srfi :99 records syntactic)</tt>.
So long as the deprecated R6RS syntax is not used, Larceny's
<tt>define-record-type</tt> is fully compatible with the procedural
layers defined by <tt>(srfi :99 records procedural)</tt> and by
<tt>(rnrs records procedural)</tt>.</p>
<p>Larceny's R5RS mode supports all features of the deprecated
<tt>(rnrs records procedural)</tt> and <tt>(rnrs records inspection)</tt>
libraries.  R5RS mode does not support <tt>(rnrs records syntactic)</tt>.</p>
<p>All of Larceny's modes support all features of the
<a href="#Err5rsRecordsProceduralSection"><tt>(err5rs records procedural)</tt></a>
and
<a href="#Err5rsRecordsInspectionSection"><tt>(err5rs records inspection)</tt></a>
libraries.  R7RS and R6RS modes also support the
<a href="#Err5rsRecordsSyntacticSection"><tt>(err5rs records syntactic)</tt></a>
library.
These libraries are equivalent to the
<tt>(srfi :99 records procedural)</tt>,
<tt>(srfi :99 records inspection)</tt>, and
<tt>(srfi :99 records syntactic)</tt> libraries.</p>
<p>The record definition syntax of
<a href="http://srfi.schemers.org/srfi-9/">SRFI 9</a>
is a proper subset
of the syntax provided by the <tt>(err5rs records syntactic)</tt>
library.  In R5RS mode, SRFI 9 can be loaded dynamically
using the
<a href="#require"><tt>require</tt></a> procedure:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    &gt; (require 'srfi-9)</tt></pre>
</div></div>
<p>We recommend the R7RS and/or SRFI 9 libraries be used instead
of the corresponding R6RS libraries.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>The R6RS spouts some tendentious nonsense about procedural
records being slower than syntactic records, but this is not
true of Larceny's records, and is unlikely to be true of other
implementations either.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>Larceny continues to support its old-style
records, which are almost but not quite compatible
with R7RS and R6RS records.  This can be confusing,
since some of Larceny's procedures have the same names
as R6RS procedures.  That has made it necessary to overload
those procedures to work with both old-style and R6RS
records.  We apologize for the mess.</p>
</td>
</tr></table>
</div>
<h3><a id="R6rsConditionsSection"></a>8.8. Exceptions and conditions</h3>
<p>All of Larceny's modes support all features of the
<tt>(rnrs exceptions)</tt> and <tt>(rnrs conditions)</tt> libraries.</p>
<h3><a id="R6rsIoSection"></a>8.9. Input and output</h3>
<p>R7RS and R6RS modes support all names exported by the
<tt>(rnrs io ports)</tt>, <tt>(rnrs io simple)</tt>, and
<tt>(rnrs files)</tt> libraries.</p>
<p>The <tt>buffer-mode</tt>, <tt>eol-style</tt>, and <tt>error-handling-mode</tt>
syntaxes are deprecated because they are redundant
with <tt>quote</tt>.  Larceny may provide these deprecated syntaxes
in the form of procedures rather than syntax, but this
deviation from R6RS semantics cannot be detected by
portable R6RS programs.</p>
<p>Larceny's R5RS mode supports all non-deprecated features
of those libraries.</p>
<p>Larceny supports four distinct buffer modes: <tt>none</tt>,
<tt>line</tt>, <tt>datum</tt>, and <tt>block</tt>.  The R6RS requires
the <tt>buffer-mode</tt> syntax to raise an exception for the
<tt>datum</tt> buffer mode, which is the buffer mode Larceny
uses for interactive output ports.</p>
<p>In Larceny, any symbol names a supported end-of-line
style.  All end-of-line and error-handling-mode symbols
whose meanings are not described by the R6RS have
locale-dependent meanings, which is an extension
permitted by the R6RS standard.</p>
<p>Although Larceny supports the UTF-16 codec, it is not
really useful on Windows machines (where it should be
most useful) because Larceny's low-level file system
mimics a byte-oriented Unix file system even on
Windows.  This problem should be addressed in some
future version of Larceny.</p>
<p>The most up-to-date list of known deviations from R6RS
io semantics can be found on the web page
that describes the current status of
<a href="https://github.com/larcenists/larceny/wiki/DargoMode">Larceny's R6RS-compatible mode</a>.</p>
<h3><a id="R6rsProgramsSection"></a>8.10. Programs</h3>
<p>R7RS and R6RS modes support the <tt>(rnrs programs)</tt> library.</p>
<p>Larceny's R5RS mode provides the <tt>exit</tt> procedure but
not the <tt>command-line</tt> procedure of that library.
Larceny's traditional <tt>command-line-arguments</tt> procedure
can be used to implement an approximation to <tt>command-line</tt>.
For a definition, see <tt>lib/R6RS/rnrs/programs.sls</tt>.</p>
<h3><a id="R6rsArithmeticSection"></a>8.11. Arithmetic</h3>
<p>All of Larceny's modes support all features of the
<tt>(rnrs arithmetic fixnums)</tt>,
<tt>(rnrs arithmetic flonums)</tt>, and
<tt>(rnrs arithmetic bitwise)</tt>
libraries.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>R6RS fixnum and flonum operations may be slower than the
corresponding generic operations, since the fixnum and flonum
operations are required to check their arguments and may also
have to check their results.
Isolated operations in small micro-benchmarks are likely to
be slower than groups of similar operations in larger programs,
however, because Larceny's compiler removes redundant checks
and propagates type information.</p>
</td>
</tr></table>
</div>
<h3><a id="R6rsSyntaxCaseSection"></a>8.12. Syntax-case</h3>
<p>R7RS and R6RS modes support the <tt>(rnrs syntax-case)</tt> library.
Larceny's R5RS mode does not.</p>
<h3><a id="R6rsHashtablesSection"></a>8.13. Hashtables</h3>
<p>All of Larceny's modes support all features of the
<tt>(rnrs hashtables)</tt> library.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>Larceny's traditional <tt>make-hashtable</tt> procedure has been
renamed to <tt>make-oldstyle-hashtable</tt>.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>When you use Larceny's R5RS or R7RS mode to dump a heap image
that contains <tt>eq?</tt> or <tt>eqv?</tt> hashtables you have created, they
are automatically reset so they will
rehash themselves whenever you begin a new session with the
dumped heap.</p>
</td>
</tr></table>
</div>
<h3><a id="R6rsEnumerationsSection"></a>8.14. Enumeration sets</h3>
<p>R7RS and R6RS modes support the <tt>(rnrs enums)</tt> library.
Larceny's R5RS mode provides all of the procedures exported by
<tt>(rnrs enums)</tt> but does not provide the <tt>define-enumeration</tt>
syntax.</p>
<h3><a id="R6rsEvalSection"></a>8.15. Eval</h3>
<p>R7RS and R6RS modes support the <tt>(rnrs eval)</tt> library.
Larceny's R5RS mode provides an R5RS-compatible eval procedure,
not an R6RS-compatible eval procedure, and does not provide the
<tt>environment</tt> procedure.</p>
<h3><a id="R6rsMutableStringsSection"></a>8.16. Mutable pairs and strings</h3>
<p>All of Larceny's modes support all features of the
<tt>(rnrs mutable-pairs)</tt> and <tt>(rnrs mutable-strings)</tt> libraries.</p>
<h3><a id="R6rsR5rsSection"></a>8.17. R5RS</h3>
<p>All of Larceny's modes support all features of the
<tt>(rnrs r5rs)</tt> library.</p>
</div>
<h2><a id="LarcenyErr5rsLibrariesChapter"></a>9. Larceny's R7RS/R6RS libraries</h2>
<div class="sectionbody">
<p>Larceny provides libraries for compiling
R7RS/R6RS libraries and for timing benchmarks.</p>
<h3><a id="LarcenyLoadSection"></a>9.1. Load</h3>
<p>The <tt>(larceny load)</tt> library exports both the
<tt>load</tt> procedure of <tt>(scheme load)</tt>
and Larceny's <tt>r5rs:require</tt> procedure, which is a renaming of
the <a href="#require"><tt>require</tt></a> procedure used by
Larceny's R5RS mode.</p>
<p>In Larceny's R7RS mode,
the <tt>load</tt> procedure can load
R5RS libraries and programs as well as R7RS/R6RS
libraries.</p>
<p>The <tt>r5rs:require</tt> procedure should be used only for dynamic loading of
R5RS libraries into Larceny's underlying R5RS system.  The
variables defined by that library can be imported into
an R7RS session or R7RS/R6RS library or program using a
<a href="#R7rsPrimitivesSection"><tt>primitives</tt></a>
clause in an <tt>import</tt> form.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>These procedures should be used only at an interactive top
level and in files that will be loaded into an interactive top
level.  Calls to these procedures have no effect at compile
time, and should not appear in files that will be compiled
separately; use the <tt>define-library</tt> and <tt>import</tt> syntaxes
instead.</p>
</td>
</tr></table>
</div>
<h3><a id="LarcenyCompilerSection"></a>9.2. Compiler</h3>
<p>The <tt>(larceny compiler)</tt> library exports the
<tt>load</tt> and <tt>r5rs:require</tt> procedures of <tt>(larceny load)</tt>,
the
<a href="#current-require-path"><tt>current-require-path</tt></a>
procedure, the
<a href="#compile-file"><tt>compile-file</tt></a>,
<a href="#compile-library"><tt>compile-library</tt></a>, and
<a href="#compile-stale-libraries"><tt>compile-stale-libraries</tt></a>
procedures described below,
and the
<a href="#compiler-switches"><tt>compiler-switches</tt></a> procedure.</p>
<p>These procedures can be used to compile R7RS/R6RS
libraries and top-level programs before they are imported
or executed.
This is especially important for Petit Larceny, which
would otherwise use an interpreter.  For native Larceny,
whose just-in-time compiler generates native machine code
as source libraries and programs are loaded, imported, or
executed, the main advantage of separate compilation is
that compiled libraries and programs will load much
faster than source libraries and programs.</p>
<p>The main disadvantage of separate compilation is that
compiled libraries and programs go <em>stale</em> when their
source code is changed or when a library on which they
depend is changed or recompiled.  Stale libraries and
programs can be dangerously inconsistent with libraries
on which they depend, so Larceny checks for staleness
and refuses to execute a stale library or program.
The <a href="#compile-stale-libraries"><tt>compile-stale-libraries</tt></a>
procedure provides a convenient way to recompile stale
libraries and programs.</p>
<p><p><tt>(compile-file <em>sourcefile</em>) </tt></p></p>
<p>Compiles <em>sourcefile</em>, which must be a string naming
a file that contains source code for one or more
R7RS/R6RS libraries or a top-level program.
If <em>slfaslfile</em> is supplied as a second argument,
then it must be a string naming the file that will
contain the compiled code; otherwise the name of
the compiled file is obtained from <em>sourcefile</em>
by replacing the "<tt>.sld</tt>" or "<tt>.sls</tt>" suffix with "<tt>.slfasl</tt>".</p>
<p><a id="compile-library"></a>
<em> Procedure compile-library</em>
<p><tt>(compile-library <em>sourcefile</em>) </tt></p></p>
<p>Compiles <em>sourcefile</em>, which must be a string naming
a file that contains source code for one or more
R7RS/R6RS libraries.
Apart from its unwillingness to compile top-level
programs, <tt>compile-library</tt> behaves the same as
<tt>compile-file</tt> above.</p>
<p><a id="compile-stale-libraries"></a>
<em> Procedure compile-stale-libraries</em>
<p><tt>(compile-stale-libraries <em></em>) </tt></p>
<p><tt>(compile-stale-libraries <em>changedfile</em>) </tt></p></p>
<p>If no argument is supplied, then all "<tt>.sld</tt>" and "<tt>.sls</tt>" files that
lie within the current directory or a subdirectory are
recompiled.</p>
<p>If <em>changedfile</em> is supplied, then it must be a string
giving the absolute pathname of a file.
(In typical usage, <em>changedfile</em> is a source file that
has been modified, making it necessary to recompile all
files that depend upon it.)
Compiles all R7RS/R6RS library files that lie within
the same directory as <em>changedfile</em> or a subdirectory,
and have not yet been compiled or whose compiled files
are older than <em>changedfile</em>.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>In future versions of Larceny, <tt>compile-stale-libraries</tt>
might compile only the source files that depend upon
<em>changedfile</em>.</p>
</td>
</tr></table>
</div>
<p><a id="compiler-switches"></a>
<em> Procedure compiler-switches</em>
<p><tt>(compiler-switches <em></em>) </tt></p>
<p><tt>(compiler-switches <em>mode</em>) </tt></p></p>
<p>If no argument is supplied, then the current settings
of all compiler switches are displayed.  Each of those
switches is itself a parameter that is exported by the
<tt>(larceny compiler)</tt> library.  Calling any individual
compiler switch with no arguments will return its current
setting.  Calling any individual compiler switch with an
argument (usually a boolean) will change its setting to
that argument.</p>
<p>The <tt>compiler-switches</tt> procedure may also be called with
one of the following symbols as its argument:</p>
<p><tt>default</tt>
sets most compiler switches to their default settings.</p>
<p><tt>fast-safe</tt>
enables all optimizations but continues to generate
code to perform all run-time type and range checks that
are needed for safety
(in the traditional sense, not the R6RS sense).</p>
<p><tt>fast-unsafe</tt>
enables all optimizations and also disables type and
range checking.  This setting is deprecated because it
compromises safety (in the traditional sense).</p>
<p><tt>slow</tt>
turns off all optimizations.</p>
<p><tt>standard</tt>
sets compiler switches for maximal conformance to the
R5RS and R6RS standards.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>The <tt>standard</tt> setting is deprecated because it generates
very slow code (because the R5RS makes it difficult to
inline standard procedures), disables most compile-time
checking (because the R6RS forbids rejection of programs
with obvious errors unless the R6RS classifies the errors
as syntactic), and may also compromise the portability or
interoperability of R7RS/R6RS libraries and programs
(because the R6RS outlaws several extensions that Larceny
uses to improve its compatibility with other implementations
of the R5RS, R6RS, and R7RS as well as interoperability between
Larceny's own R5RS and R7RS/R6RS modes).</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<p>Selective toggling of compiler switches is almost always
better than using the <tt>standard</tt> setting.
To improve R5RS conformance without sacrificing too much
performance, set the <tt>benchmark-mode</tt> switch to false and
set the <tt>integrate-procedures</tt> switch to false only when
compiling files that need to be sensitive to redefinitions
of standard procedures.
For R6RS libraries and programs, setting the <tt>benchmark-mode</tt>
and <tt>global-optimization</tt> switches to false will eliminate a
couple of minor conformance issues with only a small loss
of performance and without sacrificing compile-time checking
or portability.
For R7RS libraries and programs, the compiler's default settings
already conform to the R7RS.</p>
</td>
</tr></table>
</div>
<h3><a id="LarcenyBenchmarkingSection"></a>9.3. Benchmarking</h3>
<p>The <tt>(larceny benchmarking)</tt> library exports the
<tt>time</tt> syntax and <tt>run-benchmark</tt> procedure described
below.</p>
<p><em>Syntax time</em></p>
<p><tt>(time expression)</tt></p>
<p>Evaluates <em>expression</em> and returns its result
after printing approximations to the storage
allocated and time taken during evaluation of
<em>expression</em>.</p>
<div class="listingblock">
<div class="content">
<pre><tt>    &gt; (time (fib 30))
    Words allocated: 0
    Words reclaimed: 0
    Elapsed time...: 49 ms (User: 48 ms; System: 0 ms)
    Elapsed GC time: 0 ms (CPU: 0 in 0 collections.)
    832040</tt></pre>
</div></div>
<p><p><tt>(run-benchmark <em>name iterations thunk predicate</em>) </tt></p></p>
<p>Given the <em>name</em> of a benchmark, the number of
<em>iterations</em> to be performed, a zero-argument
procedure <em>thunk</em> that runs the benchmark,
and a unary <em>predicate</em> that checks the result
of <em>thunk</em>, prints approximations to the storage
allocated and time taken by <em>iterations</em> calls
to <em>thunk</em>.</p>
<div class="listingblock">
<div class="content">
<pre><tt>    &gt; (run-benchmark "fib30"
                     100
                     (lambda () (fib 30))
                     (lambda (x) (= x 832040)))

    --------------------------------------------------------
    fib30
    Words allocated: 0
    Words reclaimed: 0
    Elapsed time...: 4828 ms (User: 4824 ms; System: 4 ms)
    Elapsed GC time: 0 ms (CPU: 0 in 0 collections.)</tt></pre>
</div></div>
<h3><a id="RecordsPrinterSection"></a>9.4. Records printer</h3>
<p>The <tt>(larceny records printer)</tt> library exports the
two procedures described below.  These procedures
can be used to override Larceny's usual printing
of records and opaque types that were defined using
the records libraries.</p>
<p><a id="rtd-printer"></a>
<em> Procedure rtd-printer</em>
<p><tt>(rtd-printer <em>rtd</em>)  =&gt; <em>maybe-procedure</em></tt></p></p>
<p>Given a record type descriptor, returns its custom
print procedure, or returns false if the rtd has no
custom print procedure.</p>
<p><a id="rtd-printer-set!"></a>
<em> Procedure rtd-printer-set!</em>
<p><tt>(rtd-printer-set! <em>rtd printer</em>) </tt></p></p>
<p>Given a record type descriptor <em>rtd</em> and a
<em>printer</em> for instances of that rtd, installs
<em>printer</em> as a custom print procedure for <em>rtd</em>.
The <em>printer</em> should be a procedure that,
given an instance of the rtd and a textual
output port, writes a representation of the
instance to the port.</p>
</div>
<h2><a id="Err5rsChapter"></a>10. ERR5RS standard libraries</h2>
<div class="sectionbody">
<p><a href="#Standards">ERR5RS</a> has been superseded by the R7RS, so the
libraries described below are now deprecated.</p>
<h3><a id="Err5rsLoadSection"></a>10.1. Load</h3>
<p>The <tt>(err5rs load)</tt> library has been superseded by the
<tt>(scheme load)</tt> library, and continues to exist only for
backward compatibility.</p>
<p><a id="load"></a>
<em> Procedure load</em>
<p><tt>(load <em>filename</em>) </tt></p></p>
<p>Loads ERR5RS code from <em>filename</em>, evaluating each form
as though it had been entered at the interactive
read/eval/print loop.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>The <tt>load</tt> procedure should be used only at an interactive top
level and in files that will be loaded into an interactive top
level.  Calls to the <tt>load</tt> procedure have no effect at compile
time, and should not appear in files that will be compiled
separately; use the <tt>library</tt> and <tt>import</tt> syntaxes instead.</p>
</td>
</tr></table>
</div>
<h3><a id="Err5rsRecordsSection"></a>10.2. Records</h3>
<p>The ERR5RS record facility described below incorporates all
optional features of SRFI 99 and is otherwise identical to
the facilities described by SRFI 99.
SRFI 99 is itself an extension of SRFI 9, whose
<tt>define-record-type</tt> syntax is identical to that defined by
the R7RS.</p>
<p>When a procedure is said to be equivalent to an R6RS
procedure, the equivalence holds only when all arguments
have the properties required of them by the R6RS
specification.  ERR5RS does not mandate R6RS exception
semantics for programs that violate the specification.</p>
<h4><a id="Err5rsRecordsProceduralSection"></a>10.2.1. Procedural layer</h4>
<p>This section describes the <tt>(err5rs records procedural)</tt> library.</p>
<p><a id="make-rtd"></a>
<em> Procedure make-rtd</em>
<p><tt>(make-rtd <em>name fieldspecs</em>) </tt></p>
<p><tt>(make-rtd <em>name fieldspecs parent-rtd</em>) </tt></p>
<p><tt>(make-rtd <em>name fieldspecs parent-rtd option &#8230;</em>) </tt></p></p>
<p><em>name</em> is a symbol, which matters only to the
<a href="#rtd-name"><tt>rtd-name</tt></a> procedure of the inspection layer.
<em>fieldspecs</em> is a vector of field specifiers, where
each field specifier is one of</p>
<ul>
<li>
<p>
a symbol naming the (mutable) field;
</p>
</li>
<li>
<p>
a list of the form <tt>(mutable <em>name</em>)</tt>,
where <em>name</em> is a symbol naming the mutable field;
</p>
</li>
<li>
<p>
a list of the form <tt>(immutable <em>name</em>)</tt>,
where <em>name</em> is a symbol naming the immutable field.
</p>
</li>
</ul>
<p>The optional parent is an rtd or <tt>#f</tt>. It is an error for
any of the symbols in fieldspecs to name more than one
of the fields specified by fieldspecs, but the field names
in fieldspecs may shadow field names in the parent rtd.</p>
<p><a href="#make-rtd"><tt>make-rtd</tt></a> returns an R6RS-compatible record-type
descriptor.</p>
<p>Larceny allows the following optional arguments to follow
the optional <em>parent-rtd</em> argument:</p>
<ul>
<li>
<p>
the symbol <tt>sealed</tt> means the new rtd cannot be used
as the parent of other rtds;
</p>
</li>
<li>
<p>
the symbol <tt>opaque</tt> means the <a href="#record?"><tt>record?</tt></a> predicate
will not recognize instances of the new rtd;
</p>
</li>
<li>
<p>
the symbol <tt>uid</tt>, followed by another symbol <em>id</em>,
means the new rtd is non-generative with uid <em>id</em>; the
semantics of this extension is the same as in the R6RS.
</p>
</li>
</ul>
<p>These Larceny-specific options may be used in any
combination, giving Larceny's ERR5RS records the same
expressive power as R6RS records, with which they are
fully interoperable.</p>
<p><a id="rtd?"></a>
<em> Procedure rtd?</em>
<p><tt>(rtd? <em>obj</em>) </tt></p></p>
<p>This predicate returns true if and only if its argument
is a record-type descriptor.
<tt>rtd?</tt> is equivalent to the <tt>record-type-descriptor?</tt>
procedure of the R6RS.</p>
<p><a id="rtd-constructor"></a>
<em> Procedure rtd-constructor</em>
<p><tt>(rtd-constructor <em>rtd</em>) </tt></p>
<p><tt>(rtd-constructor <em>rtd fieldspecs</em>) </tt></p></p>
<p><em>rtd</em> is a record-type descriptor, and <em>fieldspecs</em> is
an optional vector of symbols.</p>
<p>If no <em>fieldspecs</em> argument is supplied,
then <tt>rtd-constructor</tt> returns a procedure that expects
one argument for each field of the record-type described
by <em>rtd</em> and returns an instance of that record-type
with its fields initialized to the corresponding
arguments.
Arguments that correspond to the fields of the
record-type's parent (if any) come first.</p>
<p>If <em>fieldspecs</em> is supplied, then <tt>rtd-constructor</tt>
returns a procedure that expects one argument for each
element of <em>fieldspecs</em> and returns an instance of the
record-type described by <em>rtd</em> with the named fields
initialized to the corresponding arguments.</p>
<p>It is an error if some symbol occurs more than once in
<em>fieldspecs</em>.  Fields of a derived record-type shadow
fields of the same name in its parent; the <em>fieldspecs</em>
argument cannot be used to initialize a shadowed field.</p>
<p><a id="rtd-predicate"></a>
<em> Procedure rtd-predicate</em>
<p><tt>(rtd-predicate <em>rtd</em>) </tt></p></p>
<p>Equivalent to the <tt>record-predicate</tt> procedure of the R6RS.</p>
<p><a id="rtd-accessor"></a>
<em> Procedure rtd-accessor</em>
<p><tt>(rtd-accessor <em>rtd field</em>) </tt></p></p>
<p><em>field</em> is a symbol that names a field of the
record-type described by the record-type descriptor <em>rtd</em>.
Returns a unary procedure that accepts instances of <em>rtd</em>
(or any record-type that inherits from <em>rtd</em>) and
returns the current value of the named field.</p>
<p>Fields in derived record-types shadow fields of the same
name in a parent record-type.</p>
<p><a id="rtd-mutator"></a>
<em> Procedure rtd-mutator</em>
<p><tt>(rtd-mutator <em>rtd field</em>) </tt></p></p>
<p><em>field</em> is a symbol that names a field of the
record-type described by the record-type descriptor <em>rtd</em>.
Returns a binary procedure that accepts instances of <em>rtd</em>
(or any record-type that inherits from <em>rtd</em>) and a new
value to be stored into the named field, performs that
side effect, and returns an unspecified value.</p>
<p>Fields in derived record-types shadow fields of the same
name in a parent record-type.</p>
<h4><a id="Err5rsRecordsInspectionSection"></a>10.2.2. Inspection layer</h4>
<p>This section describes the <tt>(err5rs records inspection)</tt> library.</p>
<p><a id="record?"></a>
<em> Procedure record?</em>
<p><tt>(record? <em>obj</em>) </tt></p></p>
<p>Equivalent to its R6RS namesake.</p>
<p><a id="record-rtd"></a>
<em> Procedure record-rtd</em>
<p><tt>(record-rtd <em>record</em>) </tt></p></p>
<p>Equivalent to its R6RS namesake.</p>
<p><a id="rtd-name"></a>
<em> Procedure rtd-name</em>
<p><tt>(rtd-name <em>rtd</em>) </tt></p></p>
<p>Equivalent to the <tt>record-type-name</tt> procedure of the R6RS.</p>
<p><a id="rtd-parent"></a>
<em> Procedure rtd-parent</em>
<p><tt>(rtd-parent <em>rtd</em>) </tt></p></p>
<p>Equivalent to the <tt>record-type-parent</tt> procedure of the R6RS.</p>
<p><a id="rtd-field-names"></a>
<em> Procedure rtd-field-names</em>
<p><tt>(rtd-field-names <em>rtd</em>) </tt></p></p>
<p>Equivalent to the <tt>record-type-field-names</tt> procedure of the R6RS.
(That is, it returns a vector of the symbols that name the fields
of the record-type represented by <em>rtd</em>, excluding the fields of
parent record-types.)</p>
<p><a id="rtd-all-field-names"></a>
<em> Procedure rtd-all-field-names</em>
<p><tt>(rtd-all-field-names <em>rtd</em>) </tt></p></p>
<p>Returns a vector of the symbols that name the fields of
the record-type represented by <em>rtd</em>, including the fields
of its parent record-types, if any, with the fields of
parent record-types coming before the fields of its children,
with each subsequence in the same order as in the vectors
that would be returned by calling <a href="#rtd-field-names"><tt>rtd-field-names</tt></a>
on <em>rtd</em> and on all its ancestral record-type descriptors.</p>
<p><a id="rtd-field-mutable?"></a>
<em> Procedure rtd-field-mutable?</em>
<p><tt>(rtd-field-mutable? <em>rtd field</em>) </tt></p></p>
<p><em>rtd</em> is a record-type descriptor, and <em>field</em> is a
symbol naming a field of the record-type described by <em>rtd</em>.
Returns <tt>#t</tt> if the named field is mutable; otherwise returns <tt>#f</tt>.</p>
<h4><a id="Err5rsRecordsSyntacticSection"></a>10.2.3. Syntactic layer</h4>
<p>This section describes the <tt>(err5rs records syntactic)</tt> library.</p>
<p>The syntactic layer consists of
<a href="http://srfi.schemers.org/srfi-9/">SRFI 9</a>
extended with single inheritance and (optional) implicit naming.</p>
<p>All ERR5RS record-type definitions are generative (unless
Larceny's optional <tt>uid</tt> feature is used), but
ERR5RS drops the SRFI 9 restriction to top level, mainly
because the R6RS allows generative definitions wherever
a definition may appear.</p>
<p>The syntax of an ERR5RS record-type definition is</p>
<div class="listingblock">
<div class="content">
<pre><tt>    &lt;definition&gt;
      -&gt; &lt;record type definition&gt;           ; addition to 7.1.6 in R5RS

    &lt;record type definition&gt;
      -&gt; (define-record-type &lt;type spec&gt;
           &lt;constructor spec&gt;
           &lt;predicate spec&gt;
           &lt;field spec&gt; ...)

    &lt;type spec&gt;  -&gt; &lt;type name&gt;
                 -&gt; (&lt;type name&gt; &lt;parent&gt;)

    &lt;constructor spec&gt;
                 -&gt; #f
                 -&gt; #t
                 -&gt; &lt;constructor name&gt;
                 -&gt; (&lt;constructor name&gt; &lt;field name&gt; ...)

    &lt;predicate spec&gt;
                 -&gt; #f
                 -&gt; #t
                 -&gt; &lt;predicate name&gt;

    &lt;field spec&gt; -&gt; &lt;field name&gt;
                 -&gt; (&lt;field name&gt;)
                 -&gt; (&lt;field name&gt; &lt;accessor name&gt;)
                 -&gt; (&lt;field name&gt; &lt;accessor name&gt; &lt;mutator name&gt;)

    &lt;parent&gt;           -&gt; &lt;expression&gt;

    &lt;type name&gt;        -&gt; &lt;identifier&gt;
    &lt;constructor name&gt; -&gt; &lt;identifier&gt;
    &lt;predicate name&gt;   -&gt; &lt;identifier&gt;
    &lt;accessor name&gt;    -&gt; &lt;identifier&gt;
    &lt;mutator name&gt;     -&gt; &lt;identifier&gt;
    &lt;field name&gt;       -&gt; &lt;identifier&gt;</tt></pre>
</div></div>
<p>The semantics of a record type definition is the same
as in SRFI 9: the record type definition macro-expands
into a cluster of definitions that</p>
<ul>
<li>
<p>
defines the <tt>&lt;type name&gt;</tt> as the record-type descriptor
for the new record-type;
</p>
</li>
<li>
<p>
defines a constructor for instances of the new
record-type (unless the constructor spec is <tt>#f</tt>);
</p>
</li>
<li>
<p>
defines a predicate that recognizes instances of the
new record-type and its subtypes (unless the predicate spec is <tt>#f</tt>);
</p>
</li>
<li>
<p>
defines an accessor for each field name;
</p>
</li>
<li>
<p>
defines a mutator for each mutable field name.
</p>
</li>
</ul>
<p>An ERR5RS record type definition extends SRFI 9 with the
following additional options:</p>
<ul>
<li>
<p>
If a <tt>&lt;parent&gt;</tt> expression is specified, then it must
evaluate to an rtd that serves as the parent record-type
for the record-type being defined.
</p>
</li>
<li>
<p>
If <tt>#f</tt> is specified for the constructor or predicate,
then no constructor or predicate procedure is defined.
(This is useful when the record-type being defined will
be used as an abstract base class.)
</p>
</li>
<li>
<p>
If <tt>#t</tt> is specified for the constructor or predicate,
then the name of the constructor is the type name prefixed
by <tt>make-</tt>, and the name of the predicate is the type name
followed by a question mark (<tt>?</tt>).
</p>
</li>
<li>
<p>
If the constructor name is specified as <tt>#t</tt> or as an
identifier, then the constructor's arguments correspond
to the fields of the parent (if any) followed by the new
fields added by this record-type definition.
</p>
</li>
<li>
<p>
If a field spec consists of a single identifier, then
</p>
<ul>
<li>
<p>
the field is immutable;
</p>
</li>
<li>
<p>
the name of its accessor is the type name followed by
a hyphen (<tt>-</tt>) followed by the field name.
</p>
</li>
</ul>
</li>
<li>
<p>
If a field spec consists of a list of one identifier, then
</p>
<ul>
<li>
<p>
the field is mutable;
</p>
</li>
<li>
<p>
the name of its accessor is the type name followed
by a hyphen (<tt>-</tt>) followed by the field name;
</p>
</li>
<li>
<p>
the name of its mutator is the type name followed by
a hyphen (<tt>-</tt>) followed by the field name followed by <tt>-set!</tt>.
</p>
</li>
</ul>
</li>
</ul>
<h4><a id="RecordIdentitySection"></a>10.2.4. Record identity</h4>
<p>Two ERR5RS records with fields are <tt>eqv?</tt> if and only if
they were created by the same (dynamic) call to some
record constructor.
Two ERR5RS records are <tt>eq?</tt> if and only if they are <tt>eqv?</tt>.</p>
<p>Apart from the usual constraint that equivalence according
to <tt>eqv?</tt> implies equivalence according to <tt>equal?</tt>, the
behavior of <tt>equal?</tt> on ERR5RS records is unspecified.
(This is compatible with the R6RS.)</p>
<p>A <tt>define-record-type</tt> form macro-expands into code that
calls <a href="#make-rtd"><tt>make-rtd</tt></a> each time the expanded record-type
definition is executed.
Two ERR5RS record-type descriptors are <tt>eqv?</tt> if and only if
they were created by the same (dynamic) call to
<a href="#make-rtd"><tt>make-rtd</tt></a>.</p>
</div>
<h2><a id="LarcenyR5rsLibrariesChapter"></a>11. Larceny's R5RS libraries</h2>
<div class="sectionbody">
<p>The procedures described in this chapter are nonstandard.
Some are deprecated after being rendered obsolete by R7RS
or R6RS standard libraries.
Others still provide useful capabilities that the standard
libraries don't.</p>
<h3>11.1. Strings</h3>
<p>Larceny provides Unicode strings with
<a href="http://www.r6rs.org/">R6RS</a>
semantics.</p>
<p>The <tt>string-downcase</tt> and <tt>string-upcase</tt> procedures
perform Unicode-compatible case folding, which can result
in a string whose length is different from that of the original.</p>
<p>Larceny may still provide <tt>string-downcase!</tt> and <tt>string-upcase!</tt>
procedures, but they are deprecated.</p>
<h3>11.2. Bytevectors</h3>
<p>A <em>bytevector</em> is a data structure that stores bytes &#8212; exact
8-bit unsigned integers. Bytevectors are useful in constructing
system interfaces and other low-level programming. In Larceny,
many bytevector-like structures &#8212; bignums, for example &#8212;
are implemented in terms of a
lower-level <em>bytevector-like</em> data type. The operations on
generic bytevector-like structures are particularly fast but
useful largely in code that manipulates Larceny's data
representations.</p>
<p>The <a href="#BytevectorsLibrary"><tt>(rnrs bytevectors)</tt> library</a> now
provides a large set of procedures that, in Larceny, are
defined using the procedures described below.</p>
<p><a id="make-bytevector"></a>
<em> Integrable procedure make-bytevector</em>
<p><tt>(make-bytevector <em>length</em>)  =&gt; <em>bytevector</em></tt></p>
<p><tt>(make-bytevector <em>length fill</em>)  =&gt; <em>bytevector</em></tt></p></p>
<p>Returns a bytevector of the desired length.
If no second argument is given, then the bytevector has not
been initialized and most likely contains garbage.</p>
<p><em>Operations on bytevector structures</em></p>
<p><p><tt>(bytevector? <em>obj</em>)  =&gt; <em>boolean</em></tt></p></p>
<p><p><tt>(bytevector-length <em>bytevector</em>)  =&gt; <em>integer</em></tt></p></p>
<p><p><tt>(bytevector-ref <em>bytevector offset</em>)  =&gt; <em>byte</em></tt></p></p>
<p><p><tt>(bytevector-set! <em>bytevector offset byte</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p><p><tt>(bytevector-equal? <em>bytevector1 bytevector2</em>)  =&gt; <em>boolean</em></tt></p></p>
<p><p><tt>(bytevector-fill! <em>bytevector byte</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p><p><tt>(bytevector-copy <em>bytevector</em>)  =&gt; <em>bytevector</em></tt></p></p>
<p>These procedures do what you expect.
All are integrable, except <tt>bytevector-equal?</tt> and <tt>bytevector-copy</tt>.
The <tt>bytevector-equal?</tt> name is deprecated, since the
R6RS calls it <tt>bytevector=?</tt>.</p>
<p><em>Operations on bytevector-like structures</em></p>
<p><p><tt>(bytevector-like? <em>obj</em>)  =&gt; <em>boolean</em></tt></p></p>
<p><p><tt>(bytevector-like-length <em>bytevector</em>)  =&gt; <em>integer</em></tt></p></p>
<p><p><tt>(bytevector-like-ref <em>bytevector offset</em>)  =&gt; <em>byte</em></tt></p></p>
<p><p><tt>(bytevector-like-set! <em>bytevector offset byte</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p><p><tt>(bytevector-like-equal? <em>bytevector1 bytevector2</em>)  =&gt; <em>boolean</em></tt></p></p>
<p><p><tt>(bytevector-like-copy <em>bytevector</em>)  =&gt; <em>bytevector</em></tt></p></p>
<p>A bytevector-like structure is a low-level representation
for indexed arrays of uninterpreted bytes.  Bytevector-like
structures are used to represent types such as bignums and
flonums.</p>
<p>There is no way to construct a "generic" bytevector-like
structure; use the constructors for specific bytevector-like
types.</p>
<p>The bytevector-like operations operate on all bytevector-like
structures.  All are integrable, except <tt>bytevector-like-equal?</tt>
and <tt>bytevector-like-copy</tt>.  All are deprecated because they
violate abstraction barriers and make your code
representation-dependent; they are useful mainly to
Larceny developers, who might otherwise be tempted to
write some low-level operations in C or assembly language.</p>
<h3>11.3. Vectors</h3>
<p><a id="vector-copy"></a>
<em> Procedure vector-copy</em>
<p><tt>(vector-copy <em>vector</em>)  =&gt; <em>vector</em></tt></p></p>
<p>Returns a shallow copy of its argument.</p>
<p><em>Operations on vector-like structures</em></p>
<p><p><tt>(vector-like? <em>object</em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(vector-like-length <em>vector-like</em>)  =&gt; <em>fixnum</em></tt></p>
<p><tt>(vector-like-ref <em>vector-like k</em>)  =&gt; <em>object</em></tt></p>
<p><tt>(vector-like-set! <em>vector-like k object</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>A vector-like structure is a low-level representation
for indexed arrays of Scheme objects.  Vector-like
structures are used to represent types such as vectors,
records, symbols, and ports.</p>
<p>There is no way to construct a "generic" vector-like structure;
use the constructors for specific data types.</p>
<p>The vector-like operations operate on all vector-like structures.
All are integrable.
All are deprecated because they
violate abstraction barriers and make your code
representation-dependent; they are useful mainly to
Larceny developers, who might otherwise be tempted to
write some low-level operations in C or assembly language.</p>
<h3>11.4. Procedures</h3>
<p><em>Operations on procedures</em></p>
<p><p><tt>(make-procedure <em>length</em>)  =&gt; <em>procedure</em></tt></p>
<p><tt>(procedure-length <em>procedure</em>)  =&gt; <em>fixnum</em></tt></p>
<p><tt>(procedure-ref <em>procedure offset</em>)  =&gt; <em>object</em></tt></p>
<p><tt>(procedure-set! <em>procedure offset object</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>These procedures operate on the representations of procedures and
allow user programs to construct, inspect, and alter procedures.</p>
<p><a id="procedure-copy"></a>
<em> Procedure procedure-copy</em>
<p><tt>(procedure-copy <em>procedure</em>)  =&gt; <em>procedure</em></tt></p></p>
<p>Returns a shallow copy of the procedure.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>The procedures above are deprecated because they
violate abstraction barriers and make your code
representation-dependent; they are useful mainly to
Larceny developers, who might otherwise be tempted to
write some low-level operations in C or assembly language.</p>
</td>
</tr></table>
</div>
<p>The rest of this section describes some procedures that
reach through abstraction barriers in a more controlled way
to extract heuristic information from procedures for debugging
purposes.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>The following
text is copied from a straw proposal authored by Will Clinger and sent
to rrr-authors on 09 May 1996. The text has been edited lightly. See
the end for notes about the Larceny implementation.</p>
</td>
</tr></table>
</div>
<p>The procedures that extract heuristic information from procedures are
permitted to return any result whatsoever. If the type of a result is
not among those listed below, then the result represents an
implementation-dependent extension to this interface, which may safely
be interpreted as though no information were available from the
procedure. Otherwise the result is to be interpreted as described
below.</p>
<p><a id="procedure-arity"></a>
<em> Procedure procedure-arity</em>
<p><tt>(procedure-arity <em>proc</em>) </tt></p></p>
<p>Returns information about the arity of <em>proc</em>. If the result is <tt>#f</tt>,
then no information is available. If the result is an exact
non-negative integer <em>k</em>, then <em>proc</em> requires exactly <em>k</em>
arguments. If the result is an inexact non-negative integer <em>n</em>, then
<em>proc</em> requires <em>n</em> or more arguments. If the result is a pair, then
it is a list of non-negative integers, each of which indicates a
number of arguments that will be accepted by <em>proc</em>; the list is not
necessarily exhaustive.</p>
<p><a id="procedure-documentation-string"></a>
<em> Procedure procedure-documentation-string</em>
<p><tt>(procedure-documentation-string <em>proc</em>) </tt></p></p>
<p>Returns general information about <em>proc</em>. If the result is <tt>#f</tt>, then no
information is available. If the result is a string, then it is to be
interpreted as a "documentation string" (see Common Lisp).</p>
<p><a id="procedure-name"></a>
<em> Procedure procedure-name</em>
<p><tt>(procedure-name <em>proc</em>) </tt></p></p>
<p>Returns information about the name of <em>proc</em>. If the result is <tt>#f</tt>,
then no information is available. If the result is a symbol or string,
then it represents a name. If the result is a pair, then it is a list
of symbols and/or strings representing a path of names; the first
element represents an outer name and the last element represents an
inner name.</p>
<p><a id="procedure-source-file"></a>
<em> Procedure procedure-source-file</em>
<p><tt>(procedure-source-file <em>proc</em>) </tt></p></p>
<p>Returns information about the name of a file that contains the source
code for <em>proc</em>. If the result is <tt>#f</tt>, then no information is
available. If the result is a string, then the string is the name of a
file.</p>
<p><a id="procedure-source-position"></a>
<em> Procedure procedure-source-position</em>
<p><tt>(procedure-source-position <em>proc</em>) </tt></p></p>
<p>Returns information about the position of the source code for <em>proc</em>
whithin the source file specified by procedure-source-file. If the
result is <tt>#f</tt>, then no information is available. If the result is an
exact integer <em>k</em>, then <em>k</em> characters precede the opening parenthesis
of the source code for <em>proc</em> within that source file.</p>
<p><a id="procedure-expression"></a>
<em> Procedure procedure-expression</em>
<p><tt>(procedure-expression <em>proc</em>) </tt></p></p>
<p>Returns information about the source code for <em>proc</em>. If the result is
<tt>#f</tt>, then no information is available. If the result is a pair, then it
is a lambda expression in the traditional representation of a list.</p>
<p><a id="procedure-environment"></a>
<em> Procedure procedure-environment</em>
<p><tt>(procedure-environment <em>proc</em>) </tt></p></p>
<p>Returns information about the environment of <em>proc</em>. If the result is
<tt>#f</tt>, then no information is available. In any case the result may be
passed to any of the <a href="#SectionEnvironments">environment inquiry functions</a>.</p>
<p><strong>Notes on the Larceny implementation</strong></p>
<p>Twobit does not yet produce data for all of these functions, so some
of them always return <tt>#f</tt>.</p>
<h3>11.5. Pairs and Lists</h3>
<p>The <tt>(rnrs lists)</tt> library now
provides a set of procedures that may supersede some
of the procedures described below.
If one of Larceny's procedures duplicates the semantics of
an R6RS procedure whose name is different, then Larceny's
name is deprecated.</p>
<p><a id="append!"></a>
<em> Procedure append!</em>
<p><tt>(append! <em>list1 list2 &#8230; obj</em>)  =&gt; <em>object</em></tt></p></p>
<p><tt>append!</tt> destructively appends its arguments, which must be lists, and
returns the resulting list. The last argument can be any object. The
argument lists are appended by changing the cdr of the last pair of
each argument except the last to point to the next argument.</p>
<p><a id="every?"></a>
<em> Procedure every?</em>
<p><tt>(every? <em>procedure list1 list2 &#8230;</em>)  =&gt; <em>object</em></tt></p></p>
<p><tt>every?</tt> applies <em>procedure</em> to each element tuple of <em>list_s in
first-to-last order, and returns <tt>#f</tt> as soon as _procedure</em> returns
<tt>#f</tt>. If <em>procedure</em> does not return <tt>#f</tt> for any element tuple of
<em>list_s, then the value returned by _procedure</em> for the last element
tuple of _list_s is returned.</p>
<p><a id="last-pair"></a>
<em> Procedure last-pair</em>
<p><tt>(last-pair <em>list-structure</em>)  =&gt; <em>pair</em></tt></p></p>
<p><tt>last-pair</tt> returns the last pair of the <em>list structure</em>, which must be
a sequence of pairs linked through the cdr fields.</p>
<p><a id="list-copy"></a>
<em> Procedure list-copy</em>
<p><tt>(list-copy <em>list-copy</em>)  =&gt; <em>list</em></tt></p></p>
<p><tt>list-copy</tt> makes a shallow copy of the <em>list</em> and returns that copy.</p>
<p><a id="remove"></a>
<em> Procedure remove</em>
<p><tt>(remove <em>key list</em>)  =&gt; <em>list</em></tt></p>
<a id="remq"></a>
<em> Procedure remq</em>
<p><tt>(remq <em>key list</em>)  =&gt; <em>list</em></tt></p>
<a id="remv"></a>
<em> Procedure remv</em>
<p><tt>(remv <em>key list</em>)  =&gt; <em>list</em></tt></p>
<a id="remp"></a>
<em> Procedure remp</em>
<p><tt>(remp <em>pred? list</em>)  =&gt; <em>list</em></tt></p></p>
<p>Each of these procedures returns a new list which contains all the
elements of <em>list</em> in the original order, except that those elements of
the original list that were equal to <em>key</em> (or that satisfy <em>pred?</em>) are
not in the new list. Remove uses <tt>equal?</tt> as the equivalence predicate;
<tt>remq</tt> uses <tt>eq?</tt>, and <tt>remv</tt> uses <tt>eqv?</tt>.</p>
<p><a id="remove!"></a>
<em> Procedure remove!</em>
<p><tt>(remove! <em>key list</em>)  =&gt; <em>list</em></tt></p>
<a id="remq!"></a>
<em> Procedure remq!</em>
<p><tt>(remq! <em>key list</em>)  =&gt; <em>list</em></tt></p>
<a id="remv!"></a>
<em> Procedure remv!</em>
<p><tt>(remv! <em>key list</em>)  =&gt; <em>list</em></tt></p>
<a id="remp!"></a>
<em> Procedure remp!</em>
<p><tt>(remp! <em>pred? list</em>)  =&gt; <em>list</em></tt></p></p>
<p>These procedures are like <tt>remove</tt>, <tt>remq</tt>, <tt>remv</tt>, and <tt>remp</tt>,
except they modify <em>list</em> instead of returning a fresh list.</p>
<p><a id="reverse!"></a>
<em> Procedure reverse!</em>
<p><tt>(reverse! <em>list</em>)  =&gt; <em>list</em></tt></p></p>
<p><tt>reverse!</tt> destructively reverses its argument and returns the reversed
list.</p>
<p><a id="some?"></a>
<em> Procedure some?</em>
<p><tt>(some? <em>procedure list1 list2 &#8230;</em>)  =&gt; <em>object</em></tt></p></p>
<p><tt>some?</tt> applies <em>procedure</em> to each element tuple of <em>list_s in
first-to-last order, and returns the first non-false value returned by
_procedure.</em> If <em>procedure</em> does not return a true value for any
element tuple of _list_s, then some? returns <tt>#f</tt>.</p>
<h3>11.6. Sorting</h3>
<p>The <tt>(rnrs sorting)</tt> library now
provides a small set of procedures that supersede most
of the procedures described below.
All of the procedures described below are therefore
deprecated.</p>
<p><em>Procedures sort and sort!</em></p>
<p><p><tt>(sort <em>list less?</em>)  =&gt; <em>list</em></tt></p>
<p><tt>(sort <em>vector less?</em>)  =&gt; <em>vector</em></tt></p>
<p><tt>(sort! <em>list less?</em>)  =&gt; <em>list</em></tt></p>
<p><tt>(sort! <em>vector less?</em>)  =&gt; <em>vector</em></tt></p></p>
<p>These procedures sort their argument (a list or a vector) according to
the predicate <em>less?</em>, which must implement a total order on the
elements in the data structures that are sorted.</p>
<p><tt>sort</tt> returns a fresh data structure containing the sorted data;
<tt>sort!</tt> sorts the data structure in-place.</p>
<h3>11.7. Records</h3>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>Larceny's records have been extended to implement all SRFI 99
and
<a href="http://www.r6rs.org/">R6RS</a>
procedures from</p>
<div class="literalblock">
<div class="content">
<pre><tt>(srfi :99 records procedural)
(srfi :99 records inspection)
(rnrs records procedural)
(rnrs records inspection)</tt></pre>
</div></div>
<p>We recommend that Larceny programmers use the SRFI 99 APIs instead
of the R6RS APIs.  This should entail no loss of portability, since
the standard reference implementation of SRFI 99 records should run
efficiently in any implementation of the R7RS/R6RS that permits new
libraries to defined at all.</p>
<p>Larceny now has two kinds of records: old-style and R7RS/R6RS/SRFI99/ERR5RS.
Old-style records cannot be created in R6RS-conforming mode, so
our extension of R6RS procedures to accept old-style records does
not affect R6RS conformance.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>The following specification describes Larceny's old-style record API,
which is now deprecated.  It
is based on a proposal posted by Pavel Curtis to
rrrs-authors on 10 Sep 1989, and later re-posted by Norman Adams to
comp.lang.scheme on 5 Feb 1992. The authorship and copyright status of
the original text are unknown to me.</p>
<p>This document differs from the original proposal in that its record
types are extensible, and that it specifies the type of record-type
descriptors.</p>
</td>
</tr></table>
</div>
<h4>11.7.1. Specification</h4>
<p><a id="make-record-type"></a>
<em> Procedure make-record-type</em>
<p><tt>(make-record-type <em>type-name field-names</em>) </tt></p></p>
<p>Returns a "record-type descriptor", a value representing a new data
type, disjoint from all others. The <em>type-name</em> argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type). The <em>field-names</em>
argument is a list of symbols naming the "fields" of a record of the
new type. It is an error if the list contains any duplicates.</p>
<p>If the <em>parent-rtd</em> argument is provided, then the new type will be a
subtype of the type represented by <em>parent-rtd</em>, and the field names
of the new type will include all the field names of the parent
type. It is an error if the complete list of field names contains any
duplicates.</p>
<p>Record-type descriptors are themselves records. In particular,
record-type descriptors have a field printer that is either <tt>#f</tt> or a
procedure. If the value of the field is a procedure, then the
procedure will be called to print records of the type represented by
the record-type descriptor. The procedure must accept two arguments:
the record object to be printed and an output port.</p>
<p><a id="record-constructor"></a>
<em> Procedure record-constructor</em>
<p><tt>(record-constructor <em>rtd</em>) </tt></p></p>
<p>Returns a procedure for constructing new members of the type
represented by <em>rtd.</em> The returned procedure accepts exactly as many
arguments as there are symbols in the given list, <em>field-names</em>; these
are used, in order, as the initial values of those fields in a new
record, which is returned by the constructor procedure. The values of
any fields not named in that list are unspecified. The field-names
argument defaults to the list of field-names in the call to
make-record-type that created the type represented by <em>rtd</em>; if the
<em>field-names</em> argument is provided, it is an error if it contains any
duplicates or any symbols not in the default list.</p>
<p><a id="record-predicate"></a>
<em> Procedure record-predicate</em>
<p><tt>(record-predicate <em>rtd</em>) </tt></p></p>
<p>Returns a procedure for testing membership in the type represented by
<em>rtd.</em> The returned procedure accepts exactly one argument and returns
a true value if the argument is a member of the indicated record type
or one of its subtypes; it returns a false value otherwise.</p>
<p><a id="record-accessor"></a>
<em> Procedure record-accessor</em>
<p><tt>(record-accessor <em>rtd field-name</em>) </tt></p></p>
<p>Returns a procedure for reading the value of a particular field of a
member of the type represented by <em>rtd.</em> The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
<em>field-name</em> in that record. The symbol field-name must be a member of
the list of field-names in the call to make-record-type that created
the type represented by <em>rtd</em>, or a member of the field-names of the
parent type of the type represented by <em>rtd.</em></p>
<p><a id="record-updater"></a>
<em> Procedure record-updater</em>
<p><tt>(record-updater <em>rtd field-name</em>) </tt></p></p>
<p>Returns a procedure for writing the value of a particular field of a
member of the type represented by <em>rtd.</em> The returned procedure
accepts exactly two arguments: first, a record of the appropriate
type, and second, an arbitrary Scheme value; it modifies the field
named by the symbol <em>field-name</em> in that record to contain the given
value. The returned value of the updater procedure is unspecified. The
symbol <em>field-name</em> must be a member of the list of field-names in the
call to make-record-type that created the type represented by <em>rtd</em>,
or a member of the field-names of the parent type of the type
represented by <em>rtd.</em></p>
<p><p><tt>(record? <em>obj</em>) </tt></p></p>
<p>Returns a true value if <em>obj</em> is a record of any type and a false value
otherwise. Note that <tt>record?</tt> may be true of any Scheme value; of
course, if it returns true for some particular value, then
<tt>record-type-descriptor</tt> is applicable to that value and returns an
appropriate descriptor.</p>
<p><a id="record-type-descriptor"></a>
<em> Procedure record-type-descriptor</em>
<p><tt>(record-type-descriptor <em>record</em>) </tt></p></p>
<p>Returns a record-type descriptor representing the type of the given
record. That is, for example, if the returned descriptor were passed
to record-predicate, the resulting predicate would return a true value
when passed the given record. Note that it is not necessarily the case
that the returned descriptor is the one that was passed to
record-constructor in the call that created the constructor procedure
that created the given record.</p>
<p><a id="record-type-name"></a>
<em> Procedure record-type-name</em>
<p><tt>(record-type-name <em>rtd</em>) </tt></p></p>
<p>Returns the type-name associated with the type represented by <em>rtd.</em>
The returned value is eqv? to the type-name argument given in the call
to make-record-type that created the type represented by rtd.</p>
<p><a id="record-type-field-names"></a>
<em> Procedure record-type-field-names</em>
<p><tt>(record-type-field-names <em>rtd</em>) </tt></p></p>
<p>Returns a list of the symbols naming the fields in members of the type
represented by <em>rtd.</em></p>
<p><a id="record-type-parent"></a>
<em> Procedure record-type-parent</em>
<p><tt>(record-type-parent <em>rtd</em>) </tt></p></p>
<p>Returns a record-type descriptor for the parent type of the type
represented by <em>rtd</em>, if that type has a parent type, or a false value
otherwise. The type represented by <em>rtd</em> has a parent type if the call
to make-record-type that created <em>rtd</em> provided the <em>parent-rtd</em>
argument.</p>
<p><a id="record-type-extends?"></a>
<em> Procedure record-type-extends?</em>
<p><tt>(record-type-extends? <em>rtd1 rtd2</em>) </tt></p></p>
<p>Returns a true value if the type represented by <em>rtd1</em> is a subtype of
the type represented by <em>rtd2</em> and a false value otherwise. A type <em>s</em>
is a subtype of a type <em>t</em> if <em>s=t</em> or if the parent type of <em>s</em>, if
it exists, is a subtype of <em>t.</em></p>
<h4>11.7.2. Implementation</h4>
<p>The R6RS spouts some tendentious nonsense about procedural
records being slower than syntactic records, but this is not
true of Larceny's records, and is unlikely to be true of other
implementations either.
Larceny's procedural records are fairly efficient already,
and will become even more efficient in future versions as
interlibrary optimizations are added.</p>
<h3>11.8. Input, Output, and Files</h3>
<p>The <tt>(scheme base)</tt>, <tt>(scheme file)</tt>, <tt>(rnrs io ports)</tt>,
and <tt>(rnrs files)</tt> libraries now
provide a set of procedures that may supersede some
of the procedures described below.
If one of Larceny's procedures duplicates the semantics of
an R7RS or R6RS procedure whose name is different, then Larceny's
name is deprecated.</p>
<p><a id="close-open-files"></a>
<em> Procedure close-open-files</em>
<p><tt>(close-open-files <em></em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Closes all open files.</p>
<p><a id="console-input-port"></a>
<em> Procedure console-input-port</em>
<p><tt>(console-input-port <em></em>)  =&gt; <em>input-port</em></tt></p></p>
<p>Returns a character input port such that no read from the port has
signalled an error or returned the end-of-file object.</p>
<p><em>Rationale:</em> console-input-port and console-output-port are artifacts
of Unix interactive I/O conventions, where an interactive end-of-file
does not mean "quit" but rather "done here". Under these conventions
the console port should be reset following an end-of-file. Resetting
conflicts with the semantics of ports in Scheme, so console-input-port
and console-output-port return a new port if the current port is
already at end-of-file.</p>
<p>Since it is convenient to handle errors in the same manner as
end-of-file, these procedures also return a new port if an error has
been signalled during an I/O operation on the port.</p>
<p>Console-input-port and console-output-port simply call the port
generators installed in the parameters console-input-port-factory and
console-output-port-factory, which allow user programs to install
their own console port generators.</p>
<p><a id="console-output-port"></a>
<em> Procedure console-output-port</em>
<p><tt>(console-output-port <em></em>)  =&gt; <em>output-port</em></tt></p></p>
<p>Returns a character output port such that no write to the port has
signalled an error.</p>
<p>See console-input-port for a full explanation.</p>
<p><a id="console-input-port-factory"></a>

<em>Parameter console-input-port-factory</em></p>
<p>The value of this parameter is a procedure that returns a character
input port such that no read from the port has signalled an error or
returned the end-of-file object.</p>
<p>See console-input-port for a full explanation.</p>
<p><a id="console-output-port-factory"></a>

<em>Parameter console-output-port-factory</em></p>
<p>The value of this parameter is a procedure that returns a character
output port such that no write the port has signalled an error.</p>
<p>See console-input-port for a full explanation.</p>
<p><a id="current-input-port"></a>

<em>Parameter current-input-port</em></p>
<p>The value of this parameter is a character input port.</p>
<p><a id="current-output-port"></a>

<em>Parameter current-output-port</em></p>
<p>The value of this parameter is a character output port.</p>
<p><a id="delete-file"></a>
<em> Procedure delete-file</em>
<p><tt>(delete-file <em>filename</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Deletes the named file. No error is signalled if the file does not
exist.</p>
<p><a id="eof-object"></a>
<em> Procedure eof-object</em>
<p><tt>(eof-object <em></em>)  =&gt; <em>end-of-file object</em></tt></p></p>
<p><em>Eof-object</em> returns an end-of-file object.</p>
<p><a id="file-exists?"></a>
<em> Procedure file-exists?</em>
<p><tt>(file-exists? <em>filename</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>File-exists? returns #t if the named file exists at the time the
procedure is called.</p>
<p><a id="file-modification-time"></a>
<em> Procedure file-modification-time</em>
<p><tt>(file-modification-time <em>filename</em>)  =&gt; <em>vector or #f</em></tt></p></p>
<p>File-modification-time returns the time of last modification of the
file as a vector, or #f if the file does not exist. The vector has six
elements: year, month, day, hour, minute, second, all of which are
exact nonnegative integers. The time returned is relative to the local
timezone.</p>
<p><tt>     (file-modification-time "larceny") =&gt; #(1997 2 6 12 51 13)</tt></p>
<p><tt>     (file-modification-time "geekdom") =&gt; #f</tt></p>
<p><a id="flush-output-port"></a>
<em> Procedure flush-output-port</em>
<p><tt>(flush-output-port <em></em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(flush-output-port <em>port</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Write any buffered data in the port to the underlying output medium.</p>
<p><a id="get-output-string"></a>
<em> Procedure get-output-string</em>
<p><tt>(get-output-string <em>string-output-port</em>)  =&gt; <em>string</em></tt></p></p>
<p>Retrieve the output string from the given string output port.</p>
<p><a id="open-input-string"></a>
<em> Procedure open-input-string</em>
<p><tt>(open-input-string <em>string</em>)  =&gt; <em>input-port</em></tt></p></p>
<p>Creates an input port that reads from <em>string</em>. The string may be
shared with the caller. A string input port does not need to be
closed, although closing it will prevent further reads from it.</p>
<p><a id="open-output-string"></a>
<em> Procedure open-output-string</em>
<p><tt>(open-output-string <em></em>)  =&gt; <em>output-port</em></tt></p></p>
<p>Creates an output port where any output is written to a string. The
accumulated string can be retrieved with
<a href="#get-output-string">[get-output-string]</a> at any time.</p>
<p><a id="port?"></a>
<em> Procedure port?</em>
<p><tt>(port? <em>object</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>Tests whether its argument is a port.</p>
<p><a id="port-name"></a>
<em> Procedure port-name</em>
<p><tt>(port-name <em>port</em>)  =&gt; <em>string</em></tt></p></p>
<p>Returns the name associated with the port; for file ports, this is the file name.</p>
<p><a id="port-position"></a>
<em> Procedure port-position</em>
<p><tt>(port-position <em>port</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns the number of characters that have been read from or written to the port.</p>
<p><a id="rename-file"></a>
<em> Procedure rename-file</em>
<p><tt>(rename-file <em>from to</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Renames the file <em>from</em> and gives it the name <em>to</em>. No error is
signalled if <em>from</em> does not exist or <em>to</em> exists.</p>
<p><a id="reset-output-string"></a>
<em> Procedure reset-output-string</em>
<p><tt>(reset-output-string <em>port</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Given a <em>port</em> created with <em>open-output-string</em>, deletes from the
port all the characters that have been output so far.</p>
<p><a id="with-input-from-port"></a>
<em> Procedure with-input-from-port</em>
<p><tt>(with-input-from-port <em>input-port thunk</em>)  =&gt; <em>object</em></tt></p></p>
<p>Calls <em>thunk</em> with current input bound to <em>input-port</em> in the dynamic
extent of <em>thunk</em>. Returns whatever value was returned from <em>thunk</em>.</p>
<p><a id="with-output-to-port"></a>
<em> Procedure with-output-to-port</em>
<p><tt>(with-output-to-port <em>output-port thunk</em>)  =&gt; <em>object</em></tt></p></p>
<p>Calls <em>thunk</em> with current output bound to <em>output-port</em> in the
dynamic extent of <em>thunk</em>. Returns whatever value was returned from
<em>thunk</em>.</p>
<h3>11.9. Operating System Interface</h3>
<p><a id="command-line-arguments"></a>
<em> Procedure command-line-arguments</em>
<p><tt>(command-line-arguments <em></em>)  =&gt; <em>vector</em></tt></p></p>
<p>Returns a vector of strings: the arguments supplied to the program by
the user or the operating system.</p>
<p><a id="dump-heap"></a>
<em> Procedure dump-heap</em>
<p><tt>(dump-heap <em>filename procedure</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Dump a heap image to the named file that will start up with the
supplied procedure. Before <em>procedure</em> is called, command line
arguments will be parsed and any init procedures registered with
<tt>add-init-procedure!</tt>  will be called.</p>
<p><em>Note: Currently, heap dumping is only available with the
stop-and-copy collector (<tt>-stopcopy</tt> command line option), although the
heap image can be used with all the other collectors.</em></p>
<p><a id="dump-interactive-heap"></a>
<em> Procedure dump-interactive-heap</em>
<p><tt>(dump-interactive-heap <em>filename</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Dump a heap image to the named file that will start up with the
standard read-eval-print loop. Before the read-eval-print loop is
called, command line arguments will be parsed and any init procedures
registered with <tt>add-init-procedure!</tt>
will be called.</p>
<p><em>Note: Currently, heap dumping is only available with the
stop-and-copy collector (<tt>-stopcopy</tt> command line option), although the
heap image can be used with all the other collectors.</em></p>
<p><a id="getenv"></a>
<em> Procedure getenv</em>
<p><tt>(getenv <em>key</em>)  =&gt; <em>string or #f</em></tt></p></p>
<p>Returns the operating system environment mapping for the string <em>key</em>,
or <tt>#f</tt> if there is no mapping for <em>key</em>.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>This is now a synonym for the <tt>get-environment-variable</tt>
exported by the <tt>(scheme process-context)</tt> library.</p>
</td>
</tr></table>
</div>
<p><a id="setenv"></a>
<em> Procedure setenv</em>
<p><tt>(setenv <em>key val</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Sets the operating system environment mapping for the string <em>key</em>
to <em>val</em>.</p>
<p><a id="system"></a>
<em> Procedure system</em>
<p><tt>(system <em>command</em>)  =&gt; <em>status</em></tt></p></p>
<p>Send the <em>command</em> to the operating system's command processor and
return the command's exit status, if any. On Unix, <em>command</em> is a
string and <em>status</em> is an exact integer.</p>
<h3><a id="FixnumPrimitives"></a>11.10. Fixnum primitives</h3>
<p>Fixnums are small exact integers that are likely to be
represented without heap
allocation. Larceny never represents a number that can be
represented as a fixnum any other way, so programs that can use
fixnums will do so automatically. However, operations that work only
on fixnums can sometimes be substantially faster than generic
operations, and the following primitives are provided for use in those
programs that need especially good performance.</p>
<p>The <tt>(rnrs arithmetic fixnums)</tt> library now
provides a large set of procedures, some of them similar to
the procedures described below.
If one of Larceny's procedures duplicates the semantics of
an R6RS procedure whose name is different, then Larceny's
name is deprecated within R7RS/R6RS code.</p>
<p>All arguments to the following procedures must be fixnums.</p>
<p><a id="fixnum?"></a>
<em> Procedure fixnum?</em>
<p><tt>(fixnum? <em>obj</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>Returns <tt>#t</tt> if its argument is a fixnum, and <tt>#f</tt> otherwise.</p>
<p><a id="fx+"></a>
<em> Procedure fx+</em>
<p><tt>(fx+ <em>fix1 fix2</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns the fixnum sum of its arguments. If the result is not
representable as a fixnum, then an error is signalled (unless error
checking has been disabled).</p>
<p><a id="fx-"></a>
<em> Procedure fx-</em></p>
<p>Returns the fixnum difference of its arguments. If the result is not
representable as a fixnum, then an error is signalled.</p>
<p><a id="fx&#8212;"></a>
<em> Procedure fx&#8212;</em>
<p><tt>(fx&#8212; <em>fix1</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns the fixnum negative of its argument. If the result is not
representable as a fixnum, then an error is signalled.</p>
<p><a id="fx*"></a>
<em> Procedure fx*</em>
<p><tt>(fx* <em>fix1 fix2</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns the fixnum product of its arguments. If the result is not
representable as a fixnum, then an error is signalled.</p>
<p><a id="fx="></a>
<em> Procedure fx=</em>
<p><tt>(fx= <em>fix1 fix2</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>Returns <tt>#t</tt> if its arguments are equal, and <tt>#f</tt> otherwise.</p>
<p><a id="fx&lt;"></a>
<em> Procedure fx&lt;</em>
<p><tt>(fx&lt; <em>fix1 fix2</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>Returns <tt>#t</tt> if <em>fix1</em> is less than <em>fix2</em>, and <tt>#f</tt> otherwise.</p>
<p><a id="fx&lt;="></a>
<em> Procedure fx&lt;=</em>
<p><tt>(fx&lt;= <em>fix1 fix2</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>Returns <tt>#t</tt> if <em>fix1</em> is less than or equal to <em>fix2</em>, and <tt>#f</tt>
otherwise.</p>
<p><a id="fx&gt;"></a>
<em> Procedure fx&gt;</em>
<p><tt>(fx&gt; <em>fix1 fix2</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>Returns <tt>#t</tt> if <em>fix1</em> is greater than <em>fix2</em>, and <tt>#f</tt> otherwise.</p>
<p><a id="fx&gt;="></a>
<em> Procedure fx&gt;=</em>
<p><tt>(fx&gt;= <em>fix1 fix2</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>Returns <tt>#t</tt> if <em>fix1</em> is greater than or equal to <em>fix2</em>, and <tt>#f</tt>
otherwise.</p>
<p><a id="fxnegative?"></a>
<em> Procedure fxnegative?</em>
<p><tt>(fxnegative? <em>fix</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>Returns <tt>#t</tt> if its argument is less than zero, and <tt>#f</tt> otherwise.</p>
<p><a id="fxpositive?"></a>
<em> Procedure fxpositive?</em>
<p><tt>(fxpositive? <em>fix</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>Returns <tt>#t</tt> if its argument is greater than zero, and <tt>#f</tt> otherwise.</p>
<p><a id="fxzero?"></a>
<em> Procedure fxzero?</em>
<p><tt>(fxzero? <em>fix</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>Returns <tt>#t</tt> if its argument is zero, and <tt>#f</tt> otherwise.</p>
<p><a id="fxlogand"></a>
<em> Procedure fxlogand</em>
<p><tt>(fxlogand <em>fix1 fix2</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns the bitwise <em>and</em> of its arguments.</p>
<p><a id="fxlogior"></a>
<em> Procedure fxlogior</em>
<p><tt>(fxlogior <em>fix1 fix2</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns the bitwise <em>inclusive or</em> of its arguments.</p>
<p><a id="fxlognot"></a>
<em> Procedure fxlognot</em>
<p><tt>(fxlognot <em>fix</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns the bitwise <em>not</em> of its argument.</p>
<p><a id="fxlogxor"></a>
<em> Procedure fxlogxor</em>
<p><tt>(fxlogxor <em>fix1 fix2</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns the bitwise <em>exclusive or</em> of its arguments.</p>
<p><a id="fxlsh"></a>
<em> Procedure fxlsh</em>
<p><tt>(fxlsh <em>fix1 fix2</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns <em>fix1</em> shifted left <em>fix2</em> places, shifting in zero bits at
the low end. If the shift count exceeds the number of bits in the
machine's word size, then the results are machine-dependent.</p>
<p><a id="most-positive-fixnum"></a>
<em> Procedure most-positive-fixnum</em>
<p><tt>(most-positive-fixnum <em></em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns the largest representable positive fixnum.</p>
<p><a id="most-negative-fixnum"></a>
<em> Procedure most-negative-fixnum</em>
<p><tt>(most-negative-fixnum <em></em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns the smallest representable negative fixnum.</p>
<p><a id="fxrsha"></a>
<em> Procedure fxrsha</em>
<p><tt>(fxrsha <em>fix1 fix2</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns <em>fix1</em> shifted right <em>fix2</em> places, shifting in a copy of the
sign bit at the left end. If the shift count exceeds the number of
bits in the machine's word size, then the results are
machine-dependent.</p>
<p><a id="fxrshl"></a>
<em> Procedure fxrshl</em>
<p><tt>(fxrshl <em>fix1 fix2</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns <em>fix1</em> shifted right <em>fix2</em> places, shifting in zero bits at
the high end. If the shift count exceeds the number of bits in the
machine's word size, then the results are machine-dependent.</p>
<h3>11.11. Numbers</h3>
<p>Larceny has six representations for numbers: <em>fixnums</em> are small,
exact integers; <em>bignums</em> are unlimited-precision exact integers;
<em>ratnums</em> are exact rationals; <em>flonums</em> are inexact rationals;
<em>rectnums</em> are exact complexes; and <em>compnums</em> are inexact complexes.</p>
<p><em>Number-representation predicates</em></p>
<p><p><tt>(fixnum? <em>obj</em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(bignum? <em>obj</em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(ratnum? <em>obj</em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(flonum? <em>obj</em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(rectnum? <em>obj</em>)  =&gt; <em>boolean</em></tt></p>
<p><tt>(compnum? <em>obj</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>These predicates test whether an object is a number of a particular
representation and return <tt>#t</tt> if so, <tt>#f</tt> if not.</p>
<p><a id="random"></a>
<em> Procedure random</em>
<p><tt>(random <em>limit</em>)  =&gt; <em>exact integer</em></tt></p></p>
<p>Returns a pseudorandom nonnegative exact integer in the range 0
through <em>limit</em>-1.</p>
<h3>11.12. Hashtables and hash functions</h3>
<p>Hashtables represent finite mappings from keys to values.
If the hash function is a good one, then the value associated
with a key may be looked up in constant time (on the average).</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>The R6RS hashtables library are a big improvement
over Larceny's traditional hash tables, and should be used
instead of the API described below.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>To resolve a clash of names and semantics with the
R6RS <tt>make-hashtable</tt> procedure, Larceny's traditional
<tt>make-hashtable</tt> procedure has been renamed to
<tt>make-oldstyle-hashtable</tt>.</p>
</td>
</tr></table>
</div>
<h4>11.12.1. Hash tables</h4>
<p><a id="make-oldstyle-hashtable"></a>
<em> Procedure make-oldstyle-hashtable</em>
<p><tt>(make-oldstyle-hashtable <em>hash-function bucket-searcher size</em>)  =&gt; <em>hashtable</em></tt></p></p>
<p>Returns a newly allocated mutable hash table using <em>hash-function</em> as
the hash function and <em>bucket-searcher</em>, e.g. <tt>assq</tt>, <tt>assv</tt>, <tt>assoc</tt>, to
search a bucket with <em>size</em> buckets at first, expanding the number of
buckets as needed. The <em>hash-function</em> must accept a key and return a
non-negative exact integer.</p>
<p><p><tt>(make-oldstyle-hashtable <em>hash-function bucket-searcher</em>)  =&gt; <em>hashtable</em></tt></p></p>
<p>Equivalent to <tt>(make-oldstyle-hashtable <em>hash-function bucket-searcher n</em>)</tt> for
some value of <em>n</em> chosen by the implementation.</p>
<p><p><tt>(make-oldstyle-hashtable <em>hash-function</em>)  =&gt; <em>hashtable</em></tt></p></p>
<p>Equivalent to <tt>(make-oldstyle-hashtable <em>hash-function</em> assv)</tt>.</p>
<p><p><tt>(make-oldstyle-hashtable <em></em>)  =&gt; <em>hashtable</em></tt></p></p>
<p>Equivalent to <tt>(make-oldstyle-hashtable object-hash assv)</tt>.</p>
<p><a id="hashtable-contains?"></a>
<em> Procedure hashtable-contains?</em>
<p><tt>(hashtable-contains? <em>hashtable key</em>)  =&gt; <em>bool</em></tt></p></p>
<p>Returns true iff the <em>hashtable</em> contains an entry for <em>key</em>.</p>
<p><a id="hashtable-fetch"></a>
<em> Procedure hashtable-fetch</em>
<p><tt>(hashtable-fetch <em>hashtable key flag</em>)  =&gt; <em>object</em></tt></p></p>
<p>Returns the value associated with <em>key</em> in the <em>hashtable</em> if the
<em>hashtable</em> contains <em>key</em>; otherwise returns <em>flag</em>.</p>
<p><a id="hashtable-get"></a>
<em> Procedure hashtable-get</em>
<p><tt>(hashtable-get <em>hashtable key</em>)  =&gt; <em>object</em></tt></p></p>
<p>Equivalent to <tt>(hashtable-fetch  #f)</tt>.</p>
<p><a id="hashtable-put!"></a>
<em> Procedure hashtable-put!</em>
<p><tt>(hashtable-put! <em>hashtable key value</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Changes the <em>hashtable</em> to associate <em>key</em> with <em>value</em>, replacing any
existing association for <em>key</em>.</p>
<p><a id="hashtable-remove!"></a>
<em> Procedure hashtable-remove!</em>
<p><tt>(hashtable-remove! <em>hashtable key</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Removes any association for <em>key</em> within the <em>hashtable</em>.</p>
<p><a id="hashtable-clear!"></a>
<em> Procedure hashtable-clear!</em>
<p><tt>(hashtable-clear! <em>hashtable</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Removes all associations from the <em>hashtable</em>.</p>
<p><a id="hashtable-size"></a>
<em> Procedure hashtable-size</em>
<p><tt>(hashtable-size <em>hashtable</em>)  =&gt; <em>integer</em></tt></p></p>
<p>Returns the number of keys contained within the <em>hashtable</em>.</p>
<p><a id="hashtable-for-each"></a>
<em> Procedure hashtable-for-each</em>
<p><tt>(hashtable-for-each <em>procedure hashtable</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>The <em>procedure</em> must accept two arguments, a key and the value
associated with that key. Calls the <em>procedure</em> once for each
key-value association in <em>hashtable</em>. The order of these calls is
indeterminate.</p>
<p><a id="hashtable-map"></a>
<em> Procedure hashtable-map</em>
<p><tt>(hashtable-map <em>procedure hashtable</em>) </tt></p></p>
<p>The <em>procedure</em> must accept two arguments, a key and the value
associated with that key. Calls the <em>procedure</em> once for each
key-value association in <em>hashtable</em>, and returns a list of the
results. The order of the calls is indeterminate.</p>
<p><a id="hashtable-copy"></a>
<em> Procedure hashtable-copy</em>
<p><tt>(hashtable-copy <em>hashtable</em>)  =&gt; <em>hashtable</em></tt></p></p>
<p>Returns a copy of the <em>hashtable</em>.</p>
<h4>11.12.2. Hash functions</h4>
<p>The <em>hash values</em> returned by these functions are nonnegative exact
integer suitable as hash values for the hashtable functions.</p>
<p><a id="equal-hash"></a>
<em> Procedure equal-hash</em>
<p><tt>(equal-hash <em>object</em>)  =&gt; <em>integer</em></tt></p></p>
<p>Returns a hash value for <em>object</em> based on its contents.</p>
<p><a id="object-hash"></a>
<em> Procedure object-hash</em>
<p><tt>(object-hash <em>object</em>)  =&gt; <em>integer</em></tt></p></p>
<p>Returns a hash value for <em>object</em> based on its identity.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>This hash function performs extremely poorly on pairs,
vectors, strings, and bytevectors, which are the objects
with which it is mostly likely to be used.
For efficient hashing on object identity, create the
hashtable with <tt>make-eq-hashtable</tt> or <tt>make-eqv-hashtable</tt>
of the <tt>(rnrs hashtables)</tt> library.</p>
</td>
</tr></table>
</div>
<p><a id="string-hash"></a>
<em> Procedure string-hash</em>
<p><tt>(string-hash <em>string</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns a hash value for <em>string</em> based on its content.</p>
<p><a id="symbol-hash"></a>
<em> Procedure symbol-hash</em>
<p><tt>(symbol-hash <em>symbol</em>)  =&gt; <em>fixnum</em></tt></p></p>
<p>Returns a hash value for <em>symbol</em> based on its print name.
The <tt>symbol-hash</tt>
is very fast, because the hash code is cached in the symbol data
structure.</p>
<h3>11.13. Parameters</h3>
<p>Parameters are procedures that serve as containers for values.</p>
<p>When called with no arguments, a parameter returns its current value.
The value of a parameter can be changed temporarily using the
<em>parameterize</em> syntax described below.</p>
<p>The effect of passing arguments to a parameter is implementation-dependent.
In Larceny, passing one argument to a parameter changes the current value
of the parameter to the result of applying a <em>converter</em> procedure to that
argument, as described by SRFI 39.</p>
<p><a id="make-parameter"></a>
<em> Procedure make-parameter</em>
<p><tt>(make-parameter <em>init</em>)  =&gt; <em>procedure</em></tt></p>
<p><tt>(make-parameter <em>init converter</em>)  =&gt; <em>procedure</em></tt></p>
<p><tt>(make-parameter <em>name init predicate</em>)  =&gt; <em>procedure</em></tt></p></p>
<p>Creates a parameter.</p>
<p>When <em>make-parameter</em> is called with one argument <em>init</em>,
the parameter's initial value is <em>init</em>, and the parameter's
<em>converter</em> will be the identity function.</p>
<p>When <em>make-parameter</em> is called with two arguments,
<em>converter</em> must be a procedure that accepts one argument,
and the parameter's initial value is the result of calling
<em>converter</em> on <em>init</em>.</p>
<p>Larceny extends SRFI 39 and the R7RS specification of <em>make-parameter</em>
by allowing it to be called with three arguments.
The first argument, <em>name,</em> must be a symbol or string giving the
print name of the parameter.
The second argument, <em>init,</em> will be the initial value of the parameter.
The third argument is a <em>predicate</em> from which Larceny constructs a
<em>converter</em> procedure that acts like the identity function on arguments
that satisfy the <em>predicate</em> but raises an exception on arguments that
don't.</p>
<p><p><tt>(make-parameter <em>name init</em>)  =&gt; <em>procedure</em></tt></p></p>
<p>Larceny's parameter objects predate SRFI 39.
For backward compatibility, Larceny's <em>make-parameter</em> will
accept two arguments even if the second is not a procedure,
provided the first argument is a symbol or string.
In that special case, the two arguments will be treated as the
<em>name</em> and <em>init</em> arguments to Larceny's three-argument version,
with the <em>predicate</em> defaulting to the identity function.
<em>This extension is strongly deprecated.</em></p>
<p><em>Syntax parameterize</em></p>
<p><tt> (parameterize ((parameter0 value0) &#8230;) expr0 expr1 &#8230;)</tt></p>
<p><em>Parameterize</em> temporarily overrides the values of a set of parameters
while the expressions in the body of the <em>parameterize</em> expression are
evaluated.
(It is like <em>fluid-let</em> for parameters instead of variables.)</p>
<h4>11.13.1. Larceny parameters</h4>
<p>The following is a partial list of Larceny's parameters.
The first three are described by the R7RS standard.
Most of the others are intended for use by developers of Larceny;
some are described in Wiki pages at Larceny's GitHub site,
while others are described only by source code.</p>
<p><a href="io.html#proc:current-input-port">Parameter <tt>current-input-port</tt></a></p>
<p><a href="io.html#proc:current-output-port">Parameter <tt>current-output-port</tt></a></p>
<p><a href="io.html#proc:current-error-port">Parameter <tt>current-error-port</tt></a></p>
<p><a href="io.html#proc:console-input-port-factory">Parameter <tt>console-input-port-factory</tt></a></p>
<p><a href="io.html#proc:console-output-port-factory">Parameter <tt>console-output-port-factory</tt></a></p>
<p><a href="repl.html#proc:herald">Parameter <tt>herald</tt></a></p>
<p><a href="environ.html#proc:interaction-environment">Parameter <tt>interaction-environment</tt></a></p>
<p><a href="control.html#proc:evaluator">Parameter <tt>evaluator</tt></a></p>
<p><a href="control.html#proc:load-evaluator">Parameter <tt>load-evaluator</tt></a></p>
<p><a href="repl.html#proc:repl-evaluator">Parameter <tt>repl-evaluator</tt></a></p>
<p><a href="repl.html#proc:repl-level">Parameter <tt>repl-level</tt></a></p>
<p><a href="repl.html#proc:repl-printer">Parameter <tt>repl-printer</tt></a></p>
<p><a href="debugging.html#proc:break-handler">Parameter <tt>break-handler</tt></a></p>
<p><a href="control.html#proc:error-handler">Parameter <tt>error-handler</tt></a></p>
<p><a href="control.html#proc:quit-handler">Parameter <tt>quit-handler</tt></a></p>
<p><a href="control.html#proc:reset-handler">Parameter <tt>reset-handler</tt></a></p>
<p><a href="control.html#proc:keyboard-interrupt-handler">Parameter <tt>keyboard-interrupt-handler</tt></a></p>
<p><a href="control.html#proc:timer-interrupt-handler">Parameter <tt>timer-interrupt-handler</tt></a></p>
<p><a href="control.html#proc:standard-timeslice">Parameter <tt>standard-timeslice</tt></a></p>
<p><a href="structures.html#proc:structure-comparator">Parameter <tt>structure-comparator</tt></a></p>
<p><a href="structures.html#proc:structure-printer">Parameter <tt>structure-printer</tt></a></p>
<h3>11.14. Property Lists</h3>
<p>The <em>property list</em> of a symbol is an association list that is
attached to that symbol. The association list maps <em>properties</em>, which
are themselves symbols, to arbitrary values.</p>
<p><a id="putprop"></a>
<em> Procedure putprop</em>
<p><tt>(putprop <em>symbol property obj</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>If an association exists for <em>property</em> on the property list of
<em>symbol</em>, then its value is replaced by the new value
<em>obj</em>. Otherwise, a new association is added to the property list of
<em>symbol</em> that associates <em>property</em> with <em>obj</em>.</p>
<p><a id="getprop"></a>
<em> Procedure getprop</em>
<p><tt>(getprop <em>symbol property</em>)  =&gt; <em>obj</em></tt></p></p>
<p>If an association exists for <em>property</em> on the property list of
<em>symbol</em>, then its value is returned. Otherwise, <tt>#f</tt> is returned.</p>
<p><a id="remprop"></a>
<em> Procedure remprop</em>
<p><tt>(remprop <em>symbol property</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>If an association exists for <em>property</em> on the property list of
<em>symbol</em>, then that association is removed. Otherwise, this is a
no-op.</p>
<h3>11.15. Symbols</h3>
<p><a id="gensym"></a>
<em> Procedure gensym</em>
<p><tt>(gensym <em>string</em>)  =&gt; <em>symbol</em></tt></p></p>
<p>Gensym returns a new uninterned symbol, the name of which contains the
given <em>string.</em></p>
<p><a id="oblist"></a>
<em> Procedure oblist</em>
<p><tt>(oblist <em></em>)  =&gt; <em>list</em></tt></p></p>
<p>Oblist returns the list of interned symbols.</p>
<p><a id="oblist-set!"></a>
<em> Procedure oblist-set!</em>
<p><tt>(oblist-set! <em>list</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(oblist-set! <em>list table-size</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p><tt>oblist-set!</tt> sets the list of interned symbols to those in the given
<em>list</em> by clearing the symbol hash table and storing the symbols in
<em>list</em> in the hash table. If the optional <em>table-size</em> is given, it is
taken to be the desired size of the new symbol table.</p>
<p>See also: <a href="#symbol-hash">[symbol-hash]</a>.</p>
<h3>11.16. System Control and Performance Measurement</h3>
<p><a id="collect"></a>
<em> Procedure collect</em>
<p><tt>(collect <em></em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(collect <em>generation</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(collect <em>generation method</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Collect initiates a garbage collection. If the system has multiple
generations, then the optional arguments are interpreted as
follows. The <em>generation</em> is the generation to collect, where 0 is the
youngest generation. The <em>method</em> determines how the collection is
performed. If <em>method</em> is the symbol collect, then a full collection
is performed in that generation, whatever that means &#8212; in a normal
multi-generational copying collector, it means that all live objects
in the generation's current semispace and all live objects from all
younger generations are copied into the generation's other
semispace. If <em>method</em> is the symbol promote, then live objects are
promoted from younger generations into the target generation &#8212; in our
example collector, that means that the objects are copied into the
target generation's current semispace.</p>
<p>The default value for <em>generation</em> is 0, and the default value for
<em>method</em> is collect.</p>
<p>Note that the collector's internal policy settings may cause it to
perform a more major type of collection than the one requested; for
example, an attempt to collect generation 2 could cause the collector
to promote all live data into generation 3.</p>
<p><a id="gc-counter"></a>
<em> Procedure gc-counter</em>
<p><tt>(gc-counter <em></em>)  =&gt; <em>fixnum</em></tt></p></p>
<p><em>gc-counter</em> returns the number of garbage collections performed since
startup. On a 32-bit system, the counter wraps around every
1,073,741,824 collections.</p>
<p><em>gc-counter</em> is a primitive and compiles to a single load instruction
on the SPARC.</p>
<p><a id="major-gc-counter"></a>
<em> Procedure major-gc-counter</em>
<p><tt>(major-gc-counter <em></em>)  =&gt; <em>fixnum</em></tt></p></p>
<p><em>major-gc-counter</em> returns the number of major garbage collections
performed since startup, where a major collection is defined as a
collection that may change the address of objects that have already
survived a previous collection.
On a 32-bit system, the counter wraps around every
1,073,741,824 collections.</p>
<p><em>major-gc-counter</em> is a primitive and compiles to a single load
instruction on the SPARC.  Its primary use to implement efficient
hashtables that hash on object identity (make-eq-hashtable and
make-eqv-hashtable).</p>
<p><a id="gcctl"></a>
<em> Procedure gcctl</em>
<p><tt>(gcctl <em>heap-number operation operand</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p><em>[GCCTL is largely obsolete in the new garbage collector but may be
resurrected in the future. It can still be used to control the
non-predictive collector.]</em></p>
<p>gcctl controls garbage collection policy on a heap-wise basis. The
<em>heap-number</em> is the heap to operate on, like for the command line
switches: heap 1 is the youngest. If the given heap number does not
correspond to a heap, gcctl fails silently.</p>
<p>The <em>operation</em> is a symbol that selects the operation to perform, and
the <em>operand</em> is the operand to that operation, always a number. For
the non-predictive garbage collector, the following operator/operand
pairs are meaningful:</p>
<ul>
<li>
<p>
j-fixed, <em>n</em>: after a collection, the collector parameter <em>j</em> should be set to the value <em>n</em>, if possible. (Non-predictive heaps only.)
</p>
</li>
<li>
<p>
j-percent, <em>n</em>: after a collection, the collector parameter <em>j</em> should be set to be <em>n</em> percent of the number of free steps. (Non-predictive heaps only.)
</p>
</li>
<li>
<p>
incr-fixed, <em>n</em>: when growing the heap, the growing should be done in increments of <em>n</em>. In the non-predictive heap, <em>n</em> is the number of steps. In other heaps, <em>n</em> denotes kilobytes.
</p>
</li>
<li>
<p>
incr-percent, <em>n</em>: when growing the heap, the growing should be done in increments of <em>n</em> percent.
</p>
</li>
</ul>
<p><strong>Example:</strong> if the non-predictive heap is heap number 2, then the expressions</p>
<div class="literalblock">
<div class="content">
<pre><tt>(gcctl 2 'j-fixed 0)
(gcctl 2 'incr-fixed 1)</tt></pre>
</div></div>
<p>makes the non-predictive collector simulate a normal stop-and-copy
collector (because <em>j</em> is always set to 0), and grows the heap only
one step at a time as necessary. This may be useful for certain kinds
of experiments.</p>
<p><strong>Example:</strong> ditto, the expressions</p>
<div class="literalblock">
<div class="content">
<pre><tt>(gcctl 2 'j-percent 50)
(gcctl 2 'incr-percent 20)</tt></pre>
</div></div>
<p>selects the default policy settings.</p>
<p><strong>Note</strong>: The gcctl facility is experimental. A more developed
  facility will allow controlling heap contraction policy, as well as
  setting all the watermarks. Certainly one can envision other uses,
  too. Finally, it needs to be possible to get current values.</p>
<p><strong>Note</strong>: Currently the non-predictive heap (np-sc-heap.c) and the
  standard stop-and-copy "old" heap (old-heap.c) are supported, but
  not the standard "young" heap (young-heap.c), nor the stop-and-copy
  collector (sc-heap.c).</p>
<p><a id="sro"></a>
<em> Procedure sro</em>
<p><tt>(sro <em>pointer-tag type-tag limit</em>)  =&gt; <em>vector</em></tt></p></p>
<p>SRO ("standing room only") is a system primitive that traverses the
entire heap and returns a vector that contains all live objects in the
heap that satisfy the constraints imposed by its parameters:</p>
<ul>
<li>
<p>
If <em>pointer-tag</em> is -1, then object type is unconstrained;
    otherwise, the object type is constrained to have a pointer tag
    that matches <em>pointer-tag</em>. You can read all about pointer tags
    <a href="#LarcenyNoteRepr">here</a>, but the short story is that 1=pair, 3=vector-like,
    5=bytevector-like, and 7=procedure-like.
</p>
</li>
<li>
<p>
If <em>type-tag</em> is -1, then object type is unconstrained by
    type-tag; otherwise, only objects with a matching type-tag are
    selected (after selection by pointer tag). Pairs don't have
    type-tags, but other objects do. You can read all about type-tags
    <a href="#LarcenyNoteRepr">here</a>.
</p>
</li>
<li>
<p>
<em>Limit</em> constrains the selected objects by the number of
    references. If <em>limit</em> is -1, then no constraints are imposed;
    otherwise, only objects (selected by pointer-tag and type-tag)
    with no more than <em>limit</em> references to them are selected.
</p>
</li>
</ul>
<p>For example, (sro -1 -1 -1) returns a vector that contains all live
objects (not including the vector), and (sro 5 2 3) returns a vector
containing all live flonums (bytevector-like, with typetag 2) that are
referred to in no more than 3 places.</p>
<p><a id="stats-dump-on"></a>
<em> Procedure stats-dump-on</em>
<p><tt>(stats-dump-on <em>filename</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Stats-dump-on turns on garbage collection statistics dumping. After
each collection, a complete RTS statistics dump is appended to the
file named by <em>filename</em>.</p>
<p>The file format and contents are documented in a banner written at the
top of the output file. In addition, accessor procedures for the
output structure are defined in the program Util/process-stats.sch.</p>
<p>Stats-dump-on does not perform an initial dump when the file is first
opened; only at the first collection is the first set of statistics
dumped. The user might therefore want to initiate a minor collection
just after turning on dumping in order to have a baseline set of data.</p>
<p><a id="stats-dump-off"></a>
<em> Procedure stats-dump-off</em>
<p><tt>(stats-dump-off <em></em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Stats-dump-off turns off garbage collection statistics dumping (which
was turned on with <a href="#stats-dump-on">[stats-dump-on]</a>). It does not dump a final set
of statistics before closing the file; therefore, the user may wish to
initiate a minor collection before calling this procedure.</p>
<p><a id="system-features"></a>
<em> Procedure system-features</em>
<p><tt>(system-features <em></em>)  =&gt; <em>alist</em></tt></p></p>
<p>System-features returns an association lists of system features. Most
entries are self-explanatory. The following are a more subtle:</p>
<ul>
<li>
<p>
The value of architecture-name is Larceny's notion of the architecture for which it was compiled, not the architecture the program is currently running on. For example, the value of this feature is "Standard-C" if you're running Petit Larceny.
</p>
</li>
<li>
<p>
The value of heap-area-info is a vector of vectors, one subvector for each heap area in the running system. The subvector has four entries: the generation number, the area type, the current size, and additional information.
</p>
</li>
</ul>
<p><a id="display-memstats"></a>
<em> Procedure display-memstats</em>
<p><tt>(display-memstats <em>vector</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(display-memstats <em>vector minimal</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(display-memstats <em>vector minimal full</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>Display-memstats takes as its argument a vector as returned by
<a href="#memstats">[memstats]</a> and displays the contents of the vector in
human-readable form on the current output port. By default, not all of
the values in the vector are displayed.</p>
<p>If the symbol minimal is passed as the second argument, then only a
small number of statistics generally relevant to running benchmarks
are displayed.</p>
<p>If the symbol full is passed as the second argument, then all
statistics are displayed.</p>
<p><a id="memstats"></a>
<em> Procedure memstats</em>
<p><tt>(memstats <em></em>)  =&gt; <em>vector</em></tt></p></p>
<p>Memstats returns a freshly allocated vector containing run-time-system
resource usage statistics. Many of these will make no sense whatsoever
to you unless you also study the RTS sources. A listing of the
contents of the vector is available <a href="#SectionMemstats">here</a>.</p>
<p><a id="run-with-stats"></a>
<em> Procedure run-with-stats</em>
<p><tt>(run-with-stats <em>thunk</em>)  =&gt; <em>obj</em></tt></p></p>
<p>Run-with-stats evaluates <em>thunk</em>, then prints a short summary of
run-time statistics, as with</p>
<div class="literalblock">
<div class="content">
<pre><tt>(display-memstats ... 'minimal),</tt></pre>
</div></div>
<p>and then returns the result of evaluating <em>thunk</em>.</p>
<p><a id="run-benchmark"></a>
<em> Procedure run-benchmark</em>
<p><tt>(run-benchmark <em>name k thunk ok?</em>)  =&gt; <em>obj</em></tt></p></p>
<p>Run-benchmark prints a short banner (including the identifying <em>name</em>)
to identify the benchmark, then runs <em>thunk</em> <em>k</em> times, and finally
tests the value returned from the last call to <em>thunk</em> by applying the
predicate <em>ok?</em> to it. If the predicate returns true, then
run-benchmark prints summary statistics, as with</p>
<div class="literalblock">
<div class="content">
<pre><tt>([display-memstats][5] ... 'minimal).</tt></pre>
</div></div>
<p>If the predicate returns false, an error is signalled.</p>
<h3>11.17. SRFI Support</h3>
<p>SRFIs (Scheme Requests For Implementations) describe and implement
additional Scheme libraries. The SRFI effort is open to anyone,
and is described at <a href="http://srfi.schemers.org">http://srfi.schemers.org</a>.</p>
<p>SRFIs are numbered.  Importing SRFIs into an R7RS library or
program is straightforward:</p>
<div class="listingblock">
<div class="content">
<pre><tt>(import (srfi 19)
        (srfi 27))</tt></pre>
</div></div>
<p>The R6RS forbids numbers within library names, so R6RS libraries
and programs must import SRFI libraries using the SRFI 97 naming
convention in which a colon precedes the number:</p>
<div class="listingblock">
<div class="content">
<pre><tt>(import (srfi :19)
        (srfi :27))</tt></pre>
</div></div>
<p>To test whether particular SRFIs are available, use the R7RS
<tt>cond-expand</tt> feature:</p>
<div class="listingblock">
<div class="content">
<pre><tt>(cond-expand
 ((and (library (srfi 19))
       (library (srfi 27)))
  (import (srfi 19))
  (import (srfi 27))))</tt></pre>
</div></div>
<p><tt>cond-expand</tt> is not available to R6RS libraries or programs.</p>
<p>R5RS programs can use <tt>cond-expand</tt> as implemented by SRFI 0,
"Feature-based conditional expansion construct".  (SRFI 0 must
be loaded into Larceny before it can be used; see below.)
Larceny provides the following nonstandard key for use in SRFI 0:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    larceny</tt></pre>
</div></div>
<p>Larceny currently supports many SRFIs, though not as many as it
should.
Some SRFIs are built into Larceny's R5RS mode, but most must be
loaded dynamically using Larceny's <tt>require</tt> procedure:</p>
<div class="listingblock">
<div class="content">
<pre><tt>    &gt; (require 'srfi-0)</tt></pre>
</div></div>
<p>The design documents for SRFI 0 and other SRFIs are available at
<a href="http://srfi.schemers.org">http://srfi.schemers.org</a>.</p>
<h3>11.18. SLIB support</h3>
<p><a href="http://www-swiss.ai.mit.edu/~jaffer/SLIB.html">SLIB</a>
is a large collection of useful libraries that have been
written or collected by Aubrey Jaffer.</p>
<p>Larceny supports SLIB via
<a href="http://srfi.schemers.org/srfi-96/">SRFI 96</a>,
but SLIB itself is not shipped with Larceny;
it must be downloaded separately and then installed.
For the most up-to-date information on installing and using
SLIB with Larceny, see <tt>doc/HOWTO-SLIB</tt>.</p>
<h3>11.19. Foreign-Function Interface to C</h3>
<p>Larceny provides a general foreign-function interface (FFI) substrate
on which other FFIs can be built; see
<a href="LarcenyNotes/note7-ffi.html">Larceny Note #7</a>.
The FFI described in this manual section is a simple example of
a derived FFI. It is not yet fully evolved, but it is useful.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>This section has undergone signficant revision, but
not all of the material has been properly vetted.
Some of the information in this section may be out of date.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>Some of the text below is adapted from the 2008 Scheme Workshop
paper, &#8220;The Layers of Larceny's Foreign Function Interface,&#8221;
by Felix S Klock II.  That paper may provide additional insight
for those searching for implementation details and motivations.</p>
</td>
</tr></table>
</div>
<h4>11.19.1. Introducing the FFI</h4>
<p>There are a number of different potential ways to use the FFI.
One client may want to develop code in C and load it into Larceny.
Another client may want to load native libraries
provided by the host operating system, enabling invocation
of foreign code from Scheme expressions without developing
any C code or even running a C compiler.
Larceny's FFI can be used for both of these cases,
but many of its facilities target a third client
in between the two extremes: a client with a C compiler and
the header files and object code for the foreign libraries,
but who wishes to avoid writing glue code in C to interface
with the libraries.</p>
<p>There are four main steps to interacting with foreign code:</p>
<ol>
<li>
<p>
identifying the space of values manipulated by the
   foreign code that will also be manipulated in Scheme,
</p>
</li>
<li>
<p>
describing how to marshal values between foreign and
   Scheme code,
</p>
</li>
<li>
<p>
loading library file(s) holding foreign object code, and
</p>
</li>
<li>
<p>
linking procedures from the loaded library.
</p>
</li>
</ol>
<p>Step 1 is conceptual, while steps 2 through 4
yield artifacts in Scheme source code.</p>
<h4>11.19.2. The space of foreign values</h4>
<p>At the machine code level, foreign values are uninterpreted
sequences of bits.  Often foreign object code is oriented
around manipulating word-sized bit-sequences (<em>words</em>)
or arrays and tuples of words.</p>
<p>Many libraries are written with a particular
interpretation of such values.  In C code, explicit types are
often used hints to guide such interpretation; for example,
a <tt>0</tt> of type <tt>bool</tt> is usually interpreted as <em>false</em>,
while a <tt>1</tt> (or other non-zero value) of type <tt>bool</tt> is
usually interpreted as <em>true</em>.
Another example are C enumerations (or <em>enums</em>).
An enum declaration defines a set of named
integral constants.  After the C declaration:</p>
<div class="listingblock">
<div class="content">
<pre><tt>enum months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };</tt></pre>
</div></div>
<p>a <tt>JAN</tt> in C code now denotes <tt>1</tt>, <tt>FEB</tt> is <tt>2</tt>, and so on.
Furthermore, tools like debuggers may render a variable <tt>x</tt>
dynamically assigned the value <tt>2</tt> (and of static type <tt>enum months</tt>)
as <tt>FEB</tt>.  Thus the enum declaration
intoduces a new interpretation for a finite set of integers.</p>
<p>This leads to questions for a client of an FFI;
we explore some below.</p>
<ul>
<li>
<p>
Should foreign words be passed over to
the Scheme world as uninterpreted numbers (and thus
be converted into Scheme integers, usually fixnums),
or should they be marshaled into interpreted values, such as
<tt>#f</tt> and <tt>#t</tt> for the <tt>bool</tt> type, or the Scheme symbols
{<tt>JAN</tt>, <tt>FEB</tt>, <tt>MAR</tt>, <tt>APR</tt>, <tt>MAY</tt>, <tt>JUN</tt>,
 <tt>JUL</tt>, <tt>AUG</tt>, <tt>SEP</tt>, <tt>OCT</tt>, <tt>NOV</tt>, <tt>DEC</tt>}
for the <tt>enum months</tt> type?
</p>
</li>
<li>
<p>
Similarly, how should Scheme values be marshaled into
foreign words?
</p>
</li>
<li>
<p>
A foreign library might leave the mapping
of names like <tt>FEB</tt> to words like <tt>2</tt> <em>unspecified</em>
in the library interface.
That is, while the C compiler will know <tt>FEB</tt> maps to <tt>2</tt>
according to a particular version of the library's header file,
the library designer may intend to change this mapping
in the future, and clients writing C code should <em>only</em> use
the names to refer to a <tt>enum months</tt> value, and <em>not</em> integer
expressions.
</p>
<ul>
<li>
<p>
How should this constraint be handled in the FFI; should
 the library client revise their code in reaction to
 such changes to the mapping?
</p>
</li>
<li>
<p>
Or should the system derive
 the mapping from the header files, in the same manner that
 the C compiler does?
</p>
</li>
</ul>
</li>
<li>
<p>
Foreign libraries often manipulate
mutable entities, like arrays of words where
modifications can be observed (often by design).
</p>
<ul>
<li>
<p>
How should such values be marshaled?
</p>
</li>
<li>
<p>
Is it sound to copy such values to the Scheme heap?
  If so, is a shallow copy sufficient?
</p>
</li>
</ul>
</li>
<li>
<p>
Will the foreign code hold references to heap-allocated
objects?  Heap-allocated objects that <em>leak</em> out to
foreign memory must be treated with care;
garbage collection presents two main problems.
</p>
<ul>
<li>
<p>
First, such objects must not move during a garbage collection;
Larceny supports this via special-purpose allocation routines:
 <tt>cons-nonrelocatable</tt>, <tt>make-nonrelocatable-bytevector</tt>,
 and <tt>make-nonrelocatable-vector</tt>.
</p>
</li>
<li>
<p>
Second, the garbage collector must know to hold on to
(i.e. trace)
such values as long as they are needed by foreign code;
otherwise the objects or their referents may be
collected without the knowledge of the foreign code.
</p>
</li>
</ul>
</li>
</ul>
<p>Answering these questions may require deep knowledge
of the intended usage of the foreign library.</p>
<p>The Larceny FFI attempts to ease interfacing with
foreign code in the presence of the above concerns,
but the nature of the header files included with
most foreign libraries means that the FFI cannot infer
the answers unassisted.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>Foreign C code developed to work in concert with Larceny
could hypothetically be written to cope with holding
handles for objects managed by the the garbage collector,
but there is currently no significant support
for this use-case.</p>
</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<p>One class of foreign values is not addressed
by the Larceny FFI: structures passed by value (as
opposed to by reference, ie pointers to structures).
There is no way to describe the interface to a
foreign procedure that accepts or produces a
C <tt>struct</tt> (at least not properly nor portably).</p>
<p>This tends to not matter for many foreign libraries
(since many C programmers eschew passing structures
by value), but it can arise.</p>
<p>If the foreign library of interest has procedures that
accept or produce a C <tt>struct</tt>, we currently recommend
either avoiding such procedures, or writing
adapter code in C that marshals between values handled
by the FFI and the C <tt>struct</tt>.</p>
</td>
</tr></table>
</div>
<p>The conclusion is: when designing an interface to a foreign
library, you should analyze the values manipulated on the
foreign side and identify their relationship with values
on the Scheme side.
After you have identified the domains of interest,
you then describe how the values will be marshaled
back and forth between the two domains.</p>
<h4>11.19.3. Marshalling via ffi-attributes</h4>
<p>This section describes the marshalling protocol defined in
<tt>lib/Base/std-ffi.sch</tt>.</p>
<p>Foreign functions automatically marshal their inputs and outputs
according to type-descriptors attached to each foreign
function.</p>
<p>Type-descriptors are S-expressons formed according to the following
grammar:</p>
<div class="literalblock">
<div class="content">
<pre><tt>TypeDesc ::= CoreAttr | ArrowT | MaybeT | OneOfT

CoreAttr ::= PrimAttr | VoidStar | ---

PrimAttr ::= CurrentPrimAttr | DeprecatedPrimAttr

CurrentPrimAttr
         ::= int | uint | byte | short | ushort | char | uchar
          |  long | ulong | longlong | ulonglong
          |  size_t | float | double |  bool | string | void

DeprecatedPrimAttr
         ::= unsigned | boxed

VoidStar ::= void* | ---

ArrowT   ::= (-&gt; (TypeDesc ...) TypeDesc)

MaybeT   ::= (maybe TypeDesc)

OneOfT   ::= (oneof (Any Fixnum) ... TypeDesc)</tt></pre>
</div></div>
<p>where <tt>---</tt> represents a user-extensible part of the grammar
(see below),
<tt>Any</tt> represents any Scheme value, and <tt>Fixnum</tt> represents
any word-sized integer.</p>
<p>A central registry maps <tt>CoreAttr</tt>'s to a foreign
representation and two conversion routines:
one to convert a Scheme value to a foreign argument, and
another to convert a foreign result back back to a Scheme value.
The denoted components are collectively referred to as a <em>type</em>
within the FFI documentation.
The registry is extensible; the <tt>ffi-add-attribute-core-entry!</tt>
procedure adds new <tt>CoreAttr's</tt> to the registry, and
one can alternatively add short-hands for
type-descriptors via the <tt>ffi-add-alias-of-attribute-entry!</tt>
procedure.
Finally, one can add new <tt>VoidStar</tt> productions
(subtypes of the <tt>void*</tt> type-descriptor)
via the <tt>ffi-install-void*-subtype</tt> procedure
(defined in the <tt>lib/Standard/foreign-stdlib.sch</tt> library).</p>
<h5>Primitive Attribute Types</h5>
<p>The following is a list of the accepted types and their conversions
at the boundary between Scheme and foreign code:</p>
<dl>
<dt>
<tt>int</tt>
</dt>
<dd>
<p>
  Exact integer values in the range [-2<sup>31</sup>,2<sup>31</sup>-1].
  Scheme integers in that range are converted to and from C "<tt>int</tt>".
</p>
</dd>
<dt>
<tt>uint</tt>
</dt>
<dd>
<p>
  Exact integer values in the range [0,2<sup>32</sup>-1].
  Scheme integers in that ranges are converted to and from C "<tt>unsigned int</tt>".
</p>
</dd>
<dt>
<tt>byte</tt>
</dt>
<dd>
<p>
  Synonymous with <tt>int</tt> in the current implementation.
</p>
</dd>
<dt>
<tt>short</tt>
</dt>
<dd>
<p>
  Synonymous with <tt>int</tt> in the current implementation.
</p>
</dd>
<dt>
<tt>ushort</tt>
</dt>
<dd>
<p>
  Synonymous with <tt>unsigned</tt> in the current implementation.
</p>
</dd>
<dt>
<tt>char</tt>
</dt>
<dd>
<p>
  Scheme ASCII characters are converted to and from C "<tt>char</tt>".
</p>
</dd>
<dt>
<tt>uchar</tt>
</dt>
<dd>
<p>
  Scheme ASCII characters are converted to and from C "<tt>unsigned char</tt>".
</p>
</dd>
<dt>
<tt>long</tt>
</dt>
<dd>
<p>
  Synonymous with <tt>int</tt> in the current implementation.
</p>
</dd>
<dt>
<tt>ulong</tt>
</dt>
<dd>
<p>
  Synonymous with <tt>unsigned</tt> in the current implementation.
</p>
</dd>
<dt>
<tt>longlong</tt>
</dt>
<dd>
<p>
  Exact integer values in the range [-2<sup>63</sup>,2<sup>63</sup>-1].
  Scheme integers in that range are converted
  to and from C "<tt>long long</tt>".
</p>
</dd>
<dt>
<tt>ulonglong</tt>
</dt>
<dd>
<p>
  Exact integer values in the range [0,2<sup>64</sup>-1].
  Scheme integers in that range are converted
  to and from C "<tt>unsigned long long</tt>".
</p>
</dd>
<dt>
<tt>size_t</tt>
</dt>
<dd>
<p>
  Synonymous with <tt>uint</tt> in the current implementation.
</p>
</dd>
<dt>
<tt>float</tt>
</dt>
<dd>
<p>
  Scheme flonums are converted to and from C "<tt>float</tt>".
  The conversion to <tt>float</tt> is performed via
  a C <tt>(float)</tt> cast from a C <tt>double</tt>.
</p>
</dd>
<dt>
<tt>double</tt>
</dt>
<dd>
<p>
  Scheme flonums are converted to and from C "double".
</p>
</dd>
<dt>
<tt>bool</tt>
</dt>
<dd>
<p>
  Scheme objects are converted to C "<tt>int</tt>";
  <tt>#f</tt> is converted to 0, and all other objects to 1.
  In the reverse direction, 0 is converted to <tt>#f</tt> and
  all other integers to <tt>#t</tt>.
</p>
</dd>
<dt>
<tt>string</tt>
</dt>
<dd>
<p>
  A Scheme string holding ASCII characters
  is <em>copied</em> into a NUL-terminated bytevector,
  passing a pointer to its first byte to the foreign procedure;
  <tt>#f</tt> is converted to a C "<tt>(char*)0</tt>" value.
  In the reverse direction, a pointer to a NUL-terminated sequence
  of bytes interpreted as ASCII characters is
  copied into a freshly allocated Scheme string; a NULL pointer is
  converted to <tt>#f</tt>.
</p>
</dd>
<dt>
<tt>void</tt>
</dt>
<dd>
<p>
  No return value.
  (Only used in return position for foreign functions;
  all Scheme procedures passed to the FFI are invoked in a context
  expecting one value.)
</p>
</dd>
<dt>
<tt>unsigned</tt>
</dt>
<dd>
<p>
  Synonymous with <tt>uint</tt>; deprecated.
</p>
</dd>
<dt>
<tt>boxed</tt>
</dt>
<dd>
<p>
  Any heap-allocated data structure (pair,
  bytevector-like, vector-like, procedure) is converted to
  a C "<tt>void*</tt>" to the first element of the structure. The
  value <tt>#f</tt> is also acceptable. It is converted to a C "<tt>(void*)0</tt>"
  value.
  (Only used in argument position for foreign functions; foreign
   functions are not expected to return direct references
   to heap-allocated values.)
</p>
</dd>
</dl>
<h5>Extending the Core Attribute Registry</h5>
<p>The public interface to many foreign libraries is written
in terms of types defined within that foreign library.
One can introduce new types to the Larceny FFI
by extending the core attribute entry table.</p>
<p><a id="ffi-add-attribute-core-entry!"></a>
<em> Procedure ffi-add-attribute-core-entry!</em>
<p><tt>(ffi-add-attribute-core-entry! <em>entry-name rep-sym marshal unmarshal</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p><a href="#ffi-add-attribute-core-entry!">[ffi-add-attribute-core-entry!]</a> extends the
internal registry with the new entry specified by its arguments.</p>
<ul>
<li>
<p>
<em>entry-name</em> is a symbol (the symbolic type name being
introduced to the ffi).
</p>
</li>
<li>
<p>
<em>rep-name</em> is a low-level type descriptor symbol, one of
<tt>signed32</tt>, <tt>unsigned32</tt>, <tt>signed64</tt>, <tt>unsigned64</tt>
(representing varieties of fixed width integers),
<tt>ieee32</tt> (representing &#8220;floats&#8221;),
<tt>ieee64</tt> (representing &#8220;doubles&#8221;), or
<tt>pointer</tt> (representing &#8220;<tt>(void*)</tt>&#8221; in C).
</p>
</li>
<li>
<p>
<em>marshal</em> is a marshaling function that accepts a Scheme object and a symbol
(the name of the invoking procedure); it is responsible for checking
the Scheme object's validity and then producing a corresponding
instance of the low-level representation.
</p>
</li>
<li>
<p>
<em>unmarshal</em> is either <tt>#f</tt> or an unmarshalling function that
accepts an instance of the low-level representation
and produces a corresponding Scheme object.
</p>
</li>
</ul>
<h5>Attribute Type Constructors</h5>
<p>Core attributes suffice for linking to simple
functions.
Constructured FFI attributes express more complex
marshaling protocols</p>
<div class="title">Arrow Type Constructors</div>
<p>A structured FFI attribute
of the form <tt>(-&gt; (<em>s_1</em> &#8230; <em>s_n</em>) <em>s_r</em>)</tt>
(called an <em>arrow type</em>)
allows passing functions from Scheme to C
and back again.  Each of the <em>s_1</em>, &#8230;, <em>s_n</em>, <em>s_r</em>
is an FFI attribute.
When an arrow type describes an input to a foreign
function, it marshals a Scheme procedure to a
C function pointer by generating glue code to hook the two together
and marshal values as described by the FFI attributes
within the arrow type.
Likewise, when an arrow type describes an output from a
foreign function, it marshals a C function pointer
to a Scheme procedure, again by generating glue code.
These two mappings naturally generalize to arbitrary nesting
of arrow types, so one can create callbacks that consume
callouts, return callouts that consume callbacks, and so on.</p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<p>The current implementation of arrow types introduces an
unnecessary space leak, because none of Larceny's current
garbage collectors attempt to reclaim some of the structure
allocated (in particular, the so-called trampolines)
when functions are marshaled via arrow types.</p>
<p>The FFI could be revised to reduce the leak
(e.g. it could keep a cache of generated trampolines and
reuse them, but currently do not do so).</p>
<p>Many foreign libraries have a structure where one only
sets up a fixed set of callbacks, and then all further
computation does not require arrow type marshaling.
This is one reason why fixing this problem
has been a low priority item for the Larceny development
team.</p>
</td>
</tr></table>
</div>
<div class="title">Maybe Type Constructor</div>
<p><tt>(maybe <em>t</em>)</tt> captures the
pattern of passing <tt>NULL</tt> in C and <tt>#f</tt> in Scheme
to represent the absence of information.
The FFI attribute <em>t</em> within the maybe type
describes the typical information passed;
the constructed maybe type
marshals <tt>#f</tt> to the foreign null pointer or <tt>0</tt> (as appropriate),
and otherwise applies the marshaling of <em>t</em>.
Likewise, it unmarshals the foreign
null pointer and <tt>0</tt> to <tt>#f</tt>, and otherwise applies the
unmarshaling of <em>t</em>.</p>
<p>(There are a few other built-in type constructors, such as
 the <tt>oneof</tt> type constructor, but they
 are not as fully-developed as the two above, and are intended
 for use only for internal development for now.)</p>
<h5>void* Type Hierarchies</h5>
<p>Using the <tt>void*</tt> attribute
wraps foreign addresses up in a Larceny record,
so that standard numeric
operations cannot be directly applied by accident.
The FFI uses two features of Larceny's record system:
the record type descriptor is a first class
value with an inspectable name, and
record types are extensible via single-inheritance.</p>
<div class="title">Basic Operations on <tt>void*</tt></div>
<p>The FFI provides <tt>void*-rt</tt>, a record type
descriptor with a single field (a wrapped address).
There is also a family of functions for dereferencing the
pointer within a <tt>void*-rt</tt> and manipulating the
state it references.</p>
<p><a id="void*-&gt;address"></a>
<em> Procedure void*-&gt;address</em>
<p><tt>(void*-&gt;address <em>x</em>)  =&gt; <em>number</em></tt></p>
Extracts the underlying address held in a <tt>void*</tt>.</p>
<p><a id="void*?"></a>
<em> Procedure void*?</em>
<p><tt>(void*? <em>x</em>)  =&gt; <em>boolean</em></tt></p>
Distinquishes <tt>void*</tt>'s from other Scheme values.</p>
<p><a id="void*-byte-ref"></a>
<em> Procedure void*-byte-ref</em>
<p><tt>(void*-byte-ref <em>x idx</em>)  =&gt; <em>number</em></tt></p>
Extracts byte at offset from address within <em>x</em>.</p>
<p><a id="void*-byte-set!"></a>
<em> Procedure void*-byte-set!</em>
<p><tt>(void*-byte-set! <em>x idx val</em>)  =&gt; <em>unspecified</em></tt></p>
Modifies byte at offset from address within <em>x</em>.</p>
<p><a id="void*-word-ref"></a>
<em> Procedure void*-word-ref</em>
<p><tt>(void*-word-ref <em>x idx</em>)  =&gt; <em>number</em></tt></p>
Extracts word-sized integer at offset from address within <em>x</em>.</p>
<p><a id="void*-word-set!"></a>
<em> Procedure void*-word-set!</em>
<p><tt>(void*-word-set! <em>x idx val</em>)  =&gt; <em>unspecified</em></tt></p>
Modifies word-sized integer at offset from address within <em>x</em>.</p>
<p><a id="void*-void*-ref"></a>
<em> Procedure void*-void*-ref</em>
<p><tt>(void*-void*-ref <em>x idx</em>)  =&gt; <em>void*</em></tt></p>
Extracts address (and wraps it in a <tt>void*</tt>) at offset from address within <em>x</em>.</p>
<p><a id="void*-void*-set!"></a>
<em> Procedure void*-void*-set!</em>
<p><tt>(void*-void*-set! <em>x idx val</em>)  =&gt; <em>unspecified</em></tt></p>
Modifies address at offset from address within <em>x</em>.</p>
<p><a id="void*-double-ref"></a>
<em> Procedure void*-double-ref</em>
<p><tt>(void*-double-ref <em>x idx</em>)  =&gt; <em>number</em></tt></p>
Extracts 64-bit flonum at offset from address within <em>x</em>.</p>
<p><a id="void*-double-set!"></a>
<em> Procedure void*-double-set!</em>
<p><tt>(void*-double-set! <em>x idx val</em>)  =&gt; <em>unspecified</em></tt></p>
Modifies 64-bit flonum at offset from address within <em>x</em>.</p>
<div class="title">Type Hierarchies</div>
<p>Procedures for establishing type hierarchies are provided by the
<tt>lib/Standard/foreign-stdlib.sch</tt> library; see
<a href="#ffi-install-void*-subtype">[ffi-install-void*-subtype]</a> and <a href="#establish-void*-subhierarchy!">[establish-void*-subhierarchy!]</a>.</p>
<h4>11.19.4. Creating loadable modules</h4>
<p>You must first compile your C code and create one or more loadable object modules. These object modules may then be loaded into Larceny, and Scheme foreign functions may link to specific functions in the loaded module. Defining foreign functions in Scheme is covered in a later section.</p>
<p>The method for creating a loadable object module varies from platform to platform. In the following, assume you have to C source files file1.c and file2.c that define functions that you want to make available as foreign functions in Larceny.</p>
<h5>SunOS 4</h5>
<p>Compile your source files and create a shared library. Using GCC, the command line might look like this:</p>
<div class="literalblock">
<div class="content">
<pre><tt>gcc -fPIC -shared file1.c file2.c -o my-library.so</tt></pre>
</div></div>
<p>The command creates my-library.so in the current directory. This library can now be loaded into Larceny using <a href="#foreign-file">[foreign-file]</a>. Any other shared libraries used by your library files should also be loaded into Larceny using <a href="#foreign-file">[foreign-file]</a> before any procedures are linked using <a href="#foreign-procedure">[foreign-procedure]</a>.</p>
<p>By default, /lib/libc.so is made available to the dynamic linker and to the foreign function interface, so there is no need for you to load that library explicitly.</p>
<h5>SunOS 5</h5>
<p>Compile your source files and create a shared library, linking with all the necessary libraries. Using GCC, the command line might look like this:</p>
<div class="literalblock">
<div class="content">
<pre><tt>gcc -fPIC -shared file1.c file2.c -lc -lm -lsocket -o my-library.so</tt></pre>
</div></div>
<p>Now you can use foreign-file to load my-library.so into Larceny.</p>
<p>By default, /lib/libc.so is made available to the foreign function interface, so there is no need for you to load that library explicitly.</p>
<h4>11.19.5. The Interface</h4>
<h5>Procedures</h5>
<p><a id="foreign-file"></a>
<em> Procedure foreign-file</em>
<p><tt>(foreign-file <em>filename</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p><a href="#foreign-file">[foreign-file]</a> loads the named object file into Larceny and makes it available for dynamic linking.</p>
<p>Larceny uses the operating system provided dynamic linker to do dynamic linking. The operation of the dynamic linker varies from platform to platform:</p>
<ul>
<li>
<p>
On some versions of SunOS 4, if the linker is given a file that does not exist, it will terminate the process. (Most likely this is a bug.) This means you should never call foreign-file with the name of a file that does not exist.
</p>
</li>
<li>
<p>
On SunOS 5, if a foreign file is given to foreign-file without a directory specification, then the dynamic linker will search its load path (the <tt>LD_LIBRARY_PATH</tt> environment variable) for the file. Hence, a foreign file in the current directory should be "./file.so", not "file.so".
</p>
</li>
</ul>
<p><a id="foreign-procedure"></a>
<em> Procedure foreign-procedure</em>
<p><tt>(foreign-procedure <em>name (arg-type &#8230;) return-type</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>FIXME: The interface to this function has been extended to support
hooking into Windows procedures that use the Pascal calling convention
instead of the C one.  The way to select which convention to use
should be documented.</p>
<p>Returns a Scheme procedure <em>p</em> that calls the foreign procedure whose
name is <em>name</em>. When <em>p</em> is called, it will convert its parameters to
representations indicated by the <em>arg-type</em>s and invoke the foreign
procedure, passing the converted values as parameters. When the
foreign procedure returns, its return value is converted to a Scheme
value according to <em>return-type</em>.</p>
<p>Types are described below.</p>
<p>The address of the foreign procedure is obtained by searching for <em>name</em> in the symbol tables of the foreign files that have been loaded with <em>foreign-file</em>.</p>
<p><a id="foreign-null-pointer"></a>
<em> Procedure foreign-null-pointer</em>
<p><tt>(foreign-null-pointer <em></em>)  =&gt; <em>integer</em></tt></p></p>
<p>Returns a foreign null pointer.</p>
<p><a id="foreign-null-pointer?"></a>
<em> Procedure foreign-null-pointer?</em>
<p><tt>(foreign-null-pointer? <em>integer</em>)  =&gt; <em>boolean</em></tt></p></p>
<p>Tests whether its argument is a foreign null pointer.</p>
<h4>11.19.6. Foreign Data Access</h4>
<h5>Raw memory access</h5>
<p>The two primitives <em>peek-bytes</em> and <em>poke-bytes</em> are provided for reading and writing memory at specific addresses. These procedures are typically used for copying data from foreign data structures into Scheme bytevectors for subsequent decoding.</p>
<p>(The use of <em>peek-bytes</em> and <em>poke-bytes</em> can often be avoided by keeping foreign data in a Scheme bytevector and passing the bytevector to a call-out using the <strong>boxed</strong> parameter type. However, this technique is inappropriate if the foreign code retains a pointer to the Scheme datum, which may be moved by the garbage collector.)</p>
<p><a id="peek-bytes"></a>
<em> Procedure peek-bytes</em>
<p><tt>(peek-bytes <em>addr bytevector count</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p><em>Addr</em> must be an exact nonnegative integer. <em>Count</em> must be a fixnum. The bytes in the range from <em>addr</em> through <em>addr+count-1</em> are copied into <em>bytevector</em>, which must be long enough to hold that many bytes.</p>
<p>If any address in the range is not an address accessible to the process, unpredictable things may happen. Typically, you'll get a segmentation fault. Larceny does not yet catch segmentation faults.</p>
<p><a id="poke-bytes"></a>
<em> Procedure poke-bytes</em>
<p><tt>(poke-bytes <em>addr bytevector count</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p><em>Addr</em> must be an exact nonnegative integer. <em>Count</em> must be a fixnum. The <em>count</em> first bytes from <em>bytevector</em> are copied into memory in the range from <em>addr</em> through <em>addr+count-1</em>.</p>
<p>If any address in the range is not an address accessible to the process, unpredictable things may happen. Typically, you'll get a segmentation fault. Larceny does not yet catch segmentation faults.</p>
<p>Also, it's possible to corrupt memory with <em>poke-bytes</em>. Don't do that.</p>
<h5>Foreign data sizes</h5>
<p>The following variables constants define the sizes of basic C data types:</p>
<ul>
<li>
<p>
<strong>sizeof:short</strong> The size of a "short int".
</p>
</li>
<li>
<p>
<strong>sizeof:int</strong> The size of an "int".
</p>
</li>
<li>
<p>
<strong>sizeof:long</strong> The size of a "long int".
</p>
</li>
<li>
<p>
<strong>sizeof:pointer</strong> The size of any pointer type.
</p>
</li>
</ul>
<h5>Decoding foreign data</h5>
<p>Foreign data is visible to a Scheme program either as an object pointed to by a memory address (which is itself represented as an integer), or as a bytevector that contains the bytes of the foreign datum.</p>
<p>A number of utility procedures that make reading and writing data of common C primitive types have been written for both these kinds of foreign objects.</p>
<p><em>Bytevector accessor procedures</em></p>
<p><p><tt>(%get16 <em>bv i</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%get16u <em>bv i</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%get32 <em>bv i</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%get32u <em>bv i</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%get-int <em>bv i</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%get-unsigned <em>bv i</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%get-short <em>bv i</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%get-ushort <em>bv i</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%get-long <em>bv i</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%get-ulong <em>bv i</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%get-pointer <em>bv i</em>)  =&gt; <em>integer</em></tt></p></p>
<p>These procedures decode bytevectors that contain the bytes of foreign objects. In each case, <em>bv</em> is a bytevector and <em>i</em> is the offset of the first byte of a field in that bytevector. The field is fetched and returned as an integer (signed or unsigned as appropriate).</p>
<p><em>Bytevector updater procedures</em></p>
<p><p><tt>(%set16 <em>bv i val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%set16u <em>bv i val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%set32 <em>bv i val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%set32u <em>bv i val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%set-int <em>bv i val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%set-unsigned <em>bv i val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%set-short <em>bv i val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%set-ushort <em>bv i val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%set-long <em>bv i val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%set-ulong <em>bv i val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%set-pointer <em>bv i val</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>These procedures update bytevectors that contain the bytes of foreign objects. In each case, <em>bv</em> is a bytevector, <em>i</em> is an offset of the first byte of a field in that bytevector, and <em>val</em> is a value to be stored in that field. The values must be exact integers in a range implied by the data type.</p>
<p><em>Foreign-pointer accessor procedures</em></p>
<p><p><tt>(%peek8 <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek8u <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek16 <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek16u <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek32 <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek32u <em>addr</em>)  =&gt; <em>integer</em></tt></p></p>
<p><p><tt>(%peek-int <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek-long <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek-unsigned <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek-ulong <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek-short <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek-ushort <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek-pointer <em>addr</em>)  =&gt; <em>integer</em></tt></p>
<p><tt>(%peek-string <em>addr</em>)  =&gt; <em>integer</em></tt></p></p>
<p>These procedures read raw memory. In each case, <em>addr</em> is an address, and the value stored at that address (the size of which is indicated by the name of the procedure) is fetched and returned as an integer.</p>
<p><em>%Peek-string</em> expects to find a NUL-terminated string of 8-bit bytes at the given address. It is returned as a Scheme string.</p>
<p><em>Foreign-pointer updater procedures</em></p>
<p><p><tt>(%poke8 <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%poke8u <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%poke16 <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%poke16u <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%poke32 <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%poke32u <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p><p><tt>(%poke-int <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%poke-long <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%poke-unsigned <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%poke-ulong <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%poke-short <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%poke-ushort <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p>
<p><tt>(%poke-pointer <em>addr val</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p>These procedures update raw memory. In each case, <em>addr</em> is an address, and <em>val</em> is a value to be stored at that address.</p>
<h4>11.19.7. Heap dumping and the FFI</h4>
<p>If foreign functions are linked into Larceny using the FFI, and a
Larceny heap image is subsequently dumped (with
<a href="#dump-interactive-heap">[dump-interactive-heap]</a> or
<a href="#dump-heap">[dump-heap]</a>), then the foreign functions are not saved as
part of the heap image. When the heap image is subsequently loaded
into Larceny at startup, the FFI will attempt to re-link all the
foreign functions in the heap image.</p>
<p>During the relinking phase, foreign files will again be loaded into Larceny, and Larceny's FFI will use the file names <em>as they were originally given to the FFI</em> when it tries to load the files. In particular, if relative pathnames were used, Larceny will not have converted them to absolute pathnames.</p>
<p>An error during relinking will result in Larceny aborting with an error message and returning to the operating system. This is considered a feature.</p>
<h4>11.19.8. Examples</h4>
<h5>Change directory</h5>
<p>This procedure uses the chdir() system call to set the process's current working directory. The string parameter type is used to pass a Scheme string to the C procedure.</p>
<div class="literalblock">
<div class="content">
<pre><tt>(define cd
  (let ((chdir (foreign-procedure "chdir" '(string) 'int)))
    (lambda (newdir)
      (if (not (zero? (chdir newdir)))
      (error "cd: " newdir " is not a valid directory name."))
      (unspecified))))</tt></pre>
</div></div>
<h5>Print Working Directory</h5>
<p>This procedure uses the getcwd() (get current working directory) system call to retrieve the name of the process's current working directory. A bytevector is created and passed in as a buffer in which to store the return value &#8212; a 0-terminated ASCII string. Then the FFI utility function ffi/asciiz-&gt;string is called to convert the bytevector to a string.</p>
<div class="literalblock">
<div class="content">
<pre><tt>(define pwd
  (let ((getcwd (foreign-procedure "getcwd" '(boxed int) 'int)))
    (lambda ()
      (let ((s (make-bytevector 1024)))
    (getcwd s 1024)
    (ffi/asciiz-&gt;string s)))))</tt></pre>
</div></div>
<h5>Quicksort</h5>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">this example is bogus.  It is not safe to pass a collectable
object into a C procedure when the callback invocation might cause a
garbage collection, thus moving the object and invalidating the
address stored in the C machine context.</td>
</tr></table>
</div>
<p>This demonstrates how to use a callback such as the comparator argument to qsort.
It is specified in the type signature using -&gt; as a type constructor.
(Note that one should probably use the built-in sort routines rather than call out
 like this; this example is for demonstrating callbacks, not how to sort.)</p>
<div class="literalblock">
<div class="content">
<pre><tt>(define qsort!
  (foreign-procedure "qsort" '(boxed ushort ushort (-&gt; (void* void*) int)) 'void))</tt></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><tt>(let ((bv (list-&gt;vector '(40 10 30 20 1 2 3 4))))
  (qsort! bv 8 4
          (lambda (x y)
            (let ((x (/ (void*-word-ref x 0) 4))
                  (y (/ (void*-word-ref y 0) 4)))
              (- x y))))
  bv)</tt></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><tt>(let ((bv (list-&gt;bytevector '(40 10 30 20 1 2 3 4))))
  (qsort! bv 8 1
          (lambda (x y)
            (let ((x (void*-byte-ref x 0))
                  (y (void*-byte-ref y 0)))
              (- x y))))
  bv)</tt></pre>
</div></div>
<h5>Other examples</h5>
<p>The Experimental directory contains several examples of use of the FFI. See in particular the files unix.sch (Unix system calls) and socket.sch (procedures for communicating over sockets).</p>
<h4>11.19.9. Higher level layers</h4>
<p>The general foreign-function interface functionality described above
is powerful but awkward to use in practice.  A user might be tempted
to hard code values of offsets or constants that are compiler
dependent.  Also, the FFI will marshall some low-level values such
as strings or integers, but other values such as enumerations
which could be naturally mapped to sets of symbols are not marshalled
since the host environment does not provide the necessary type
information to the FFI.</p>
<p>This section documents a collection of libraries to mitigate these and
other problems.</p>
<h5>foreign-ctools</h5>
<p>Foreign data access is performed by peeking at manually calculated
addresses, but in practice one often needs to inspect fields of C
structures, whose offsets are dependant on the application binary
interface (ABI) of the host environment.  Similarly, C programs often
use refer to values via constant macro definitions; since the values
of such names are not provided by the object code and Scheme programs
do not have a C preprocessor run on them prior to execution, it is
difficult to refer to the same value without encoding "magic numbers"
into the Scheme source code.</p>
<p>The foreign-ctools library is meant to mitigate problems like the two
described above.  It provides special forms for introducing global
definitions of values typically available at compile-time for a C
program.  The library assumes the presence of a C compiler (such as
<em>cc</em> on Unix systems or <em>cl.exe</em> on Windows systems).  The special
forms work by dynamically generating, compiling, and running C code at
expansion time to determine the desired values of structure offsets or
macro constants.</p>
<p>Here is a grammar for the <tt>define-c-info</tt> form provided by
the <tt>foreign-ctools</tt> library.</p>
<div class="literalblock">
<div class="content">
<pre><tt>&lt;exp&gt;     ::= (define-c-info &lt;c-decl&gt; ... &lt;c-defn&gt; ...)

&lt;c-decl&gt;  ::= (compiler &lt;cc-spec&gt;)
           |  (path &lt;include-path&gt;)
           |  (include &lt;header&gt;)
           |  (include&lt;&gt; &lt;header&gt;)

&lt;cc-spec&gt; ::= cc | cl

&lt;c-defn&gt;  ::= (const &lt;id&gt; &lt;c-type&gt; &lt;c-expr&gt;)
           |  (sizeof &lt;id&gt; &lt;c-type-expr&gt;)
           |  (struct &lt;c-name&gt; &lt;field-clause&gt; ...)
           |  (fields &lt;c-name&gt; &lt;field-clause&gt; ...)
           |  (ifdefconst &lt;id&gt; &lt;c-type&gt; &lt;c-name&gt;)

&lt;c-type&gt;  ::= int | uint | long | ulong

&lt;include-path&gt;
          ::= &lt;string-literal&gt;

&lt;header&gt;  ::= &lt;string-literal&gt;

&lt;field-clause&gt;
          ::= (&lt;offset-id&gt; &lt;c-field&gt;)
           |  (&lt;offset-id&gt; &lt;c-field&gt; &lt;size-id&gt;)

&lt;c-expr&gt;  ::= &lt;string-literal&gt;

&lt;c-type-expr&gt;
          ::= &lt;string-literal&gt;

&lt;c-name&gt;  ::= &lt;string-literal&gt;

&lt;c-field&gt; ::= &lt;string-literal&gt;</tt></pre>
</div></div>
<p><em>Syntax define-c-info</em></p>
<p><tt> (define-c-info &lt;c-decl&gt; &#8230; &lt;c-defn&gt; &#8230;)</tt></p>
<p>The <tt>&lt;c-decl&gt;</tt> clauses of <tt>define-c-info</tt>
control how header files are processed.
The <tt>compiler</tt> clause selects between <tt>cc</tt>
(the default UNIX system compiler) and <tt>cl</tt>
(the compiler included with Microsoft's Windows SDK).
The <tt>path</tt> clause adds a directory to search when
looking for header files.
The <tt>include</tt> and <tt>include&lt;&gt;</tt> clauses indicate
header files to include when executing the
<tt>&lt;c-defn&gt;</tt> clauses;
the two variants correspond to the quoted and bracketed
forms of the C preprocessor's <tt>#include</tt> directive.</p>
<p>The <tt>&lt;c-defn&gt;</tt> clauses bind identifiers.
A <tt>(const <em>x</em> <em>t</em> "<em>ae</em>")</tt> clause binds <em>x</em> to
the integer value of <em>ae</em> according to the C language;
<em>ae</em> can be any C arithmetic expression that evaluates
to a value of type <em>t</em>.
(The expected usage is for <em>ae</em> to be an
expression that the C preprocessor expands to an arithmetic expression.)</p>
<p>The remaining clauses provide similar functionality:</p>
<ul>
<li>
<p>
<tt>(sizeof <em>x</em> "<em>te</em>")</tt>
 binds <em>x</em> to the size occupied by values
 of type <em>te</em>, where <em>te</em> is any C type expression.
</p>
</li>
<li>
<p>
<tt>(struct "<em>cn</em>" &#8230; (<em>x</em> "<em>cf</em>" <em>y</em>) &#8230;)</tt>
 binds <em>x</em> to the offset from the start of a
 structure of type <tt>struct <em>cn</em></tt> to its
 <em>cf</em> field, and binds <em>y</em>, if present, to the field's size.
 A <tt>fields</tt> clause is similar, but it applies
 to structures of type <tt><em>cn</em></tt> rather than <tt>struct <em>cn</em></tt>.
</p>
</li>
<li>
<p>
<tt>(ifdefconst <em>x</em> <em>t</em> "<em>cn</em>")</tt>
 binds <em>x</em> to the value of <tt><em>cn</em></tt> if <tt><em>cn</em></tt> is defined;
 <em>x</em> is otherwise bound to Larceny's unspecified value.
</p>
</li>
</ul>
<h5>foreign-sugar</h5>
<p>The <a href="#foreign-procedure">[foreign-procedure]</a> function is sufficient to link in
dynamically loaded C procedures, but it can be annoying to
use when there are many procedures to define that all follow
a regular pattern where one could infer a mapping between
Scheme identifiers and C function names.</p>
<p>For example, some libraries follow a naming convention where a words
within a name are separated by underscores; such functions could be
immediately mapped to Scheme names where the underscores have been
replaced by dashes.</p>
<p>The foreign-sugar library provides a special form, <tt>define-foreign</tt>,
which gives the user a syntax for defining foreign functions using
a syntax where one provides only the Scheme name, the argument types,
and the return type.  The <tt>define-foreign</tt> form then attempts to
infer what C function the name was meant to refer to.</p>
<p><em>Syntax define-foreign</em></p>
<p><tt> (define-foreign (name arg-type &#8230;) result-type)</tt></p>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">There is other functionality provided allowing the user to
introduce new rules for inferring C function names, but they are
undocumented because they will probably have to change when we switch
to an R6RS macro expander.</td>
</tr></table>
</div>
<h5>foreign-stdlib</h5>
<p><a id="stdlib/malloc"></a>
<em> Procedure stdlib/malloc</em>
<p><tt>(stdlib/malloc <em>rtd</em>)  =&gt; <em>procedure</em></tt></p></p>
<p>Given a record extension of <em>void*-rt</em>, returns an allocator that uses
the C <tt>malloc</tt> procedure to allocate instances of such an object.
Note that the client is responsible for eventually freeing such
objects with <a href="#stdlib/free">[stdlib/free]</a>.</p>
<p><a id="stdlib/free"></a>
<em> Procedure stdlib/free</em>
<p><tt>(stdlib/free <em>void*-obj</em>) </tt></p></p>
<p>Frees objects produced by allocators returned from <a href="#stdlib/malloc">[stdlib/malloc]</a>.</p>
<p><a id="ffi-install-void*-subtype"></a>
<em> Procedure ffi-install-void*-subtype</em>
<p><tt>(ffi-install-void*-subtype <em>rtd</em>)  =&gt; <em>rtd</em></tt></p>
<p><tt>(ffi-install-void*-subtype <em>string</em>)  =&gt; <em>rtd</em></tt></p>
<p><tt>(ffi-install-void*-subtype <em>symbol</em>)  =&gt; <em>rtd</em></tt></p></p>
<p><a href="#ffi-install-void*-subtype">[ffi-install-void*-subtype]</a>
extends the core attribute registry with a new primitive
entry for <em>subtype</em>.
The <em>parent-rtd</em> argument should be a subtype of <tt>void*-rt</tt>
and defaults to <tt>void*-rt</tt>.
In the case of the <em>symbol</em> or <em>string</em> inputs, the
procedure constructs a new record type subtyping the <em>parent</em> argument.
In the case of the <em>rtd</em> input, the <em>rtd</em> record type
must extend <tt>void*-rt</tt>.
<a href="#ffi-install-void*-subtype">[ffi-install-void*-subtype]</a> returns the subtype record type.</p>
<p>The returned record type represents a tagged wrapped C pointer,
allowing one to encode type hierarchies.</p>
<p><a id="establish-void*-subhierarchy!"></a>
<em> Procedure establish-void*-subhierarchy!</em>
<p><tt>(establish-void*-subhierarchy! <em>symbol-tree</em>)  =&gt; <em>unspecified</em></tt></p></p>
<p><a href="#establish-void*-subhierarchy!">[establish-void*-subhierarchy!]</a> is a convenience function
for constructing large object hierarchies.
It descends the <em>symbol-tree</em>,
creates a record type descriptor for each symbol
(where the root of the tree has the parent <tt>void*-rt</tt>),
and invokes <a href="#ffi-install-void*-subtype">[ffi-install-void*-subtype]</a> on all
of the introduced types.</p>
<p><em>Type char*</em> extends <em>void*</em>
<a id="string-&gt;char*"></a>
<em> Procedure string-&gt;char*</em>
<p><tt>(string-&gt;char* <em>string</em>)  =&gt; <em>char*</em></tt></p>
<a id="char*-strlen"></a>
<em> Procedure char*-strlen</em>
<p><tt>(char*-strlen <em>char*</em>)  =&gt; <em>fixnum</em></tt></p>
<a id="char*-&gt;string"></a>
<em> Procedure char*-&gt;string</em>
<p><tt>(char*-&gt;string <em>char*</em>)  =&gt; <em>string</em></tt></p>
<p><tt>(char*-&gt;string <em>char* len</em>)  =&gt; <em>string</em></tt></p>
<a id="CallWithCharStar"></a>
<em> Procedure call-with-char*</em>
<p><tt>(call-with-char* <em>string string-function</em>)  =&gt; <em>value</em></tt></p>
<em>Type char**</em> extends <em>void*</em>
<a id="CallWithCharStarStar"></a>
<em> Procedure call-with-char**</em>
<p><tt>(call-with-char** <em>string-vector function</em>)  =&gt; <em>value</em></tt></p>
<em>Type int*</em> extends <em>void*</em>
<a id="CallWithIntStar"></a>
<em> Procedure call-with-int*</em>
<p><tt>(call-with-int* <em>fixnum-vector function</em>)  =&gt; <em>value</em></tt></p>
<em>Type short*</em> extends <em>void*</em>
<a id="CallWithShortStar"></a>
<em> Procedure call-with-short*</em>
<p><tt>(call-with-short* <em>fixnum-vector function</em>)  =&gt; <em>value</em></tt></p>
<em>Type double*</em> extends <em>void*</em>
<a id="CallWithDoubleStar"></a>
<em> Procedure call-with-double*</em>
<p><tt>(call-with-double* <em>num-vector function</em>)  =&gt; <em>value</em></tt></p></p>
<p>FIXME: (There are other functions, but I want to test and document the
ones above first&#8230;)</p>
<h5>foreign-cstructs</h5>
<p>The <tt>foreign-cstructs</tt> library provides a
more direct interface to C structures.
It provides the <tt>define-c-struct</tt> special form.
This form is layered on top of <tt>define-c-info</tt>;
the latter provides the structure field offsets
and sizes used to generate constructors
(which produce appropriately sized bytevectors,
not record instances).
The <tt>define-c-struct</tt> form combines these
with marshaling and unmarshaling procedures to
provide high-level access to a structure.</p>
<p>The grammar for the <tt>define-c-struct</tt> form is presented below.</p>
<div class="literalblock">
<div class="content">
<pre><tt>&lt;exp&gt;    ::= (define-c-struct (&lt;struct-type&gt; &lt;ctor-id&gt; &lt;c-decl&gt; ...)
                &lt;field-clause&gt; ...)

&lt;field-clause&gt;
         ::= (&lt;c-field&gt; &lt;getter&gt;) | (&lt;c-field&gt; &lt;getter&gt; &lt;setter&gt;)

&lt;getter&gt; ::= (&lt;id&gt;) | (&lt;id&gt; &lt;unmarshal&gt;)

&lt;setter&gt; ::= (&lt;id&gt;) | (&lt;id&gt; &lt;marshal&gt;)

&lt;marshal&gt; ::= &lt;ffi-attr-symbol&gt; | &lt;marshal-proc-exp&gt;

&lt;unmarshal&gt; ::= &lt;ffi-attr-symbol&gt; | &lt;unmarshal-proc-exp&gt;

&lt;struct-type&gt; ::= &lt;string-literal&gt;</tt></pre>
</div></div>
<h5>foreign-cenums</h5>
<p>This library provides the special forms
 <tt>define-c-enum</tt> and <tt>define-c-enum-set</tt>,
which associate the identifiers of
a C <tt>enum</tt> type declaration
with the integer values they denote.</p>
<p>The <tt>define-c-enum</tt> form describes enums
encoding a discriminated sum;
<tt>define-c-enum-set</tt> describes bitmasks,
mapping them to R<sup>6</sup>RS enum-sets in Scheme.</p>
<p>The <tt>(define-c-enum <em>en</em> (&lt;c-decl&gt; &#8230;)  (<em>x</em> "<em>cn</em>") &#8230;)</tt>
form adds the <tt><em>en</em></tt> FFI attribute.
The attribute marshals each symbol <tt><em>x</em></tt> to
the integer value that <tt><em>cn</em></tt> denotes in C;
unmarshaling does the inverse translation.</p>
<p>The <tt>(define-c-enum-set <em>ens</em> (&lt;c-decl&gt; &#8230;) (<em>x</em> "<em>cn</em>") &#8230;)</tt>
form binds <em>ens</em> to an R<sup>6</sup>RS enum-set constructor
with universe resulting from
<tt>(make-enumeration '(<em>x</em> &#8230;))</tt>; it also adds the <tt><em>ens</em></tt>
FFI attribute.  The attribute marshals an
enum-set <em>s</em> constructed by <em>ens</em>
to the corresponding bitmask in C (that is,
the integer one would get by logically or'ing
all <em>cn</em> such that the corresponding <em>x</em> is in <em>s</em>).
Unmarshaling attempts to do the inverse translation.</p>
<p>The grammar for the two forms is presented below.</p>
<div class="literalblock">
<div class="content">
<pre><tt>&lt;exp&gt; ::= (define-c-enum &lt;enum-id&gt; (&lt;c-decl&gt; ...)
            (&lt;id&gt; &lt;c-name&gt;) ...)

&lt;exp&gt; ::= (define-c-enum-set &lt;enum-id&gt; (&lt;c-decl&gt; ...)
            (&lt;id&gt; &lt;c-name&gt;) ...)

&lt;enum-id&gt; ::= &lt;id&gt;</tt></pre>
</div></div>
</div>
<h2>12. Debugging</h2>
<div class="sectionbody">
<p>Larceny's debugging functionality is implemented in Scheme, using some
of Larceny's extensions for catching exceptions and inspecting the
continuation structure.</p>
<h3>12.1. Entering the debugger</h3>
<p>When Larceny detects an error or a keyboard interrupt, or when it hits
a breakpoint, it signals the condition by printing a message on the
console. Larceny then enters the debugger, which signals its presence
with a short banner and the debugger prompt:</p>
<div class="literalblock">
<div class="content">
<pre><tt>Entering debugger; type "?" for help.
debug&gt;</tt></pre>
</div></div>
<p>You can also re-enter the debugger by evaluating (debug).</p>
<h3>12.2. Debugger commands</h3>
<p>The debugger is still in an immature state. The following commands are available (commands can be typed in upper or lower case):</p>
<p><strong>B</strong>     Print backtrace of continuation.</p>
<p><strong>C</strong>     Print source code of procedure, if available.</p>
<p><strong>D</strong>     Move down to previous (earlier) activation record.</p>
<p><strong>E <em>n expr</em></strong>      <em>Expr</em> is evaluated in the current
interaction environment and must evaluate to a procedure.
It is passed the contents of slot <em>n</em> from the current
activation record, and the result, if not unspecified,
is printed.</p>
<p><strong>E <em>(n1 &#8230; nk) expr</em></strong>      <em>Expr</em> is evaluated in the current
interaction environment and must evaluate to a procedure. It is
passed the contents of slots <em>n1</em> through <em>nk</em> from the current
activation record, and the result, if not unspecified, is printed.</p>
<p><strong>I <em>n</em></strong>      Inspect the procedure in slot <em>n</em> of the current
activation record.</p>
<p><strong>I @_</strong>      Inspect the active procedure.</p>
<p><strong>Q</strong>      Quit the debugger and abort the computation.</p>
<p><strong>R</strong>      Return from the debugger and continue the computation.</p>
<p><strong>S</strong>      Summarize the contents of the current activation record.</p>
<p><strong>U</strong>      Up to the next (later) activation record.</p>
<p><strong>X</strong>      Examine the contents of the current activation record.</p>
<p>The <strong>B</strong>, <strong>D</strong>, and <strong>U</strong> commands can be prefixed with a count, for example, 5 U moves up five activation records, and 10 B displays the next 10 activation records. The default for <strong>B</strong> is to display all the activations; the default count for <strong>D</strong> and <strong>U</strong> is 1.</p>
<h3>12.3. Breakpoints</h3>
<p>You can set breakpoints either in program text with the break primitive or interactively at the start of a procedure with the break-entry procedure. When Larceny reaches a breakpoint during execution, the program is suspended and the debugger is entered to allow you to inspect the program.</p>
<p><a id="larceny-break"></a>
<em> Procedure larceny-break</em>
<p><tt>(larceny-break <em></em>) </tt></p></p>
<p>Invokes the breakpoint handler.</p>
<p><a id="break-entry"></a>
<em> Procedure break-entry</em>
<p><tt>(break-entry <em>procedure</em>) </tt></p></p>
<p>Set a breakpoint at the start of the <em>procedure</em>.</p>
<p><a id="unbreak"></a>
<em> Procedure unbreak</em>
<p><tt>(unbreak <em>procedure &#8230;</em>) </tt></p></p>
<p><p><tt>(unbreak <em></em>) </tt></p></p>
<p>In the first form, remove any breakpoint set by break-entry at the start of the <em>procedure_s. In the second form, remove all breakpoints set by _break-entry</em>.</p>
<h3>12.4. Tracing</h3>
<p><a id="trace-entry"></a>
<em> Procedure trace-entry</em>
<p><tt>(trace-entry <em>procedure</em>) </tt></p></p>
<p>Set a trace point on entry to the <em>procedure</em>, removing any other trace points on the procedure. When the <em>procedure</em> is entered, information about the call is printed on the console: the name of the procedure and the actual arguments.</p>
<p><a id="trace-exit"></a>
<em> Procedure trace-exit</em>
<p><tt>(trace-exit <em>procedure</em>) </tt></p></p>
<p>Set a trace point on exit from the <em>procedure</em>, removing any other trace points on the procedure. When the <em>procedure</em> returns, information about the return is printed on the console: the name of the procedure and the returned values.</p>
<p>Note that trace-exit destroys the tail recursion properties of the instrumented procedure. Where the <em>procedure</em> would normally "return" by tail-calling another procedure, the instrumented procedure will call the other procedure by a non-tail call and then return, at which point the procedure name and return values will be printed. Thus use of trace-exit may destroy the space properties of the program.</p>
<p><a id="trace"></a>
<em> Procedure trace</em>
<p><tt>(trace <em>procedure</em>) </tt></p></p>
<p>Set trace points on <em>procedure</em> both at entry and exit.</p>
<p><a id="untrace"></a>
<em> Procedure untrace</em>
<p><tt>(untrace <em>procedure &#8230;</em>) </tt></p></p>
<p><p><tt>(untrace <em></em>) </tt></p></p>
<p>The first form removes any trace points from the specified procedures.
The second form removes all untrace points.</p>
<h3>12.5. Other functionality</h3>
<p><a id="break-handler"></a>

<em>Parameter break-handler</em></p>
<p>The value of break-handler is a procedure that is called when a breakpoint or tracepoint is encountered. The procedure takes two arguments: the procedure in which the breakpoint was set, and the byte offset within the procedure's code vector of the breakpoint.</p>
</div>
<h2><a id="Standards"></a>13. Standards</h2>
<div class="sectionbody">
<h3>13.1. Scheme standards</h3>
<p>IEEE Standard 1178-1990,
"IEEE Standard for the Scheme Programming Language",
IEEE, 1991. ISBN 1-55937-125-0.
May be ordered from IEEE by calling 1-800-678-IEEE or 908-981-1393
or writing
IEEE Service Center, 445 Hoes Lane, P.O. Box 1331,
Piscataway, NJ 08855-1331, and using order number SH14209.</p>
<p>Richard Kelsey, William Clinger, and Jonathan Rees [editors].
<a href="http://www.brics.dk/~hosc/11-1/">Revised^5 Report
on the Algorithmic Language Scheme</a>.
<em>Journal of Higher Order and Symbolic Computation</em>,
11(1), 1998, pages 7-105.
Also appears in <em>ACM SIGPLAN Notices</em> 33(9), September 1998.
Available online
<a href="http://www.schemers.org/Documents/Standards/R5RS/">in various formats</a>.</p>
<p>Michael Sperber, R Kent Dybvig, Matthew Flatt, and Anton van Straaten
[editors].
<a href="http://www.r6rs.org/">Revised^6 Report
on the Algorithmic Language Scheme</a>, 2007.</p>
<p>Alex Shinn, John Cowan, and Arthur A Gleckler [editors].
<a href="http://www.scheme-reports.org/">Revised^7 Report
on the Algorithmic Language Scheme</a>, 2013.</p>
<h3>13.2. Other relevant standards</h3>
<p>IEEE Standard 754-1985,
"IEEE Standard for Binary Floating-Point Arithmetic",
IEEE, 1985.</p>
<p>IEEE Standard 754-2008,
"IEEE Standard for Floating-Point Arithmetic",
IEEE, 2008.
(<a href="http://en.wikipedia.org/wiki/IEEE_754r">Revision of IEEE Std 754-1985</a>
began in 2000.
The IEEE Microprocessor Standards Committee (MSC)
accepted a candidate draft on 9 October 2006.
The candidate draft 1.2.6 was approved by 79% of 70 votes,
which exceeded the required supermajority of 75%.
Because there were negative votes and several hundred comments,
however, a revised draft 1.3.0 was prepared and approved by
84% of 73 votes.
Since there were over a hundred comments on the
second candidate draft as well, a third candidate draft 1.4.0 was
prepared and another vote taken in April 2007.
After a total of eight ballots, with the last four being
approved by more than 90% of the voters, the Ballot Review
Committee decided in May 2008 that
<a href="http://www.validlab.com/754R/">maximum possible timely
consensus has been obtained</a>, and the consensus draft was
submitted to IEEE-SA RevCom.
IEEE-754-2008 was approved on 12 June 2008.)</p>
<p>The Unicode Consortium.
<a href="http://www.unicode.org/">The Unicode Standard</a>.</p>
</div>
<div id="footer">
<div id="footer-text">
Last updated 07-Mar-2015 04:02:57 EDT
</div>
</div>
</body>
</html>
