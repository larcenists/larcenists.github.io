<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Larceny User Manual</title><link rel="stylesheet" href="./docbook-xsl.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /></head><body><div class="article" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="id2425960"></a>Larceny User Manual</h2></div></div><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#LarcenyChapter">1. Larceny</a></span></dt><dt><span class="section"><a href="#InstallationChapter">2. Installing Larceny</a></span></dt><dd><dl><dt><span class="section"><a href="#VarietiesSection">2.1. Varieties of Larceny</a></span></dt><dt><span class="section"><a href="#SystemRequirementsSection">2.2. System requirements</a></span></dt><dt><span class="section"><a href="#DownloadingSection">2.3. Downloading</a></span></dt><dt><span class="section"><a href="#InstallationSection">2.4. Installing the programs</a></span></dt><dt><span class="section"><a href="#CompilingStdLibSection">2.5. Compiling the R7RS/R6RS standard libraries</a></span></dt></dl></dd><dt><span class="section"><a href="#RunningChapter">3. Running Larceny</a></span></dt><dd><dl><dt><span class="section"><a href="#R5rsSection">3.1. R5RS mode</a></span></dt><dt><span class="section"><a href="#R6rsSection">3.2. R6RS mode</a></span></dt><dt><span class="section"><a href="#R7rsSection">3.3. R7RS mode</a></span></dt><dt><span class="section"><a href="#SchemeScriptsSection">3.4. Scheme scripts</a></span></dt><dt><span class="section"><a href="#R5rsScriptSection">3.5. R5RS scripting</a></span></dt><dt><span class="section"><a href="#ErrorsSection">3.6. Errors</a></span></dt><dt><span class="section"><a href="#id2530861">3.7. Troubleshooting</a></span></dt><dt><span class="section"><a href="#PerformanceSection">3.8. Performance</a></span></dt></dl></dd><dt><span class="section"><a href="#LexicalChapter">4. Lexical syntax</a></span></dt><dd><dl><dt><span class="section"><a href="#FlagsSection">4.1. Flags</a></span></dt><dt><span class="section"><a href="#CaseFoldingSection">4.2. Case-sensitivity</a></span></dt><dt><span class="section"><a href="#LexicalExtensionsSection">4.3. Lexical extensions</a></span></dt><dt><span class="section"><a href="#LexicalParametersSection">4.4. Lexical parameters</a></span></dt></dl></dd><dt><span class="section"><a href="#NamingChapter">5. File naming conventions</a></span></dt><dd><dl><dt><span class="section"><a href="#SuffixSection">5.1. Suffixes</a></span></dt><dt><span class="section"><a href="#DirectorySection">5.2. Directories</a></span></dt><dt><span class="section"><a href="#LibraryResolutionSection">5.3. Resolving references to libraries</a></span></dt><dt><span class="section"><a href="#LibraryTranslationSection">5.4. Mapping library names to files (R7RS/R6RS)</a></span></dt><dt><span class="section"><a href="#RequireLibraryTranslationSection">5.5. Mapping library names to files (R5RS)</a></span></dt></dl></dd><dt><span class="section"><a href="#CompilingChapter">6. Compiling files and libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#CompilingR7rsSection">6.1. Compiling R7RS/R6RS libraries</a></span></dt><dt><span class="section"><a href="#CompilingR5rsSection">6.2. Compiling R5RS source files</a></span></dt></dl></dd><dt><span class="section"><a href="#R7rsChapter">7. R7RS standard libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#id2534009">7.1. Known deviations from the R7RS standard</a></span></dt></dl></dd><dt><span class="section"><a href="#R6rsChapter">8. R6RS standard libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#R6rsBaseSection">8.1. Base library</a></span></dt><dt><span class="section"><a href="#R6rsUnicodeSection">8.2. Unicode</a></span></dt><dt><span class="section"><a href="#R6rsBytevectorsSection">8.3. Bytevectors</a></span></dt><dt><span class="section"><a href="#R6rsListsSection">8.4. Lists</a></span></dt><dt><span class="section"><a href="#R6rsSortingSection">8.5. Sorting</a></span></dt><dt><span class="section"><a href="#R6rsControlSection">8.6. Control</a></span></dt><dt><span class="section"><a href="#R6rsRecordsSection">8.7. Records</a></span></dt><dt><span class="section"><a href="#R6rsConditionsSection">8.8. Exceptions and conditions</a></span></dt><dt><span class="section"><a href="#R6rsIoSection">8.9. Input and output</a></span></dt><dt><span class="section"><a href="#R6rsProgramsSection">8.10. Programs</a></span></dt><dt><span class="section"><a href="#R6rsArithmeticSection">8.11. Arithmetic</a></span></dt><dt><span class="section"><a href="#R6rsSyntaxCaseSection">8.12. Syntax-case</a></span></dt><dt><span class="section"><a href="#R6rsHashtablesSection">8.13. Hashtables</a></span></dt><dt><span class="section"><a href="#R6rsEnumerationsSection">8.14. Enumeration sets</a></span></dt><dt><span class="section"><a href="#R6rsEvalSection">8.15. Eval</a></span></dt><dt><span class="section"><a href="#R6rsMutableStringsSection">8.16. Mutable pairs and strings</a></span></dt><dt><span class="section"><a href="#R6rsR5rsSection">8.17. R5RS</a></span></dt></dl></dd><dt><span class="section"><a href="#LarcenyErr5rsLibrariesChapter">9. Larceny's R7RS/R6RS libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#LarcenyLoadSection">9.1. Load</a></span></dt><dt><span class="section"><a href="#LarcenyCompilerSection">9.2. Compiler</a></span></dt><dt><span class="section"><a href="#LarcenyBenchmarkingSection">9.3. Benchmarking</a></span></dt><dt><span class="section"><a href="#RecordsPrinterSection">9.4. Records printer</a></span></dt></dl></dd><dt><span class="section"><a href="#Err5rsChapter">10. ERR5RS standard libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#Err5rsLoadSection">10.1. Load</a></span></dt><dt><span class="section"><a href="#Err5rsRecordsSection">10.2. Records</a></span></dt></dl></dd><dt><span class="section"><a href="#LarcenyR5rsLibrariesChapter">11. Larceny's R5RS libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#id2537564">11.1. Strings</a></span></dt><dt><span class="section"><a href="#id2537611">11.2. Bytevectors</a></span></dt><dt><span class="section"><a href="#id2537942">11.3. Vectors</a></span></dt><dt><span class="section"><a href="#id2538061">11.4. Procedures</a></span></dt><dt><span class="section"><a href="#id2538610">11.5. Pairs and Lists</a></span></dt><dt><span class="section"><a href="#id2539290">11.6. Sorting</a></span></dt><dt><span class="section"><a href="#id2539400">11.7. Records</a></span></dt><dt><span class="section"><a href="#id2540153">11.8. Input, Output, and Files</a></span></dt><dt><span class="section"><a href="#id2541215">11.9. Operating System Interface</a></span></dt><dt><span class="section"><a href="#FixnumPrimitives">11.10. Fixnum primitives</a></span></dt><dt><span class="section"><a href="#id2542695">11.11. Numbers</a></span></dt><dt><span class="section"><a href="#id2542878">11.12. Hashtables and hash functions</a></span></dt><dt><span class="section"><a href="#id2543843">11.13. Parameters</a></span></dt><dt><span class="section"><a href="#id2544388">11.14. Property Lists</a></span></dt><dt><span class="section"><a href="#id2544582">11.15. Symbols</a></span></dt><dt><span class="section"><a href="#id2544757">11.16. System Control and Performance Measurement</a></span></dt><dt><span class="section"><a href="#id2545870">11.17. SRFI Support</a></span></dt><dt><span class="section"><a href="#id2546007">11.18. SLIB support</a></span></dt><dt><span class="section"><a href="#id2546048">11.19. Foreign-Function Interface to C</a></span></dt></dl></dd><dt><span class="section"><a href="#id2551351">12. Debugging</a></span></dt><dd><dl><dt><span class="section"><a href="#id2551365">12.1. Entering the debugger</a></span></dt><dt><span class="section"><a href="#id2551394">12.2. Debugger commands</a></span></dt><dt><span class="section"><a href="#id2551595">12.3. Breakpoints</a></span></dt><dt><span class="section"><a href="#id2551742">12.4. Tracing</a></span></dt><dt><span class="section"><a href="#id2551956">12.5. Other functionality</a></span></dt></dl></dd><dt><span class="section"><a href="#Standards">13. Standards</a></span></dt><dd><dl><dt><span class="section"><a href="#id2552003">13.1. Scheme standards</a></span></dt><dt><span class="section"><a href="#id2552079">13.2. Other relevant standards</a></span></dt></dl></dd><dt><span class="index"><a href="#id2552140">Index</a></span></dt></dl></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="LarcenyChapter"></a>1. Larceny</h2></div></div></div><p>Larceny
implements the Scheme programming language
as defined by
the
<a class="link" href="#Standards" title="13.&#xA0;Standards">Revised<sup>7</sup> Report</a>,
the
<a class="link" href="#Standards" title="13.&#xA0;Standards">Revised<sup>6</sup> Report</a>,
the
<a class="link" href="#Standards" title="13.&#xA0;Standards">Revised<sup>5</sup> Report</a>,
and
<a class="link" href="#Standards" title="13.&#xA0;Standards">IEEE Standard 1178-1990</a>.
Those language standards serve as Larceny's primary documentation.</p><p>This manual describes aspects of Larceny that are not described
by the Revised Reports or IEEE-1178.
For the most current version of this manual, please see
<a class="ulink" href="http://larceny.ccs.neu.edu/doc" target="_top">Larceny's online documentation page</a>.
For links to the Common Larceny User Manual and the Larceny
mailing list, please visit
<a class="ulink" href="http://www.larcenists.org/" target="_top">Larceny's main web page</a>.</p><p>To report bugs, please send email to the Larceny
developers at <code class="literal">&lt;larceny@ccs.neu.edu&gt;</code>, or submit a
bug ticket at Larceny's
<a class="ulink" href="https://github.com/larcenists/larceny" target="_top">GitHub site</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="InstallationChapter"></a>2. Installing Larceny</h2></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="VarietiesSection"></a>2.1. Varieties of Larceny</h3></div></div></div><p>There are two main varieties of Larceny.</p><p>Native Larceny is the fastest and most convenient variety
of Larceny.  It compiles directly to native machine code
for Intel x86 microprocessors running Linux, Apple OS X,
or Windows operating systems.</p><p>Petit Larceny compiles to C instead of machine code.  It
can be made to run on most Unix machines.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="SystemRequirementsSection"></a>2.2. System requirements</h3></div></div></div><p>Binary distributions of native Larceny are available for
just about any Intel x86-compatible microprocessor
running a Linux, Apple OS X, or Windows operating system.
Although Larceny still uses 32-bit pointers, it will run
on 64-bit machines provided the appropriate 32-bit
libraries have been installed.</p><p>Binary distributions of Petit Larceny are available for
x86 machines running Linux.  Petit Larceny requires the <code class="literal">gcc</code>
compiler as well as the appropriate 32-bit libraries.</p><p>For more details, see
<a class="ulink" href="http://larceny.ccs.neu.edu/doc/HOWTO-INSTALL" target="_top"><code class="literal">doc/HOWTO-INSTALL</code></a>.
If you want to build Larceny or Petit Larceny from source code, see
<a class="ulink" href="http://larceny.ccs.neu.edu/doc/HOWTO-BUILD" target="_top"><code class="literal">doc/HOWTO-BUILD</code></a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="DownloadingSection"></a>2.3. Downloading</h3></div></div></div><p>The current versions of Larceny are available for
download at
<a class="ulink" href="http://www.larcenists.org/" target="_top">Larceny's main web page</a>.</p><p>Larceny is distributed in two forms: as a precompiled
binary, or as source code that can be used to reconstruct
any of the precompiled binary distributions.
Unless you intend to modify Larceny yourself, you do not
need to download the source code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="InstallationSection"></a>2.4. Installing the programs</h3></div></div></div><p>Unpack the distribution files with an appropriate command such
as one of the following, substituting the version number (such
as 0.98) for "X.Y":</p><pre class="literallayout">tar -xzf larceny-X.Y-bin-native-ia32-linux86.tar.gz
tar -xzf larceny-X.Y-bin-native-ia32-macosx.tar.gz
tar -xzf larceny-X.Y-bin-native-ia32-win32.tar.gz
tar -xzf larceny-X.Y-bin-petit-stdc-macosx.tar.gz
tar -xzf larceny-X.Y-src.tar.gz</pre><p>That will create a directory with a similar name (but without
the <code class="literal">.tar.gz</code> suffix) in your current working directory.
That is the Larceny root directory, which you may rename
to something shorter, such as <code class="literal">larceny</code>; the rest of this
section will refer to it by that name.</p><p>Assuming you have unpacked a binary distribution for Linux or
OS X, the <code class="literal">larceny</code> directory will contain the following files:</p><pre class="literallayout">larceny.bin         Run-time system
larceny.heap        Heap image with preloaded libraries and compiler
larceny             Shell script that runs the two files listed above
scheme-script       Shell script that runs Scheme scripts
compile-stale       Scheme script that compiles R7RS/R6RS libraries
startup.sch         Pathnames for the autoload and require features</pre><p>If you unpacked a binary distribution, then you should be able to
run it immediately by making the <code class="literal">larceny</code> directory your current
working directory and invoking <code class="literal">./larceny</code>.
(If that does not work, you may need to install some 32-bit libraries
on your machine.  See
<a class="ulink" href="http://larceny.ccs.neu.edu/doc/HOWTO-INSTALL" target="_top"><code class="literal">doc/HOWTO-INSTALL</code></a>.)</p><p>Binary distributions for Windows will include a <code class="literal">larceny.bat</code> file
in addition to the files listed above, so you can run Larceny by
invoking <code class="literal">larceny</code>.
(If that does not work, you may need to tell the
<a class="ulink" href="http://www.thewindowsclub.com/turn-off-data-execution-prevention-dep" target="_top">DEP
 feature</a>
to let Larceny opt out.)</p><p>If you unpacked the source code there will be many other files and
directories, but <code class="literal">larceny.bin</code> and <code class="literal">larceny.heap</code> will not be present.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Tip</h3><p>You can reconstruct the <code class="literal">larceny.bin</code> and <code class="literal">larceny.heap</code> files from their
source code, but that process requires a working version of Larceny.
Unless you're porting Larceny or Petit Larceny to a
brand new target architecture, it's easier to obtain those
files from a binary distribution of Larceny.</p></div><p>You may add the <code class="literal">larceny</code> directory to your standard path,
or you may install Larceny into a directory that is already
part of your standard path.</p><p>Suppose, for example, that you want to install Larceny
in <code class="literal">/usr/local/bin</code> and <code class="literal">/usr/local/lib/larceny</code>.
Copy the <code class="literal">larceny</code> and <code class="literal">scheme-script</code> files to <code class="literal">/usr/local/bin</code>
and edit the definition of <code class="literal">LARCENY_ROOT</code> at the head
of each file to point to the correct directory:</p><pre class="literallayout">LARCENY_ROOT=/usr/local/lib/larceny</pre><p>Then move the entire <code class="literal">larceny</code> directory to <code class="literal">/usr/local/lib/larceny</code>.</p><p>You should now be able to run Larceny from any directory
by typing "<code class="literal">larceny</code>" at a prompt.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="CompilingStdLibSection"></a>2.5. Compiling the R7RS/R6RS standard libraries</h3></div></div></div><p>If you are installing Petit Larceny, then you will have to
compile the R7RS/R6RS runtime and standard libraries before
you can run Larceny in R7RS or R6RS modes.</p><p>This step is also required if you are building any variety of
Larceny from source code.
With the prebuilt native varieties of Larceny, however, this step
should not be necessary unless you change one of the files in
<code class="literal">lib/R7RS</code>, <code class="literal">lib/R6RS</code>, or <code class="literal">lib/SRFI</code>.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Tip</h3><p>If the <code class="literal">lib/R7RS</code>, <code class="literal">lib/R6RS</code>, and <code class="literal">lib/SRFI</code> directories are
read-only, you will be less likely to touch, modify, or compile
the standard libraries by accident.</p></div><p>Compiling the R7RS/R6RS runtime and standard libraries is
accomplished as follows:</p><pre class="screen">    $ ./larceny
    Larceny v0.98 "General Ripper" (...)
    &gt; (require 'r7rsmode)
    &gt; (larceny:compile-r7rs-runtime)
    &gt; (exit)</pre><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>Compiling the R7RS/R6RS runtime as shown above causes
all previously compiled R7RS/R6RS libraries and top-level
programs to become <a class="link" href="#CompilingChapter" title="6.&#xA0;Compiling files and libraries">stale</a>.  That means
those previously compiled files will need to be recompiled
or removed.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="RunningChapter"></a>3. Running Larceny</h2></div></div></div><p>Larceny can run in any of these distinct modes:</p><pre class="literallayout">R5RS              traditional read/eval/print loop (the default)
R6RS              batch execution of R6RS top-level programs
R7RS              R7RS read/eval/print loop or batch execution
Scheme script     batch execution of R7RS/R6RS Scheme scripts</pre><p><a class="link" href="#R5rsSection" title="3.1.&#xA0;R5RS mode">R5RS mode</a>
extends the Scheme language described by the R5RS and
IEEE/ANSI Std 1178 by adding R7RS/R6RS lexical syntax and most
of the procedures described by the newer R6RS and R7RS standards.</p><p><a class="link" href="#R6rsSection" title="3.2.&#xA0;R6RS mode">R6RS mode</a>
is largely redundant with Larceny's R7RS mode (because
every reasonable R6RS library and program could just as well be
executed in R7RS mode).  There is only one difference between
those two modes: R6RS mode enforces the R6RS mandates that, among
other things, forbid read/eval/print loops and most extensions
to R6RS lexical syntax.</p><p><a class="link" href="#R7rsSection" title="3.3.&#xA0;R7RS mode">R7RS mode</a>
will accept any combination of R7RS and R6RS libraries
and programs.  In Larceny, R6RS Scheme becomes a proper subset of
R7RS Scheme.</p><p><a class="link" href="#SchemeScriptsSection" title="3.4.&#xA0;Scheme scripts">Scheme scripts</a>
are directly executable R7RS/R6RS programs.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R5rsSection"></a>3.1. R5RS mode</h3></div></div></div><p>When you start Larceny in R5RS mode (the default), you
will be presented with a banner message and the
read-eval-print loop's prompt:</p><pre class="screen">    % larceny
    Larceny vX.Y "&lt;version_name&gt;" (MMM DD YYYY HH:MM:SS, ...)
    larceny.heap, built ...

    &gt;</pre><p>You can enter a Scheme expression at the prompt.
After a complete expression has been read, it will
be evaluated and its results printed.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>In native Larceny, the expression is evaluated by
compiling it to native machine code, which is then executed.
In Petit Larceny, the expression is evaluated by
an interpreter because compiling to C, running the
C compiler, and loading the compiled C code would
take too long.  Interpreted code behaves like compiled code,
so most of what this manual says about the compiler is also
true of Petit Larceny's interpreter.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsSection"></a>3.2. R6RS mode</h3></div></div></div><p>To execute a top-level R6RS program that is contained
within a file named <code class="literal">pgm</code>, type:</p><pre class="screen">    larceny -r6rs -program pgm</pre><p>The <code class="literal">-program</code> option can be omitted, in which case
Larceny will read the top-level program from standard
input:</p><pre class="screen">    larceny -r6rs &lt; pgm</pre><p>If you omit the <code class="literal">-program</code> option and do not redirect
standard input, then Larceny will wait patiently
for you to type a complete top-level program into
standard input, terminating it with an end-of-file.</p><p>You probably don't want to do that.  Had you wanted to
type R6RS code at Larceny, you'd be using Larceny's R7RS
read/eval/print loop instead.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R7rsSection"></a>3.3. R7RS mode</h3></div></div></div><p>To execute a top-level R7RS/R6RS program that is contained
within a file named <code class="literal">pgm</code>, type:</p><pre class="screen">    larceny -r7rs -program pgm</pre><p>To interact with Larceny's R7RS read/eval/print loop,
omit the <code class="literal">-program</code> option:</p><pre class="screen">    % larceny -r7rs
    Larceny v0.98 "General Ripper" (...)</pre><p>The <code class="literal">(scheme base)</code> library has already been imported,
but you may want to import other libraries as well.
For example:</p><pre class="screen">    &gt; (import (scheme read)
              (scheme write)
              (scheme file)
              (scheme cxr)
              (scheme inexact)
              (scheme complex)
              (scheme char)
              (scheme load))</pre><p>If you'd rather have Larceny import all of the standard R7RS and
R6RS libraries at startup, along with a few Larceny-specific
procedures, you can use the <code class="literal">-r7r6</code> option instead of <code class="literal">r7rs</code>:</p><pre class="screen">    % larceny -r7r6
    Larceny v0.98 "General Ripper" (...)</pre><p>Using the <code class="literal">-r7r6</code> option is equivalent to using the <code class="literal">-r7rs</code>
option and then importing the <code class="literal">(larceny r7r6)</code> library.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>One name conflict could not be resolved by adding R7RS extensions
to the conflicting R6RS procedure or syntax.  When the <code class="literal">-r7r6</code>
option is used, the <code class="literal">bytevector-copy!</code> procedure is imported with
R7RS semantics, and the older R6RS version of that procedure is
renamed to <code class="literal">r6rs:bytevector-copy!</code>.</p></div><p>The <code class="literal">features</code> procedure will return a list of all <code class="literal">cond-expand</code>
features and libraries available to you.  That procedure reads
the source code for all library files found in your current
<a class="link" href="#">Larceny library path</a>, so don't be
surprised if it takes a few seconds.</p><pre class="screen">    &gt; (features)
    (r7rs r6rs larceny larceny-0.98
     exact-closed ratios exact-complex complex ieee-float
     full-unicode full-unicode-strings unicode-7
     posix unix gnu-linux i386 ilp32 little-endian
     ...
     (rnrs arithmetic bitwise (6))
     (rnrs arithmetic fixnums (6))
     (rnrs arithmetic flonums (6))
     (rnrs bytevectors (6))
     ...
     (rnrs (6))
     (scheme base)
     (scheme case-lambda)
     (scheme char)
     (scheme complex)
     (scheme cxr)
     (scheme eval)
     (scheme file)
     (scheme inexact)
     (scheme lazy)
     (scheme load)
     (scheme process-context)
     (scheme r5rs)
     (scheme read)
     (scheme repl)
     (scheme time)
     (scheme write)
     (srfi 1)
     (srfi 1 lists)
     ...)</pre><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="R7rsAutomaticLoadingSection"></a>3.3.1. Automatic loading</h4></div></div></div><p>As an extension to the R7RS and R6RS, Larceny attempts to load
libraries automatically when they are first imported.
Autoloading makes interactive development and
<a class="link" href="#CompilingChapter" title="6.&#xA0;Compiling files and libraries">separate compilation</a>
much more convenient.</p><p>All of Larceny's
<a class="link" href="#R7rsPreDefinedSection" title="3.3.3.&#xA0;Predefined libraries">predefined libraries</a>
can be autoloaded.</p><p>To enable autoloading of other R7RS/R6RS libraries,
including libraries you've written yourself, you can:</p><div class="itemizedlist"><ul type="disc"><li>
use the <a class="link" href="#"><code class="literal">-path</code> command-line option</a>
</li><li>
use the <a class="link" href="#R7rsLibraryVariableSection" title="3.3.4.&#xA0;Library path"><code class="literal">LARCENY_LIBPATH</code></a> environment variable
</li><li>
use <a class="link" href="#current-require-path"><code class="literal">current-require-path</code></a>
</li><li>
edit <code class="literal">startup.sch</code> in Larceny's root directory
</li><li>
add the libraries to Larceny's <code class="literal">lib</code> directory
</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="R7rsDynamicLoadingSection"></a>3.3.2. Explicit loading</h4></div></div></div><p>Larceny automatically loads R7RS/R6RS libraries when
they are first imported.  This is usually the most
convenient way to load a library, but autoloading
can't be used to load a top-level program.  Explicit
loading is needed for top-level programs, for libraries
that don't reside in Larceny's
<a class="link" href="#current-require-path"><code class="literal">current-require-path</code></a>,
and for libraries that are defined in files whose names
do not follow Larceny's
<a class="link" href="#NamingChapter" title="5.&#xA0;File naming conventions">standard naming conventions</a>.</p><p>In theory, explicit loading is the only portable way for R7RS
programs to load a library.
<a class="link" href="#LibraryResolutionSection" title="5.3.&#xA0;Resolving references to libraries">There is no portable way for R6RS programs to load or import libraries</a>,
so R6RS programs must rely upon implementation-specific
mechanisms such as Larceny's autoloading.</p><p>For explicit loading of nonstandard libraries, top-level
programs, or unadorned R5RS-style code from a file, you
must first import a suitable load procedure:</p><pre class="screen">    &gt; (import (scheme load))</pre><p>Loading a library does not automatically import it.
To use the variables and syntax that are exported by a
library, you must import that library explicitly:</p><pre class="screen">    &gt; (load "lib/R6RS/larceny/benchmarking.sls")
    &gt; (import (larceny benchmarking))
    &gt; (time (vector-for-each + (make-vector 1000000 0)))
    Words allocated: 3053286
    Elapsed time...: 25 ms (User: 25 ms; System: 0 ms)
    Elapsed GC time: 3 ms (CPU: 2 in 2 collections (1 minor).)</pre><p>In Larceny, you may omit the call to <code class="literal">load</code> because the
<code class="literal">(larceny benchmarking)</code> library will be autoloaded when
it is imported.  In other implementations of the R7RS, you
may have to load all of the nonstandard libraries that will
be imported by a top-level program or library before you
load that top-level program or library.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="R7rsPreDefinedSection"></a>3.3.3. Predefined libraries</h4></div></div></div><p>Larceny predefines several nonstandard libraries in addition
to the standard R7RS and R6RS libraries, and autoloads them
for your convenience.  The predefined, autoloadable libraries
include:</p><p>Composite library:</p><pre class="literallayout">(larceny r7r6)                         ; all R7RS/R6RS standard libraries</pre><p>R7RS standard libraries:</p><pre class="literallayout">(scheme base)
(scheme case-lambda)
(scheme char)
(scheme complex)
(scheme cxr)
(scheme eval)
(scheme file)
(scheme inexact)
(scheme lazy)
(scheme load)
(scheme process-context)
(scheme r5rs)
(scheme read)
(scheme repl)
(scheme time)
(scheme write)</pre><p>R6RS standard libraries:</p><pre class="literallayout">(rnrs base (6))                        ; R6RS chapter 9
(rnrs unicode (6))                     ; R6RS library chapter 1
(rnrs bytevectors (6))                 ; R6RS library chapter 2
(rnrs lists (6))                       ; R6RS library chapter 3
(rnrs sorting (6))                     ; R6RS library chapter 4
(rnrs control (6))                     ; R6RS library chapter 5
(rnrs exceptions (6))                  ; R6RS library section 7.1
(rnrs conditions (6))                  ; R6RS library sections 7.2 and 7.3
(rnrs io ports (6))                    ; R6RS library sections 8.1 and 8.2
(rnrs io simple (6))                   ; R6RS library sections 8.1 and 8.3
(rnrs files (6))                       ; R6RS library chapter 9
(rnrs programs (6))                    ; R6RS library chapter 10
(rnrs arithmetic fixnums (6))          ; R6RS library section 11.2
(rnrs arithmetic flonums (6))          ; R6RS library section 11.3
(rnrs arithmetic bitwise (6))          ; R6RS library section 11.4
(rnrs syntax-case (6))                 ; R6RS library chapter 12
(rnrs hashtables (6))                  ; R6RS library chapter 13
(rnrs enums)                           ; R6RS library chapter 14
(rnrs (6))                             ; R6RS library chapter 15
(rnrs eval (6))                        ; R6RS library chapter 16
(rnrs mutable-pairs (6))               ; R6RS library chapter 17
(rnrs mutable-strings (6))             ; R6RS library chapter 18
(rnrs r5rs (6))                        ; R6RS library chapter 19</pre><p>R6RS standard libraries that are autoloadable but deprecated in Larceny
because they have been superseded by the R7RS and SRFI 99 record
facilities:</p><pre class="literallayout">(rnrs records procedural (6))          ; R6RS library section 6.3
(rnrs records inspection (6))          ; R6RS library section 6.4
(rnrs records syntactic (6))           ; R6RS library section 6.2</pre><p>SRFI libraries:</p><pre class="literallayout">(srfi 1 lists)                         ; list library
(srfi 2 and-let*)                      ; extended `and` and `let*`
(srfi 5 let)                           ; extended version of `let`
(srfi 6 basic-string-ports)            ; basic string ports
(srfi 8 receive)                       ; binding to multiple values
(srfi 9 records)                       ; defining record types
(srfi 11 let-values)                   ; syntax for multiple values
(srfi 13 strings)                      ; string libraries
(srfi 14 char-sets)                    ; character-set library (default)
(srfi 14 unicode)                      ;   for all Unicode characters
(srfi 14 bmp)                          ;   for the Basic Multilingual Plane
(srfi 14 latin-1)                      ;   for ISO 8859-1 (Latin-1)
(srfi 16 case-lambda)                  ; syntax for variable arity
(srfi 17 generalized-set!)             ; generalized set!
(srfi 19 time)                         ; time data types and procedures
(srfi 23 error)                        ; error reporting mechanism
(srfi 25 multi-dimensional-arrays)     ; multi-dimensional array primitives
(srfi 26 cut)                          ; specializing without currying
(srfi 27 random-bits)                  ; sources of random bits
(srfi 28 basic-format-strings)         ; basic format strings
(srfi 29 localization)                 ; localization
(srfi 38 with-shared-structure)        ; i/o for data with shared structure
(srfi 39 parameters)                   ; parameter objects
(srfi 41 streams)                      ; streams
(srfi 42 eager-comprehensions)         ; eager comprehensions
(srfi 43 vectors)                      ; vector library
(srfi 45 lazy)                         ; iterative lazy algorithms
(srfi 48 intermediate-format-strings)  ; format
(srfi 51 rest-values)                  ; rest values hackery
(srfi 54 cat)                          ; still more formatting
(srfi 59 vicinities)                   ; vicinity
(srfi 61 cond)                         ; a more general cond clause
(srfi 63 arrays)                       ; homogeneous, heterogeneous arrays
(srfi 64 testing)                      ; an API for test suites
(srfi 67 compare-procedures)           ; three-way comparison procedures
(srfi 78 lightweight-testing)          ; lightweight testing
(srfi 87 case)                         ; a more general case clause
(srfi 98 os-environment-variables)     ; environment variables
(srfi 99 records)                      ; (composite library)
(srfi 99 records procedural)           ; (procedural API)
(srfi 99 records inspection)           ; (inspection API)
(srfi 99 records syntactic)            ; (syntactic API)
(srfi 101 random-access-lists)         ; fast and purely functional lists
(srfi 111 boxes)                       ; boxes
(srfi 112)                             ; environment inquiry
(srfi 113 sets)                        ; sets and bags
(srfi 114 comparators)                 ; comparators
(srfi 115 regexp)                      ; regular expressions
(srfi 116 ilists)                      ; immutable lists</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>For backward compatibility,
<code class="literal">(srfi 1 lists)</code> through <code class="literal">(srfi 101 random-access-lists)</code> are also
available with the SRFI 97 naming convention in which the number is
preceded by a colon, as in <code class="literal">(srfi :1 lists)</code>.
With the more liberal R7RS syntax, that SRFI 97 naming convention
is now unnecessary.
Larceny has extended the R6RS <code class="literal">library</code> syntax to allow R6RS libraries
to import R7RS libraries that follow the R7RS naming convention shown
in the list above.</p></div><p>SRFI libraries that are autoloadable but deprecated in Larceny,
usually because they have been superseded in whole or in part by
R6RS syntax or libraries:</p><pre class="literallayout">(srfi 60 integer-bits)                 ; integers as bits
(srfi 66 octet-vectors)                ; octet vectors
(srfi 69 basic-hash-tables)            ; basic hash tables
(srfi 71 let)                          ; extensions of let, let*, letrec
(srfi 74 blobs)                        ; octet-addressed binary blocks
(srfi 95 sorting-and-merging)          ; sorting and merging</pre><p>ERR5RS libraries that are autoloadable but deprecated in Larceny
because they have been superseded by the R7RS and SRFI 99 record
facilities:</p><pre class="literallayout">(err5rs records procedural)            ; ERR5RS records (procedural API)
(err5rs records inspection)            ; ERR5RS records (inspection API)
(err5rs records syntactic)             ; ERR5RS records (syntactic API)
(err5rs load)                          ; ERR5RS load procedure</pre><p>Other autoloadable libraries:</p><pre class="literallayout">(larceny load)                         ; extension of (err5rs load)
(larceny compiler)                     ; separate compilation (R7RS/R6RS)
(larceny benchmarking)                 ; timing facilities
(larceny profiling)                    ; profiling of Scheme code
(larceny r7r6)                         ; all R7RS/R6RS standard libraries
(larceny records printer)              ; custom printing of records
(larceny shivers-syntax)               ; syntax favored by Olin Shivers
(r5rs)                                 ; approximates the R5RS top level
(explicit-renaming)                    ; macros with explicit renaming</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="R7rsLibraryVariableSection"></a>3.3.4. Library path</h4></div></div></div><p>Larceny's autoload feature locates R7RS/R6RS libraries
by performing a
<a class="link" href="#LibraryTranslationSection" title="5.4.&#xA0;Mapping library names to files (R7RS/R6RS)">depth-first search</a>
of the directories that belong to Larceny's
<a class="link" href="#current-require-path"><code class="literal">current-require-path</code></a>.
Libraries will not be autoloaded unless they are defined
in files whose names follow
<a class="link" href="#NamingChapter" title="5.&#xA0;File naming conventions">Larceny's standard conventions</a>.</p><p>The
<a class="link" href="#current-require-path"><code class="literal">current-require-path</code></a>
is initialized by the <code class="literal">startup.sch</code> file in Larceny's root
directory.</p><p><a class="link" href="#">Larceny's <code class="literal">-path</code> command-line option</a>
adds one or more directories to the directories in the
<a class="link" href="#current-require-path"><code class="literal">current-require-path</code></a>.
On most systems, you can specify multiple directories
by separating them with a colon; under Windows, use a
semicolon as separator instead.  The first directory
listed will be searched first.</p><p>The <a class="link" href="#"><code class="literal">LARCENY_LIBPATH</code></a>
environment variable can also be used to add one or more directories
to the directories in the
<a class="link" href="#current-require-path"><code class="literal">current-require-path</code></a>.
Multiple directories should be specified as with the <code class="literal">-path</code> option.</p><div class="tip" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Tip</h3><p>If you have a set of portable libraries that run under more than
one implementation of the R7RS, and you want to have a special
version of some of those libraries for Larceny, you can put all
your portable versions in one directory and the Larceny-specific
versions in another.  When you run Larceny, use the <code class="literal">-path</code>
option and specify the Larceny-specific directory first.</p></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The <code class="literal">-path</code> option cannot be used by Scheme scripts,
because command-line options are passed along to the Scheme
script without being interpreted by the <code class="literal">scheme-script</code> processor.</p></div><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>We emphasize that these extensions are non-portable.
Other implementations of the R7RS or R6RS may not provide
anything comparable to Larceny's <code class="literal">-path</code> option or
<code class="literal">LARCENY_LIBPATH</code> environment variable.
Even if they do, their mappings from library names
to file names may be incompatible with Larceny's.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="DefiningLibrariesSection"></a>3.3.5. Defining libraries</h4></div></div></div><p>As an extension to the R7RS and R6RS, Larceny allows a top-level
program or Scheme script to define R7RS/R6RS libraries within
the file that contains the top-level program or Scheme
script, before the import form that begins the top-level
program.  These libraries must be arranged so that no
library depends upon libraries that come later in the
file.</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>We emphasize that this extension is non-portable.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="R7rsPrimitivesSection"></a>3.3.6. Importing procedures from Larceny's underlying R5RS system</h4></div></div></div><p>Any of Larceny's R5RS-mode top-level procedures can be imported
into an R7RS or R6RS library or program by using an import
declaration with a <code class="literal">primitives</code> clause that names the R5RS
procedures to be imported.  For example:</p><pre class="screen">    (import (primitives random current-seconds
                        getenv setenv system
                        current-directory file-modification-time)
            (scheme time))</pre><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>This feature is highly non-portable.
Other implementations of the R7RS or R6RS may not even
have an underlying implementation of the R5RS.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="SchemeScriptsSection"></a>3.4. Scheme scripts</h3></div></div></div><p>On most Unix systems (including Linux and Apple's OS X), Larceny's
<code class="literal">scheme-script</code> will execute Scheme scripts as described in R6RS
non-normative appendix D, with or without the optional script
header.  To make Scheme scripts executable in their own
right, without executing <code class="literal">scheme-script</code> directly, add Larceny's
root directory to your path as described in <code class="literal">doc/HOWTO-INSTALL</code>,
or edit <code class="literal">scheme-script</code> to define <code class="literal">LARCENY_ROOT</code> and copy that
edited <code class="literal">scheme-script</code> to a directory in your path.</p><p>Suppose, for example, that <code class="literal">/home/myself/hello</code> is an R7RS/R6RS
Scheme script whose first line is the optional script header
shown below:</p><pre class="screen">#!/usr/bin/env scheme-script</pre><p>If you do not have execute permission for this script,
or Larceny's root directory is not in your path,
you can still run the script from
Larceny's root directory as follows:</p><pre class="screen">    % ./scheme-script /home/myself/hello</pre><p>If you have execute permission for the script, and Larceny's
root directory is in your path, you can also run the
script as follows:</p><pre class="screen">    % /home/myself/hello</pre><p>If, in addition, the directory that contains the script is
in your path, you can run the script as follows:</p><pre class="screen">    % hello</pre><p>You may also pass command-line arguments to a Scheme script.</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>We emphasize that Scheme scripts are not portable.
Scheme scripts are specified only by a non-binding appendix
to the R6RS, not by the R6RS proper.
Other implementations of the R7RS or R6RS may not support Scheme
scripts at all, or may give them a semantics incompatible
with Larceny's.</p></div><p>On Unix systems, standard input and output can be redirected
in the usual way.  In Larceny, standard input corresponds to
the textual port initially returned by <code class="literal">current-input-port</code>,
and standard output corresponds to the textual port initially
returned by <code class="literal">current-output-port</code>.</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>We emphasize that redirection of standard input and output
is non-portable.
Other implementations of the R7RS or R6RS may not allow redirection,
or may identify the standard input and output with ports
other than those initially returned by <code class="literal">current-input-port</code>
and <code class="literal">current-output-port</code>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R5rsScriptSection"></a>3.5. R5RS scripting</h3></div></div></div><p>Suppose <code class="literal">hello.sch</code> contains the following R5RS code:</p><pre class="screen">    (display "Hello world!")
    (newline)
    (exit)</pre><p>You can run <code class="literal">hello.sch</code> as a script by executing Larceny as
follows:</p><pre class="screen">    % larceny -nobanner -- hello.sch</pre><p>You can redirect Larceny's standard input, in which case
you may want to eliminate the herald announcement and the
read/eval/print loop's prompt:</p><pre class="screen">    % larceny -nobanner -- -e "(begin (herald #f) (repl-prompt values))" \
              &lt; hello.sch</pre><p>For an explanation of why that works, which may suggest other
creative uses of Larceny, ask for help:</p><pre class="screen">    % larceny -help</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ErrorsSection"></a>3.6. Errors</h3></div></div></div><p>In R6RS mode, which is batch-only, errors should result in an
error message followed by a clean exit from the program.</p><p>If your program encounters an error in an interactive mode
(R5RS or R75RS), it will enter the debugger; this is
believed to be a feature.</p><p>Despite its crudity, and to some extent because of it,
Larceny's debugger works at least as well with optimized
compiled code as with interpreted code.</p><p>If you type a question mark at the debugger prompt, the
debugger will print a help message.  That message is more
helpful if you understand the Twobit compiler and
Larceny's internal representations and invariants, but
this manual is not the place to explain those things.</p><p>The debugging context is saved so you can exit the debugger
and re-enter it from the main read/eval/print loop's prompt:</p><pre class="screen">    &gt; (debug)</pre><p>The debugger is pretty much a prototype; you don't need to
tell us how bad it is.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2530861"></a>3.7. Troubleshooting</h3></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2530866"></a>3.7.1. Errors when starting Larceny</h4></div></div></div><p>Although Larceny runs on x86-64 machines, it requires 32-bit
libraries that are not always installed on Linux and MacOS X
machines.  If those libraries are absent, the operating system
will probably give you a mysterious or misleading error message
when you try to run Larceny.  For example, the operating system's
loader may tell you "larceny.bin not found" even though it's
perfectly obvious that <code class="literal">larceny.bin</code> is present within Larceny's
root directory.  To install the necessary 32-bit libraries on
Linux machines with x86-compatible processors, someone with
superuser privileges must incant</p><pre class="screen">    sudo apt-get install lib32z1
    sudo apt-get install libc6-i386</pre><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>The names of those 32-bit packages have changed over time, and
may change again.</p></div><p>For Macintosh machines, someone with administrative privileges
must install the
<a class="ulink" href="https://developer.apple.com/opensource/" target="_top">Apple Developer Command Line Tools</a>.</p><p>When attempting to run an R7RS/R6RS program, you may see
a warning about "<code class="literal">loading source in favor of stale
fasl file</code>",
following by a long series of error messages about
syntactic keywords used as a variable, ending with
the kind of error you'd expect to see when a large
R7RS/R6RS program is fed to a Scheme compiler that was
expecting to see R5RS-compatible code.  That means
the R7RS/R6RS runtime and standard libraries were not
installed correctly, or their source files have been
touched or modified since they were last compiled.
To fix the problem,
<a class="link" href="#CompilingStdLibSection" title="2.5.&#xA0;Compiling the R7RS/R6RS standard libraries">recompile the R7RS standard libraries</a>.</p><p>The precompiled binary forms of Larceny should run on
most machines that use an appropriate processor and operating
system, but the executable program "<code class="literal">larceny.bin</code>" may be
incompatible with very old or with very new versions of
the processor or operating system.  If that appears to be
the case, you should see whether a newer version of Larceny
fixes the problem.  If not, please report the problem
to us at <code class="literal">larceny@ccs.neu.edu</code>.
Please report success stories as well.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2530986"></a>3.7.2. Errors when compiling the R7RS runtime</h4></div></div></div><p>If something goes wrong while
<a class="link" href="#CompilingStdLibSection" title="2.5.&#xA0;Compiling the R7RS/R6RS standard libraries">compiling the R7RS runtime</a>,
make sure you are running the copy of Larceny you think
you are running and have read and write permission
for <code class="literal">lib/R7RS</code>, <code class="literal">lib/R6RS</code>, <code class="literal">lib/SRFI</code>,
and all their subdirectories and files.
If you get an error message about something being
"<code class="literal">expanded against a different build of this library</code>",
then one or more of the compiled files in
<code class="literal">lib/R7RS</code> or <code class="literal">lib/R6RS</code> or <code class="literal">lib/SRFI</code>
or its subdirectories has gone
<a class="link" href="#CompilingChapter" title="6.&#xA0;Compiling files and libraries">stale</a>.
Removing all <code class="literal">.slfasl</code> files from <code class="literal">lib/R6RS</code> and <code class="literal">lib/SRFI</code> and
their subdirectories will eliminate the stale file(s).</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>Don't remove the <code class="literal">.sch</code>, <code class="literal">.scm</code>, <code class="literal">.sls</code>, or <code class="literal">.sld</code> files.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="AutoLoadErrorsSection"></a>3.7.3. Autoloading errors</h4></div></div></div><p>If Larceny attempts to autoload an imported R7RS/R6RS
library but cannot find the library, then the library
may be defined in a file that doesn't follow
<a class="link" href="#NamingChapter" title="5.&#xA0;File naming conventions">Larceny's standard naming conventions</a>.
Another possibility is that the <code class="literal">-path</code> option was
omitted or incorrect.</p><p>If an R7RS/R6RS library is recompiled, then all compiled
libraries and top-level programs that depend upon it must
also be recompiled.  In particular, recompiling the standard
R7RS runtime will invalidate all compiled libraries and
top-level programs.  Larceny's <code class="literal">compile-stale</code> script
and the
<a class="link" href="#compile-stale-libraries"><code class="literal">compile-stale-libraries</code></a>
procedure of <code class="literal">(larceny compiler)</code> make it convenient
to recompile all of the libraries and top-level
programs within any given directory in an order
consistent with their dependencies.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="CrashesSection"></a>3.7.4. Crashes</h4></div></div></div><p>Please report all crashes with as much information is possible;
a backtrace from a debugger or a core dump is ideal (but please
do not mail the core dump without contacting us first).
Larceny's run-time system is compiled with full debugging
information by default and a debugger like GDB should be able
to provide at least some clues.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="PerformanceSection"></a>3.8. Performance</h3></div></div></div><p>By default, Larceny's Twobit compiler performs several optimizations
that are fully compatible with the R7RS but may not be fully compatible
with the older R6RS, R5RS, and IEEE-1178 standards.</p><p>When compiling R5RS code, Larceny's Twobit compiler normally
makes several assumptions that allow it to generate faster code;
for example, the compiler assumes Scheme's standard
procedures will not be redefined.</p><p>To obtain strict conformance to R5RS semantics at
the expense of slower code, use R5RS mode and
evaluate the expression</p><pre class="screen">    (compiler-switches 'standard)</pre><p>To make the compiler generate faster code, you can promise not to
redefine standard procedures <span class="emphasis"><em>and</em></span> not to redefine any top-level
procedure while it is running. To make this promise, evaluate</p><pre class="screen">        (compiler-switches 'fast-safe)</pre><p>To view the current settings of Twobit's numerous compiler switches,
evaluate</p><pre class="screen">        (compiler-switches)</pre><p>All of Twobit's compiler switches are procedures whose setting
can be changed by passing the new value of the switch as an
argument.</p><p>For more information, evaluate</p><pre class="screen">        (help)</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>That <code class="literal">help</code> procedure is predefined only in R5RS mode, and
some of the help information that will be printed may be
irrelevant to the heap image you are using.</p></div><p>To alter the compiler switches from R7RS mode, or
to disable certain compiler optimizations that are
incompatible with the R6RS, see the section that
describes the
<a class="link" href="#LarcenyCompilerSection" title="9.2.&#xA0;Compiler"><code class="literal">(larceny compiler)</code> library</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="LexicalChapter"></a>4. Lexical syntax</h2></div></div></div><p>Larceny's default lexical syntax extends the lexical syntax
required by the R5RS, R6RS, and R7RS <a class="link" href="#Standards" title="13.&#xA0;Standards">standards</a>.</p><p>The R6RS forbids most lexical extensions, however, so Larceny
provides several mechanisms for turning its lexical extensions
on and off.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="FlagsSection"></a>4.1. Flags</h3></div></div></div><p>By default, Larceny recognizes several Larceny-specific flags
of the form permitted by the R6RS.  The flag you are most
likely to encounter represents one of Larceny's unspecified
values:</p><pre class="screen">    #!unspecified</pre><p>Certain other flags have special meanings to Larceny's
<code class="literal">read</code> and <code class="literal">get-datum</code> procedures.  They are described below.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="CaseFoldingSection"></a>4.2. Case-sensitivity</h3></div></div></div><p>By default, Larceny is case-sensitive.
This global default can be overridden by specifying
<code class="literal">—foldcase</code> or <code class="literal">—nofoldcase</code> on Larceny's command line,
or by changing the value of Larceny's <code class="literal">case-sensitive?</code> parameter.</p><p>The case-sensitivity of a particular textual input port
is affected by reading one of the following flags from
the port using the <code class="literal">read</code> or <code class="literal">get-datum</code> procedures:</p><pre class="screen">    #!fold-case
    #!no-fold-case</pre><p>The <code class="literal">#!fold-case</code> flag enables case-folding on data read from
the port by the <code class="literal">read</code> and <code class="literal">get-datum</code> procedures, while the
<code class="literal">#!no-fold-case</code> flag disables case-folding.  The behavior
established by one of these flags extends to the next such flag
read from the port by <code class="literal">read</code> or <code class="literal">get-datum</code>.</p><p>Both <code class="literal">#!fold-case</code> and <code class="literal">#!no-fold-case</code> are treated as comments
by Larceny's <code class="literal">read</code> and <code class="literal">get-datum</code> procedures.  (This is a change
from Larceny v0.97.)</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="LexicalExtensionsSection"></a>4.3. Lexical extensions</h3></div></div></div><p>When a port is first opened, the Larceny-specific lexical
extensions that are accepted on the port are determined
by Larceny's <a class="link" href="#LexicalParametersSection" title="4.4.&#xA0;Lexical parameters">lexical parameters</a>.</p><p>The following flags change the case-sensitivity and lexical
extensions on the specific port from which they are read:</p><pre class="screen">    #!r7rs         ; implies #!no-fold-case, enables R7RS syntax
    #!r6rs         ; implies #!no-fold-case, negates other flags
    #!r5rs         ; implies #!fold-case, enables R7RS syntax
    #!err5rs       ; enables R7RS/R6RS syntax with extensions
    #!larceny      ; implies #!no-fold-case and #!err5rs</pre><p>All of those flags are treated as comments by Larceny's <code class="literal">read</code>
and <code class="literal">get-datum</code> procedures.  (This is a change from Larceny
v0.97.)</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The <code class="literal">#!r6rs</code> flag is the only flag that <span class="emphasis"><em>disables</em></span> lexical
extensions.  To disable R6RS lexical extensions when new ports
are created, use the
<a class="link" href="#LexicalParametersSection" title="4.4.&#xA0;Lexical parameters"><code class="literal">read-r6rs-weirdness?</code> parameter</a>
described below.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="LexicalParametersSection"></a>4.4. Lexical parameters</h3></div></div></div><p>When given no argument, these parameters return the current
default for some aspects of the lexical syntax that will be
accepted on newly created input ports or written to newly
created output ports.
When given an argument, these procedures change the default
as specified by the argument.</p><p>The initial values of these parameters are determined by the
<code class="literal">-r7r6</code>, <code class="literal">-r7rs</code>, <code class="literal">-r6rs</code>, or <code class="literal">-r5rs</code> options on Larceny's
command line.  The <code class="literal">-r6rs</code> option disables non-R6RS lexical
syntax; the <code class="literal">-r7r6</code>, <code class="literal">-r7rs</code>, and <code class="literal">-r5rs</code> options allow both
R7RS and R6RS syntax.</p><p><a id="case-sensitive?"></a>
<span class="emphasis"><em> Procedure case-sensitive?</em></span>
<p>
<a id="id2531667" class="indexterm"></a>
<code class="literal">(case-sensitive? <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p>
<p><code class="literal">(case-sensitive? <span class="emphasis"><em>boolean</em></span>) </code></p></p><p>If true, newly created textual input ports behave as though they
began with <code class="literal">!fold-case</code>.  If false, newly created textual input
ports behave as though they began with <code class="literal">!no-fold-case</code>.</p><p><a id="read-r6rs-flags?"></a>
<span class="emphasis"><em> Procedure read-r6rs-flags?</em></span>
<p>
<a id="id2531726" class="indexterm"></a>
<code class="literal">(read-r6rs-flags? <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p>
<p><code class="literal">(read-r6rs-flags? <span class="emphasis"><em>boolean</em></span>) </code></p></p><p>If true, allows flags other than <code class="literal">!r6rs</code> to be read from
newly created ports.
If false, flags other than <code class="literal">!r6rs</code> raise exceptions when
read.</p><p><a id="read-r7rs-weirdness?"></a>
<span class="emphasis"><em> Procedure read-r7rs-weirdness?</em></span>
<p>
<a id="id2531783" class="indexterm"></a>
<code class="literal">(read-r7rs-weirdness? <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p>
<p><code class="literal">(read-r7rs-weirdness? <span class="emphasis"><em>boolean</em></span>) </code></p></p><p>If true, newly created textual input ports behave as though they
began with <code class="literal">#!r7rs</code>, and R7RS lexical syntax will be used when
writing external representations to newly created textual output
ports.
If false, R7RS-specific extensions to R5RS/R6RS lexical syntax
may raise exceptions.</p><p><a id="read-r6rs-weirdness?"></a>
<span class="emphasis"><em> Procedure read-r6rs-weirdness?</em></span>
<p>
<a id="id2531839" class="indexterm"></a>
<code class="literal">(read-r6rs-weirdness? <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p>
<p><code class="literal">(read-r6rs-weirdness? <span class="emphasis"><em>boolean</em></span>) </code></p></p><p>If true, allows all R6RS lexical syntax on newly created ports
without disabling other lexical syntax on those ports (so
newly created textual input ports <span class="emphasis"><em>do not</em></span> behave as though
they began with <code class="literal">#!r6rs</code>).
If false, R6RS-specific extensions to R5RS/R7RS lexical syntax
may raise exceptions.</p><p>If <code class="literal">read-r6rs-weirdness?</code> is true and <code class="literal">read-r7rs-weirdness?</code>
is false, then the R6RS bytevector syntax will be used when
writing to newly opened textual output ports.  If neither
or both are true, then R7RS bytevector syntax will be used.</p><p><a id="read-larceny-weirdness?"></a>
<span class="emphasis"><em> Procedure read-larceny-weirdness?</em></span>
<p>
<a id="id2531916" class="indexterm"></a>
<code class="literal">(read-larceny-weirdness? <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p>
<p><code class="literal">(read-larceny-weirdness? <span class="emphasis"><em>boolean</em></span>) </code></p></p><p>Determines whether newly created textual ports allow
Larceny's usual extensions to R5RS lexical syntax.
In addition, this parameter determines whether newly created
ports allow <code class="literal">#</code> as an insignificant digit, which is
required by the R5RS but disallowed by the R6RS and not
required by the R7RS.</p><p><a id="read-traditional-weirdness?"></a>
<span class="emphasis"><em> Procedure read-traditional-weirdness?</em></span>
<p>
<a id="id2531972" class="indexterm"></a>
<code class="literal">(read-traditional-weirdness? <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p>
<p><code class="literal">(read-traditional-weirdness? <span class="emphasis"><em>boolean</em></span>) </code></p></p><p>Determines whether newly created textual ports allow
certain lexical extensions that are deprecated in Larceny.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The semantics of <code class="literal">read-larceny-weirdness?</code> and
<code class="literal">read-traditional-weirdness?</code> will change over time as
deprecated misfeatures are added or dropped in response to
popular demand or apathy.
For the current semantics of these parameters, please consult
the Larceny developers' web page that describes
<a class="ulink" href="https://github.com/larcenists/larceny/wiki/LexicalConversion" target="_top">Larceny's
lexical syntax</a>.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="NamingChapter"></a>5. File naming conventions</h2></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="SuffixSection"></a>5.1. Suffixes</h3></div></div></div><p>In Larceny, file names generally follow Unix conventions,
even on Windows.  The following suffixes have special
meanings to some components of Larceny.</p><div class="variablelist"><dl><dt><span class="term">
<code class="literal">.sld</code>
</span></dt><dd>
is the preferred suffix for files that contain libraries
defined by the R7RS <code class="literal">define-library</code> syntax.
</dd><dt><span class="term">
<code class="literal">.sls</code>
</span></dt><dd>
is the preferred suffix for files that contain libraries
defined by the R6RS <code class="literal">library</code> syntax.
</dd><dt><span class="term">
<code class="literal">.sps</code>
</span></dt><dd>
is the preferred suffix for files that contain R7RS/R6RS
top-level programs (which consist of an <code class="literal">import</code> declaration
followed by definitions and expressions).
</dd><dt><span class="term">
<code class="literal">.scm</code>
</span></dt><dd>
is the preferred suffix for files that contain R7RS/R5RS
definitions and expressions but don't contain any <code class="literal">import</code>
declarations and don't define any R7RS/R6RS libraries.
</dd><dt><span class="term">
<code class="literal">.sch</code>
</span></dt><dd>
is an alternative to <code class="literal">.scm</code> used by Larceny developers.
</dd><dt><span class="term">
<code class="literal">.slfasl</code>
</span></dt><dd>
is the suffix for files that contain the compiled form of
a <code class="literal">.sld</code>, <code class="literal">.sls</code>, or <code class="literal">.sps</code> file.
</dd><dt><span class="term">
<code class="literal">.fasl</code>
</span></dt><dd>
is the suffix for files that contain the compiled form of
R5RS source code (usually <code class="literal">.scm</code> or <code class="literal">.sch</code>).
</dd><dt><span class="term">
<code class="literal">.mal</code>
</span></dt><dd>
is the preferred suffix for files that contain MacScheme
assembly language in symbolic form.
</dd><dt><span class="term">
<code class="literal">.lap</code>
</span></dt><dd>
is the suffix for files that contain MacScheme assembly language.
</dd><dt><span class="term">
<code class="literal">.lop</code>
</span></dt><dd>
is the suffix for files that contain machine code
segments in the form expected by Larceny's heap linker.
</dd><dt><span class="term">
<code class="literal">.heap</code>
</span></dt><dd>
is the suffix for files that contain an executable heap
image (must be combined with the
<a class="link" href="#InstallationSection" title="2.4.&#xA0;Installing the programs"><code class="literal">larceny.bin</code></a> runtime).
</dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>In Larceny, R7RS <code class="literal">define-library</code> and R6RS <code class="literal">library</code> syntaxes
are mostly interchangeable.  The R6RS <code class="literal">for</code> and <code class="literal">meta</code> keywords
may be needed when defining <code class="literal">syntax-case</code> macros, but the R7RS
syntax is otherwise more versatile because of its <code class="literal">include</code> and
<code class="literal">cond-expand</code> features.  For new code, we recommend the R7RS
<code class="literal">define-library</code> syntax.</p></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Although the R7RS <code class="literal">define-library</code> syntax allows <code class="literal">export</code> and
<code class="literal">import</code> declarations to be placed anywhere at the top level of
the syntax, it is standard practice to use only one <code class="literal">export</code>
declaration per library, placed immediately following the name
of the library, and to use only one <code class="literal">import</code> declaration per
library, placed immediately following the <code class="literal">export</code> declaration.</p></div><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>Some of Larceny's compilation tools rely upon the convention
described within the note above, and may not work if that
convention is not followed.</p></div><div class="tip" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Tip</h3><p>An R7RS library definition may be split into two or more files,
with the primary <code class="literal">.sld</code> file containing one or more <code class="literal">include</code>
declarations that include <code class="literal">.scm</code> files.  If <code class="literal">foo.sld</code> is the
primary file, then the included file is ordinarily named
<code class="literal">foo.body.scm</code> and placed within the same directory as <code class="literal">foo.sld</code>.
If more than one <code class="literal">.scm</code> file is included, we recommend
<code class="literal">foo.body1.scm</code>, <code class="literal">foo.body2.scm</code>, and so on.  A Larceny-specific
version of <code class="literal">foo.body2.scm</code> that's conditionally included using
the <code class="literal">cond-expand</code> feature might be named <code class="literal">foo.body2.larceny.scm</code>.</p></div><div class="tip" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Tip</h3><p>Portable source code can be tailored to Larceny and other
implementations of the R7RS by combining implementation-specific
mechanisms such as Larceny's <code class="literal">-path</code> option with the <code class="literal">include</code>
and <code class="literal">cond-expand</code> features of R7RS libraries.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="DirectorySection"></a>5.2. Directories</h3></div></div></div><p>Larceny's root directory should contain the following
files:</p><pre class="screen">    larceny
    scheme-script
    larceny.bin
    larceny.heap
    startup.sch</pre><p>The following subdirectories are also essential for correct
operation of some features of some modes in some varieties of
Larceny:</p><pre class="screen">    include
    lib
    lib/Base
    lib/Debugger
    lib/Ffi
    lib/MzScheme
    lib/R6RS
    lib/SRFI
    lib/Standard
    lib/TeachPacks</pre><p>The <code class="literal">include</code> subdirectory is used when compiling files with
Petit Larceny.</p><p>The <code class="literal">startup.sch</code> file tells Larceny's <code class="literal">require</code> procedure to
search some of the <code class="literal">lib</code> subdirectories for libraries that are
loaded dynamically.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="LibraryResolutionSection"></a>5.3. Resolving references to libraries</h3></div></div></div><p>The R7RS and R6RS standards do not specify any mapping from
library names to files or other locations at which the code
for a library might be found.</p><p>R6RS non-normative appendix E emphasizes the arbitrariness of
such mappings:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>Implementations may take radically different approaches to
storing source code for libraries, among them: files in the
file system where each file contains an arbitrary number of
library forms, files in the file system where each file
contains exactly one library form, records in a database,
and data structures in memory.</p><p>Similarly, programs and scripts may be stored in a variety of
formats. Platform constraints may restrict the choices available
to an implementation, which is why the report neither mandates
nor recommends a specific method for storage.</p><p>Implementations may provide a means for importing libraries….</p><p>Similarly, implementations may provide a means for executing a
program represented as a UTF-8 text file containing its source
code….</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">
</span></td></tr></table></div><p>To put it more starkly:</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>Although implementations of the R6RS <span class="emphasis"><em>may</em></span> "provide a means for
importing libraries" or "executing a program", they don't have
to.</p></div><p>R7RS section 5.1 urges implementations to be reasonable:</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>Implementations which store libraries in files should document
the mapping from the name of a library to its location in the
file system.</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">
</span></td></tr></table></div><p>Fortunately, <span class="emphasis"><em>de facto</em></span> standards have been emerging.
Larceny supports those <span class="emphasis"><em>de facto</em></span> standards by providing these
Larceny-specific mechanisms:</p><div class="orderedlist"><ol type="1"><li>
R7RS/R6RS standard libraries may be imported.
Their code is located automagically.
</li><li>
Nonstandard libraries, such as <code class="literal">(larceny compiler)</code>,
may be placed in one of the directories searched
by Larceny's
<a class="link" href="#">autoload</a> feature, provided
those libraries are located in files that follow Larceny's
standard naming conventions as described in
<a class="link" href="#LibraryTranslationSection" title="5.4.&#xA0;Mapping library names to files (R7RS/R6RS)">the next section</a>.
</li><li>
R7RS/R6RS top-level programs may use
<a class="link" href="#">Larceny's <code class="literal">-path</code> option</a>
to specify directories that contain other libraries
the program may import, provided those libraries are
located in files that follow Larceny's standard naming
conventions as described in
<a class="link" href="#LibraryTranslationSection" title="5.4.&#xA0;Mapping library names to files (R7RS/R6RS)">the next section</a>.
</li><li>
R7RS/R6RS top-level programs may use
<a class="link" href="#R7rsLibraryVariableSection" title="3.3.4.&#xA0;Library path">Larceny's <code class="literal">LARCENY_LIBPATH</code> environment variable</a>
to specify directories that contain other libraries
the program may import, provided those libraries are
located in files that follow Larceny's standard naming
conventions as described in
<a class="link" href="#LibraryTranslationSection" title="5.4.&#xA0;Mapping library names to files (R7RS/R6RS)">the next section</a>.
</li><li>
R7RS/R6RS top-level programs and Scheme scripts may
<a class="link" href="#DefiningLibrariesSection" title="3.3.5.&#xA0;Defining libraries">define their own libraries</a>
in the same file that contains the top-level program or
Scheme script.
</li></ol></div><p>R7RS programs may use any of those five mechanisms,
and may also use a sixth mechanism:
An R7RS program can be written as a little configuration
program that loads the program's libraries from files
before any libraries are imported.  This sixth mechanism
appears to be portable, but is not available to
R6RS programs executing in Larceny's R6RS mode because
it mixes execution with macro expansion, which is
explicitly forbidden by one of the R6RS standard's
"absolute requirements".</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="LibraryTranslationSection"></a>5.4. Mapping library names to files (R7RS/R6RS)</h3></div></div></div><p>Suppose Larceny's <code class="literal">-path</code> option is used to specify
a certain <span class="emphasis"><em>directory</em></span>, and the program imports a
nonstandard library whose name is of the form
<code class="literal">(<span class="emphasis"><em>name1</em></span> <span class="emphasis"><em>name2</em></span> … <span class="emphasis"><em>lastname</em></span>)</code>.
Larceny will search for that library in the following
files:</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>/…/<span class="emphasis"><em>lastname</em></span>.larceny.slfasl</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>/…/<span class="emphasis"><em>lastname</em></span>.larceny.sld</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>/…/<span class="emphasis"><em>lastname</em></span>.larceny.sls</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>/…/<span class="emphasis"><em>lastname</em></span>.slfasl</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>/…/<span class="emphasis"><em>lastname</em></span>.sld</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>/…/<span class="emphasis"><em>lastname</em></span>.sls</code>
</li><li>
…
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>.larceny.slfasl</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>.larceny.sld</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>.larceny.sls</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>.slfasl</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>.sld</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>/<span class="emphasis"><em>name2</em></span>.sls</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>.larceny.slfasl</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>.larceny.sld</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>.larceny.sls</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>.slfasl</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>.sld</code>
</li><li>
<code class="literal"><span class="emphasis"><em>directory</em></span>/<span class="emphasis"><em>name1</em></span>.sls</code>
</li></ul></div><p>The search starts with the first of those file names,
continues with the following file names in order,
and ends when a file with one of those names is found.
The imported library <span class="emphasis"><em>must</em></span> be one of the libraries
defined within the first file found by this search,
since the search is not continued after that first file
is found (except as noted in the next paragraph).</p><p>If the search ends by finding a file whose name ends
with <code class="literal">.slfasl</code>, then Larceny checks to see whether
there is a file in the same directory with the same
root name but ending with <code class="literal">.sld</code> or <code class="literal">.sls</code> instead of <code class="literal">.slfasl</code>.
If the <code class="literal">.sld</code> or <code class="literal">.sls</code> file has been modified since the <code class="literal">.slfasl</code>
file was last modified, then a warning is printed and
the <code class="literal">.sld</code> or <code class="literal">.sls</code> file is loaded instead of the <code class="literal">.slfasl</code> file.
Otherwise the <code class="literal">.slfasl</code> file is loaded.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The R6RS allows arbitrary mappings from library names to library
code.  Larceny takes advantage of this by ignoring version
numbers when mapping library names to files, and by (virtually)
rewriting any version number that may be specified in the
definition of a library so it matches any version specification
that appears within the <code class="literal">import</code> form.  Furthermore Larceny
allows different versions of the same library to be imported,
but Larceny's algorithm for resolving library references
ensures that the different versions of a library will be
identical except for their version numbers, which have no
meaningful semantics.  Although Larceny's treatment of versions
conforms to the R6RS specification, it should be clear that
version numbers serve no purpose in Larceny.  Since the R6RS
version feature has no usefully portable semantics and has
been ignored by most implementations of the R6RS, it is
deprecated.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="RequireLibraryTranslationSection"></a>5.5. Mapping library names to files (R5RS)</h3></div></div></div><p>In R5RS mode, Larceny's <code class="literal">-path</code> option
and <code class="literal">LARCENY_LIBPATH</code> environment variable
may be used to
specify directories to be searched by the <code class="literal">require</code>
procedure, which takes a single symbol <span class="emphasis"><em>libname</em></span> as
its argument.
The <code class="literal">require</code> procedure will search for the following
files in every directory that is part of the current
require path, starting with the directories specified
by LARCENY_LIBPATH and the <code class="literal">-path</code> option:</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal"><span class="emphasis"><em>libname</em></span>.fasl</code>
</li><li>
<code class="literal"><span class="emphasis"><em>libname</em></span>.sch</code>
</li><li>
<code class="literal"><span class="emphasis"><em>libname</em></span>.scm</code>
</li></ul></div><p>These files are expected to contain R5RS code, not
library definitions.  Otherwise the search proceeds
much the same as when searching for an R7RS/R6RS
library.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The <code class="literal">require</code> path is specified by <code class="literal">startup.sch</code> in Larceny's
root directory, but may be changed dynamically using the
<code class="literal">current-require-path</code> parameter.  Changing the <code class="literal">require</code> path
is not recommended, however, because Larceny relies on the
<code class="literal">require</code> path for dynamic loading of libraries used by several
important features of Larceny, notably R7RS and R6RS modes.</p></div><p><a id="require"></a>
<span class="emphasis"><em> Procedure require</em></span>
<p>
<a id="id2533593" class="indexterm"></a>
<code class="literal">(require <span class="emphasis"><em>libname</em></span>) </code>
</p></p><p><span class="emphasis"><em>libname</em></span> must be a symbol that names an R5RS-compatible
library within the current require path.</p><p>If the library has not already been loaded, then it is
located and loaded.  If the library is found and loaded
successfully, then <code class="literal">require</code> returns true; otherwise an
error is signalled.</p><p>If the library has already been loaded, then <code class="literal">require</code>
returns false without loading the library a second time.</p><p><a id="current-require-path"></a>
<span class="emphasis"><em> Procedure current-require-path</em></span>
<p>
<a id="id2533656" class="indexterm"></a>
<code class="literal">(current-require-path <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>stringlist</em></span></code>
</p>
<p><code class="literal">(current-require-path <span class="emphasis"><em>stringlist</em></span>) </code></p></p><p>The optional argument is a list of directory names
(without slashes at the end) that should be searched
by <a class="link" href="#require"><code class="literal">require</code></a> and (in R7RS/R6RS modes)
by Larceny's <a class="link" href="#">autoload</a>
feature.
Returns the list of directory names that will be
searched.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="CompilingChapter"></a>6. Compiling files and libraries</h2></div></div></div><p>This chapter explains how you can use Larceny to compile
Scheme source code to native machine code.</p><p>The native varieties of Larceny have a just-in-time
compiler that compiles to native code automatically
whenever you evaluate an expression, load a source
file, or import a source library.  Even so, files
will load faster if they are compiled ahead of time.</p><p>Petit Larceny does not have a just-in-time compiler,
so compiling ahead of time is the only way to enjoy
the speed of native machine code in Petit Larceny.</p><p>The main disadvantage of compiling files and libraries
is that compiled code goes <span class="emphasis"><em>stale</em></span> when its original
source code is changed or when a library on which
the compiled code depends is changed or recompiled.
Stale compiled code can be dangerously inconsistent
with libraries on which it depends, so Larceny checks
for staleness and refuses to execute a stale library
or program.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="CompilingR7rsSection"></a>6.1. Compiling R7RS/R6RS libraries</h3></div></div></div><p>On Unix machines, the most convenient way to compile
a group of R7RS/R6RS libraries and top-level programs
is to use the <code class="literal">compile-stale</code> script in Larceny's root
directory.
If Larceny's root directory is in your execution path,
then there are just two steps:</p><div class="orderedlist"><ol type="1"><li>
Use <code class="literal">cd</code> to change to the directory that contains
the R7RS/R6RS files you want to compile.  (Files
that lie within subdirectories of that directory will
be compiled also.)
</li><li>
Run the <code class="literal">compile-stale</code> script.
</li></ol></div><p>For example:</p><pre class="screen">    % cd lib/R7RS
    % compile-stale</pre><p>On non-Unix machines, you can accomplish the same thing
using Larceny's R7RS mode and the <code class="literal">(larceny compiler)</code>
library:</p><pre class="screen">    % pushd lib\R7RS
    % ../../larceny -r7rs
    Larceny v0.98 "General Ripper"

    &gt; (import (larceny compiler))

    &gt; (compile-stale-libraries)</pre><p>To compile individual files, use the <code class="literal">compile-file</code> or
<code class="literal">compile-library</code> procedures that are exported by
<a class="link" href="#LarcenyCompilerSection" title="9.2.&#xA0;Compiler"><code class="literal">(larceny compiler)</code></a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="CompilingR5rsSection"></a>6.2. Compiling R5RS source files</h3></div></div></div><p><a id="compile-file"></a>
<span class="emphasis"><em> Procedure compile-file</em></span>
<p>
<a id="id2533892" class="indexterm"></a>
<code class="literal">(compile-file <span class="emphasis"><em>sourcefile</em></span>) </code>
</p></p><p>Compiles <span class="emphasis"><em>sourcefile</em></span>, which must be a string naming
a file that contains R5RS source code.
If <span class="emphasis"><em>faslfile</em></span> is supplied as a second argument,
then it must be a string naming the file that will
contain the compiled code; otherwise the name of
the compiled file is obtained from <span class="emphasis"><em>sourcefile</em></span>
by replacing the "<code class="literal">.sch</code>" or "<code class="literal">.scm</code>" suffix with
"<code class="literal">.fasl</code>".</p><p>For R7RS/R6RS libraries and top-level programs,
<a class="link" href="#">see above</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="R7rsChapter"></a>7. R7RS standard libraries</h2></div></div></div><p>The R7RS standard libraries are described by
<a class="link" href="#Standards" title="13.&#xA0;Standards">the R7RS (small) standard</a> approved in 2013.</p><p>Larceny provides all of the R7RS standard libraries,
supports the full numeric tower, and can represent all
Unicode characters.</p><p>Binary releases of Larceny also support Unicode strings.
(When built from source code, Larceny can be configured to
use Latin-1 strings instead of Unicode.)</p><p>When Larceny is invoked with the <code class="literal">-r7r6</code> option on its
command line, all of the standard R7RS and R6RS libraries
are imported at startup.  When invoked with the <code class="literal">-r7rs</code>
option, only <code class="literal">(scheme base)</code> is imported at startup.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2534009"></a>7.1. Known deviations from the R7RS standard</h3></div></div></div><p>Larceny v0.98 does not implement these features of
the R7RS standard:</p><div class="itemizedlist"><ul type="disc"><li>
the second (arbitrary ellipsis) form of <code class="literal">syntax-rules</code>
  described in R7RS section 4.3.2
</li><li>
<code class="literal">include</code> and <code class="literal">include-ci</code> at expression level
</li><li>
<code class="literal">cond-expand</code> at expression level
</li></ul></div><p><code class="literal">include</code>, <code class="literal">include-ci</code>, and <code class="literal">cond-expand</code> are fully supported
at the top-level declaration and definition levels of R7RS
libraries.</p><p>To simplify interoperability with R6RS libraries and
programs, the <code class="literal">integer?</code>, <code class="literal">rational?</code>, and <code class="literal">real?</code>
procedures exported by <code class="literal">(scheme base)</code> have R6RS semantics.
It is not clear whether that is fully compatible with the
R7RS (small) standard, because the R7RS specification of
those procedures appears to contradict itself.</p><p>If any other R7RS feature is missing or incompatible with
the R7RS (small) standard, it's a bug.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="R6rsChapter"></a>8. R6RS standard libraries</h2></div></div></div><p>This chapter explains which features of the R6RS standard
libraries are available in each of Larceny's major modes
of execution.</p><p>Larceny was the first substantially complete implementation
of the R6RS.  Any features that are missing from R6RS modes
are missing because of bugs or because the features are
deprecated in Larceny.</p><p>Larceny is R6RS-compatible but not R6RS-conforming.
When Larceny is said to support a feature of the R6RS,
that means the feature is present and will behave as
specified by the R6RS so long as no exception is raised
or expected.
Larceny does not always raise the specific conditions
specified by the R6RS, and does not perform all of the
checking for portability problems that is mandated by
the R6RS.  These deviations do not affect the execution
of production code, and do not compromise Larceny's
traditional safety.</p><p>For example, Larceny has extended the R6RS <code class="literal">library</code> syntax to
allow R6RS libraries to import R7RS libraries even when the
names of those imported libraries use the more liberal R7RS
syntax.</p><p>Furthermore, Larceny has extended several R6RS procedures so
they behave as specified by the newer R7RS (small) standard.
In Larceny, for example, the <code class="literal">utf8-&gt;string</code> procedure
accepts one, two, or three arguments,
and the <code class="literal">finite?</code> procedure accepts any object as its argument.
According to the R6RS, <code class="literal">utf8-&gt;string</code> <span class="emphasis"><em>must</em></span> raise an
exception when passed more than one argument, and
<code class="literal">finite?</code> <span class="emphasis"><em>must</em></span> raise an exception if it detects an
argument that is not a real number.  Although the R6RS
says these exceptions are "absolute requirements", they
interfere with interoperability between R6RS and R7RS code,
and are best honored in the breach.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsBaseSection"></a>8.1. Base library</h3></div></div></div><p>R7RS and R6RS modes support all procedures and syntaxes
exported by the <code class="literal">(rnrs base)</code> library.</p><p>Larceny's R5RS mode does not support <code class="literal">library</code>, <code class="literal">import</code>, or
<code class="literal">identifier-syntax</code>.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The semantics of <code class="literal">quasiquote</code>, <code class="literal">let-syntax</code>, and <code class="literal">letrec-syntax</code>
differ between the R5RS, R6RS, and R7RS.  Larceny's R5RS mode
still supports the R5RS semantics.  R7RS and R6RS modes support
the R6RS semantics.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsUnicodeSection"></a>8.2. Unicode</h3></div></div></div><p>All of Larceny's modes support all features of the <code class="literal">(rnrs unicode)</code>
library.</p><p>Larceny v0.98 tries to conform to
<a class="link" href="#Standards" title="13.&#xA0;Standards">The Unicode Standard</a>, Version 7.0.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsBytevectorsSection"></a>8.3. Bytevectors</h3></div></div></div><p>R7RS and R6RS modes support all procedures and syntaxes
exported by <code class="literal">(rnrs bytevectors)</code>, but the <code class="literal">endianness</code>
syntax is deprecated because it is redundant with <code class="literal">quote</code>.
Larceny's R5RS mode does not support <code class="literal">endianness</code>.</p><p>In Larceny, any symbol names a supported endianness.
The symbols <code class="literal">big</code> and <code class="literal">little</code> have their expected meanings.
All other symbols mean <code class="literal">(native-endianness)</code> with respect
to integer operations, but mean the opposite of
<code class="literal">(native-endianness)</code> with respect to
<a class="link" href="#Standards" title="13.&#xA0;Standards">IEEE-754</a> operations.
For string operations, the endianness must be the symbol
<code class="literal">big</code> or the symbol <code class="literal">little</code>.  All of these extensions are
permitted by the R6RS standard.</p><p>Larceny's <code class="literal">utf16-&gt;string</code> and <code class="literal">utf32-&gt;string</code> accept one,
two, or three arguments.  The R6RS specification of these
procedures does not allow them to accept a single argument,
but that is believed to be an error in the R6RS.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsListsSection"></a>8.4. Lists</h3></div></div></div><p>All of Larceny's modes support all features of the
<code class="literal">(rnrs lists)</code> library.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsSortingSection"></a>8.5. Sorting</h3></div></div></div><p>All of Larceny's modes support all features of the
<code class="literal">(rnrs sorting)</code> library.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsControlSection"></a>8.6. Control</h3></div></div></div><p>All of Larceny's modes support all features of the
<code class="literal">(rnrs control)</code> library.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsRecordsSection"></a>8.7. Records</h3></div></div></div><p>R7RS and R6RS modes support all procedures and syntaxes
exported by
<code class="literal">(rnrs records procedural)</code>,
<code class="literal">(rnrs records inspection)</code>, and
<code class="literal">(rnrs records syntactic)</code>.</p><p>Those libraries are deprecated, however;
the <code class="literal">make-record-constructor-descriptor</code> procedure does
not simplify unusually complex cases enough to justify
the complexity it adds to typical cases, and
the entire syntactic layer is gratuitously incompatible
with the procedural layer.</p><p>Larceny extends the R7RS <code class="literal">define-record-type</code> syntax exported
by <code class="literal">(scheme base)</code> to accept the deprecated R6RS syntax, and
extends the deprecated <code class="literal">define-record-type</code> syntax exported
by <code class="literal">(rnrs records syntactic)</code> to accept R7RS syntax.
Larceny's unification of the two syntaxes within a single
implementation of <code class="literal">define-record-type</code> allows libraries and
programs to import both <code class="literal">(scheme base)</code> and <code class="literal">(rnrs)</code> without
having to rename one version of <code class="literal">define-record-type</code>.</p><p>Larceny also extends its unified R7RS/R6RS <code class="literal">define-record-type</code>
to support all features of <code class="literal">(srfi :99 records syntactic)</code>.
So long as the deprecated R6RS syntax is not used, Larceny's
<code class="literal">define-record-type</code> is fully compatible with the procedural
layers defined by <code class="literal">(srfi :99 records procedural)</code> and by
<code class="literal">(rnrs records procedural)</code>.</p><p>Larceny's R5RS mode supports all features of the deprecated
<code class="literal">(rnrs records procedural)</code> and <code class="literal">(rnrs records inspection)</code>
libraries.  R5RS mode does not support <code class="literal">(rnrs records syntactic)</code>.</p><p>All of Larceny's modes support all features of the
<a class="link" href="#Err5rsRecordsProceduralSection" title="10.2.1.&#xA0;Procedural layer"><code class="literal">(err5rs records procedural)</code></a>
and
<a class="link" href="#Err5rsRecordsInspectionSection" title="10.2.2.&#xA0;Inspection layer"><code class="literal">(err5rs records inspection)</code></a>
libraries.  R7RS and R6RS modes also support the
<a class="link" href="#Err5rsRecordsSyntacticSection" title="10.2.3.&#xA0;Syntactic layer"><code class="literal">(err5rs records syntactic)</code></a>
library.
These libraries are equivalent to the
<code class="literal">(srfi :99 records procedural)</code>,
<code class="literal">(srfi :99 records inspection)</code>, and
<code class="literal">(srfi :99 records syntactic)</code> libraries.</p><p>The record definition syntax of
<a class="ulink" href="http://srfi.schemers.org/srfi-9/" target="_top">SRFI 9</a>
is a proper subset
of the syntax provided by the <code class="literal">(err5rs records syntactic)</code>
library.  In R5RS mode, SRFI 9 can be loaded dynamically
using the
<a class="link" href="#require"><code class="literal">require</code></a> procedure:</p><pre class="screen">    &gt; (require 'srfi-9)</pre><p>We recommend the R7RS and/or SRFI 9 libraries be used instead
of the corresponding R6RS libraries.</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>The R6RS spouts some tendentious nonsense about procedural
records being slower than syntactic records, but this is not
true of Larceny's records, and is unlikely to be true of other
implementations either.</p></div><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>Larceny continues to support its old-style
records, which are almost but not quite compatible
with R7RS and R6RS records.  This can be confusing,
since some of Larceny's procedures have the same names
as R6RS procedures.  That has made it necessary to overload
those procedures to work with both old-style and R6RS
records.  We apologize for the mess.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsConditionsSection"></a>8.8. Exceptions and conditions</h3></div></div></div><p>All of Larceny's modes support all features of the
<code class="literal">(rnrs exceptions)</code> and <code class="literal">(rnrs conditions)</code> libraries.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsIoSection"></a>8.9. Input and output</h3></div></div></div><p>R7RS and R6RS modes support all names exported by the
<code class="literal">(rnrs io ports)</code>, <code class="literal">(rnrs io simple)</code>, and
<code class="literal">(rnrs files)</code> libraries.</p><p>The <code class="literal">buffer-mode</code>, <code class="literal">eol-style</code>, and <code class="literal">error-handling-mode</code>
syntaxes are deprecated because they are redundant
with <code class="literal">quote</code>.  Larceny may provide these deprecated syntaxes
in the form of procedures rather than syntax, but this
deviation from R6RS semantics cannot be detected by
portable R6RS programs.</p><p>Larceny's R5RS mode supports all non-deprecated features
of those libraries.</p><p>Larceny supports four distinct buffer modes: <code class="literal">none</code>,
<code class="literal">line</code>, <code class="literal">datum</code>, and <code class="literal">block</code>.  The R6RS requires
the <code class="literal">buffer-mode</code> syntax to raise an exception for the
<code class="literal">datum</code> buffer mode, which is the buffer mode Larceny
uses for interactive output ports.</p><p>In Larceny, any symbol names a supported end-of-line
style.  All end-of-line and error-handling-mode symbols
whose meanings are not described by the R6RS have
locale-dependent meanings, which is an extension
permitted by the R6RS standard.</p><p>Although Larceny supports the UTF-16 codec, it is not
really useful on Windows machines (where it should be
most useful) because Larceny's low-level file system
mimics a byte-oriented Unix file system even on
Windows.  This problem should be addressed in some
future version of Larceny.</p><p>The most up-to-date list of known deviations from R6RS
io semantics can be found on the web page
that describes the current status of
<a class="ulink" href="https://github.com/larcenists/larceny/wiki/DargoMode" target="_top">Larceny's R6RS-compatible mode</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsProgramsSection"></a>8.10. Programs</h3></div></div></div><p>R7RS and R6RS modes support the <code class="literal">(rnrs programs)</code> library.</p><p>Larceny's R5RS mode provides the <code class="literal">exit</code> procedure but
not the <code class="literal">command-line</code> procedure of that library.
Larceny's traditional <code class="literal">command-line-arguments</code> procedure
can be used to implement an approximation to <code class="literal">command-line</code>.
For a definition, see <code class="literal">lib/R6RS/rnrs/programs.sls</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsArithmeticSection"></a>8.11. Arithmetic</h3></div></div></div><p>All of Larceny's modes support all features of the
<code class="literal">(rnrs arithmetic fixnums)</code>,
<code class="literal">(rnrs arithmetic flonums)</code>, and
<code class="literal">(rnrs arithmetic bitwise)</code>
libraries.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>R6RS fixnum and flonum operations may be slower than the
corresponding generic operations, since the fixnum and flonum
operations are required to check their arguments and may also
have to check their results.
Isolated operations in small micro-benchmarks are likely to
be slower than groups of similar operations in larger programs,
however, because Larceny's compiler removes redundant checks
and propagates type information.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsSyntaxCaseSection"></a>8.12. Syntax-case</h3></div></div></div><p>R7RS and R6RS modes support the <code class="literal">(rnrs syntax-case)</code> library.
Larceny's R5RS mode does not.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsHashtablesSection"></a>8.13. Hashtables</h3></div></div></div><p>All of Larceny's modes support all features of the
<code class="literal">(rnrs hashtables)</code> library.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Larceny's traditional <code class="literal">make-hashtable</code> procedure has been
renamed to <code class="literal">make-oldstyle-hashtable</code>.</p></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>When you use Larceny's R5RS or R7RS mode to dump a heap image
that contains <code class="literal">eq?</code> or <code class="literal">eqv?</code> hashtables you have created, they
are automatically reset so they will
rehash themselves whenever you begin a new session with the
dumped heap.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsEnumerationsSection"></a>8.14. Enumeration sets</h3></div></div></div><p>R7RS and R6RS modes support the <code class="literal">(rnrs enums)</code> library.
Larceny's R5RS mode provides all of the procedures exported by
<code class="literal">(rnrs enums)</code> but does not provide the <code class="literal">define-enumeration</code>
syntax.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsEvalSection"></a>8.15. Eval</h3></div></div></div><p>R7RS and R6RS modes support the <code class="literal">(rnrs eval)</code> library.
Larceny's R5RS mode provides an R5RS-compatible eval procedure,
not an R6RS-compatible eval procedure, and does not provide the
<code class="literal">environment</code> procedure.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsMutableStringsSection"></a>8.16. Mutable pairs and strings</h3></div></div></div><p>All of Larceny's modes support all features of the
<code class="literal">(rnrs mutable-pairs)</code> and <code class="literal">(rnrs mutable-strings)</code> libraries.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="R6rsR5rsSection"></a>8.17. R5RS</h3></div></div></div><p>All of Larceny's modes support all features of the
<code class="literal">(rnrs r5rs)</code> library.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="LarcenyErr5rsLibrariesChapter"></a>9. Larceny's R7RS/R6RS libraries</h2></div></div></div><p>Larceny provides libraries for compiling
R7RS/R6RS libraries and for timing benchmarks.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="LarcenyLoadSection"></a>9.1. Load</h3></div></div></div><p>The <code class="literal">(larceny load)</code> library exports both the
<code class="literal">load</code> procedure of <code class="literal">(scheme load)</code>
and Larceny's <code class="literal">r5rs:require</code> procedure, which is a renaming of
the <a class="link" href="#require"><code class="literal">require</code></a> procedure used by
Larceny's R5RS mode.</p><p>In Larceny's R7RS mode,
the <code class="literal">load</code> procedure can load
R5RS libraries and programs as well as R7RS/R6RS
libraries.</p><p>The <code class="literal">r5rs:require</code> procedure should be used only for dynamic loading of
R5RS libraries into Larceny's underlying R5RS system.  The
variables defined by that library can be imported into
an R7RS session or R7RS/R6RS library or program using a
<a class="link" href="#R7rsPrimitivesSection" title="3.3.6.&#xA0;Importing procedures from Larceny's underlying R5RS system"><code class="literal">primitives</code></a>
clause in an <code class="literal">import</code> form.</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>These procedures should be used only at an interactive top
level and in files that will be loaded into an interactive top
level.  Calls to these procedures have no effect at compile
time, and should not appear in files that will be compiled
separately; use the <code class="literal">define-library</code> and <code class="literal">import</code> syntaxes
instead.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="LarcenyCompilerSection"></a>9.2. Compiler</h3></div></div></div><p>The <code class="literal">(larceny compiler)</code> library exports the
<code class="literal">load</code> and <code class="literal">r5rs:require</code> procedures of <code class="literal">(larceny load)</code>,
the
<a class="link" href="#current-require-path"><code class="literal">current-require-path</code></a>
procedure, the
<a class="link" href="#compile-file"><code class="literal">compile-file</code></a>,
<a class="link" href="#compile-library"><code class="literal">compile-library</code></a>, and
<a class="link" href="#compile-stale-libraries"><code class="literal">compile-stale-libraries</code></a>
procedures described below,
and the
<a class="link" href="#compiler-switches"><code class="literal">compiler-switches</code></a> procedure.</p><p>These procedures can be used to compile R7RS/R6RS
libraries and top-level programs before they are imported
or executed.
This is especially important for Petit Larceny, which
would otherwise use an interpreter.  For native Larceny,
whose just-in-time compiler generates native machine code
as source libraries and programs are loaded, imported, or
executed, the main advantage of separate compilation is
that compiled libraries and programs will load much
faster than source libraries and programs.</p><p>The main disadvantage of separate compilation is that
compiled libraries and programs go <span class="emphasis"><em>stale</em></span> when their
source code is changed or when a library on which they
depend is changed or recompiled.  Stale libraries and
programs can be dangerously inconsistent with libraries
on which they depend, so Larceny checks for staleness
and refuses to execute a stale library or program.
The <a class="link" href="#compile-stale-libraries"><code class="literal">compile-stale-libraries</code></a>
procedure provides a convenient way to recompile stale
libraries and programs.</p><p><p><code class="literal">(compile-file <span class="emphasis"><em>sourcefile</em></span> <span class="emphasis"><em>[slfaslfile]</em></span>) </code></p></p><p>Compiles <span class="emphasis"><em>sourcefile</em></span>, which must be a string naming
a file that contains source code for one or more
R7RS/R6RS libraries or a top-level program.
If <span class="emphasis"><em>slfaslfile</em></span> is supplied as a second argument,
then it must be a string naming the file that will
contain the compiled code; otherwise the name of
the compiled file is obtained from <span class="emphasis"><em>sourcefile</em></span>
by replacing the "<code class="literal">.sld</code>" or "<code class="literal">.sls</code>" suffix with "<code class="literal">.slfasl</code>".</p><p><a id="compile-library"></a>
<span class="emphasis"><em> Procedure compile-library</em></span>
<p>
<a id="id2535508" class="indexterm"></a>
<code class="literal">(compile-library <span class="emphasis"><em>sourcefile</em></span> <span class="emphasis"><em>[slfaslfile]</em></span>) </code>
</p></p><p>Compiles <span class="emphasis"><em>sourcefile</em></span>, which must be a string naming
a file that contains source code for one or more
R7RS/R6RS libraries.
Apart from its unwillingness to compile top-level
programs, <code class="literal">compile-library</code> behaves the same as
<code class="literal">compile-file</code> above.</p><p><a id="compile-stale-libraries"></a>
<span class="emphasis"><em> Procedure compile-stale-libraries</em></span>
<p>
<a id="id2535565" class="indexterm"></a>
<code class="literal">(compile-stale-libraries <span class="emphasis"><em></em></span>) </code>
</p>
<p><code class="literal">(compile-stale-libraries <span class="emphasis"><em>changedfile</em></span>) </code></p></p><p>If no argument is supplied, then all "<code class="literal">.sld</code>" and "<code class="literal">.sls</code>" files that
lie within the current directory or a subdirectory are
recompiled.</p><p>If <span class="emphasis"><em>changedfile</em></span> is supplied, then it must be a string
giving the absolute pathname of a file.
(In typical usage, <span class="emphasis"><em>changedfile</em></span> is a source file that
has been modified, making it necessary to recompile all
files that depend upon it.)
Compiles all R7RS/R6RS library files that lie within
the same directory as <span class="emphasis"><em>changedfile</em></span> or a subdirectory,
and have not yet been compiled or whose compiled files
are older than <span class="emphasis"><em>changedfile</em></span>.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>In future versions of Larceny, <code class="literal">compile-stale-libraries</code>
might compile only the source files that depend upon
<span class="emphasis"><em>changedfile</em></span>.</p></div><p><a id="compiler-switches"></a>
<span class="emphasis"><em> Procedure compiler-switches</em></span>
<p>
<a id="id2535666" class="indexterm"></a>
<code class="literal">(compiler-switches <span class="emphasis"><em></em></span>) </code>
</p>
<p><code class="literal">(compiler-switches <span class="emphasis"><em>mode</em></span>) </code></p></p><p>If no argument is supplied, then the current settings
of all compiler switches are displayed.  Each of those
switches is itself a parameter that is exported by the
<code class="literal">(larceny compiler)</code> library.  Calling any individual
compiler switch with no arguments will return its current
setting.  Calling any individual compiler switch with an
argument (usually a boolean) will change its setting to
that argument.</p><p>The <code class="literal">compiler-switches</code> procedure may also be called with
one of the following symbols as its argument:</p><p><code class="literal">default</code>
sets most compiler switches to their default settings.</p><p><code class="literal">fast-safe</code>
enables all optimizations but continues to generate
code to perform all run-time type and range checks that
are needed for safety
(in the traditional sense, not the R6RS sense).</p><p><code class="literal">fast-unsafe</code>
enables all optimizations and also disables type and
range checking.  This setting is deprecated because it
compromises safety (in the traditional sense).</p><p><code class="literal">slow</code>
turns off all optimizations.</p><p><code class="literal">standard</code>
sets compiler switches for maximal conformance to the
R5RS and R6RS standards.</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>The <code class="literal">standard</code> setting is deprecated because it generates
very slow code (because the R5RS makes it difficult to
inline standard procedures), disables most compile-time
checking (because the R6RS forbids rejection of programs
with obvious errors unless the R6RS classifies the errors
as syntactic), and may also compromise the portability or
interoperability of R7RS/R6RS libraries and programs
(because the R6RS outlaws several extensions that Larceny
uses to improve its compatibility with other implementations
of the R5RS, R6RS, and R7RS as well as interoperability between
Larceny's own R5RS and R7RS/R6RS modes).</p></div><div class="tip" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Tip</h3><p>Selective toggling of compiler switches is almost always
better than using the <code class="literal">standard</code> setting.
To improve R5RS conformance without sacrificing too much
performance, set the <code class="literal">benchmark-mode</code> switch to false and
set the <code class="literal">integrate-procedures</code> switch to false only when
compiling files that need to be sensitive to redefinitions
of standard procedures.
For R6RS libraries and programs, setting the <code class="literal">benchmark-mode</code>
and <code class="literal">global-optimization</code> switches to false will eliminate a
couple of minor conformance issues with only a small loss
of performance and without sacrificing compile-time checking
or portability.
For R7RS libraries and programs, the compiler's default settings
already conform to the R7RS.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="LarcenyBenchmarkingSection"></a>9.3. Benchmarking</h3></div></div></div><p>The <code class="literal">(larceny benchmarking)</code> library exports the
<code class="literal">time</code> syntax and <code class="literal">run-benchmark</code> procedure described
below.</p><p><span class="emphasis"><em>Syntax time</em></span></p><p><code class="literal">(time expression)</code></p><p>Evaluates <span class="emphasis"><em>expression</em></span> and returns its result
after printing approximations to the storage
allocated and time taken during evaluation of
<span class="emphasis"><em>expression</em></span>.</p><pre class="screen">    &gt; (time (fib 30))
    Words allocated: 0
    Words reclaimed: 0
    Elapsed time...: 49 ms (User: 48 ms; System: 0 ms)
    Elapsed GC time: 0 ms (CPU: 0 in 0 collections.)
    832040</pre><p><p><code class="literal">(run-benchmark <span class="emphasis"><em>name iterations thunk predicate</em></span>) </code></p></p><p>Given the <span class="emphasis"><em>name</em></span> of a benchmark, the number of
<span class="emphasis"><em>iterations</em></span> to be performed, a zero-argument
procedure <span class="emphasis"><em>thunk</em></span> that runs the benchmark,
and a unary <span class="emphasis"><em>predicate</em></span> that checks the result
of <span class="emphasis"><em>thunk</em></span>, prints approximations to the storage
allocated and time taken by <span class="emphasis"><em>iterations</em></span> calls
to <span class="emphasis"><em>thunk</em></span>.</p><pre class="screen">    &gt; (run-benchmark "fib30"
                     100
                     (lambda () (fib 30))
                     (lambda (x) (= x 832040)))

    --------------------------------------------------------
    fib30
    Words allocated: 0
    Words reclaimed: 0
    Elapsed time...: 4828 ms (User: 4824 ms; System: 4 ms)
    Elapsed GC time: 0 ms (CPU: 0 in 0 collections.)</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="RecordsPrinterSection"></a>9.4. Records printer</h3></div></div></div><p>The <code class="literal">(larceny records printer)</code> library exports the
two procedures described below.  These procedures
can be used to override Larceny's usual printing
of records and opaque types that were defined using
the records libraries.</p><p><a id="rtd-printer"></a>
<span class="emphasis"><em> Procedure rtd-printer</em></span>
<p>
<a id="id2536017" class="indexterm"></a>
<code class="literal">(rtd-printer <span class="emphasis"><em>rtd</em></span>)  =&gt; <span class="emphasis"><em>maybe-procedure</em></span></code>
</p></p><p>Given a record type descriptor, returns its custom
print procedure, or returns false if the rtd has no
custom print procedure.</p><p><a id="rtd-printer-set!"></a>
<span class="emphasis"><em> Procedure rtd-printer-set!</em></span>
<p>
<a id="id2536056" class="indexterm"></a>
<code class="literal">(rtd-printer-set! <span class="emphasis"><em>rtd printer</em></span>) </code>
</p></p><p>Given a record type descriptor <span class="emphasis"><em>rtd</em></span> and a
<span class="emphasis"><em>printer</em></span> for instances of that rtd, installs
<span class="emphasis"><em>printer</em></span> as a custom print procedure for <span class="emphasis"><em>rtd</em></span>.
The <span class="emphasis"><em>printer</em></span> should be a procedure that,
given an instance of the rtd and a textual
output port, writes a representation of the
instance to the port.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Err5rsChapter"></a>10. ERR5RS standard libraries</h2></div></div></div><p><a class="link" href="#Standards" title="13.&#xA0;Standards">ERR5RS</a> has been superseded by the R7RS, so the
libraries described below are now deprecated.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="Err5rsLoadSection"></a>10.1. Load</h3></div></div></div><p>The <code class="literal">(err5rs load)</code> library has been superseded by the
<code class="literal">(scheme load)</code> library, and continues to exist only for
backward compatibility.</p><p><a id="load"></a>
<span class="emphasis"><em> Procedure load</em></span>
<p>
<a id="id2536154" class="indexterm"></a>
<code class="literal">(load <span class="emphasis"><em>filename</em></span>) </code>
</p></p><p>Loads ERR5RS code from <span class="emphasis"><em>filename</em></span>, evaluating each form
as though it had been entered at the interactive
read/eval/print loop.</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>The <code class="literal">load</code> procedure should be used only at an interactive top
level and in files that will be loaded into an interactive top
level.  Calls to the <code class="literal">load</code> procedure have no effect at compile
time, and should not appear in files that will be compiled
separately; use the <code class="literal">library</code> and <code class="literal">import</code> syntaxes instead.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="Err5rsRecordsSection"></a>10.2. Records</h3></div></div></div><p>The ERR5RS record facility described below incorporates all
optional features of SRFI 99 and is otherwise identical to
the facilities described by SRFI 99.
SRFI 99 is itself an extension of SRFI 9, whose
<code class="literal">define-record-type</code> syntax is identical to that defined by
the R7RS.</p><p>When a procedure is said to be equivalent to an R6RS
procedure, the equivalence holds only when all arguments
have the properties required of them by the R6RS
specification.  ERR5RS does not mandate R6RS exception
semantics for programs that violate the specification.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="Err5rsRecordsProceduralSection"></a>10.2.1. Procedural layer</h4></div></div></div><p>This section describes the <code class="literal">(err5rs records procedural)</code> library.</p><p><a id="make-rtd"></a>
<span class="emphasis"><em> Procedure make-rtd</em></span>
<p>
<a id="id2536279" class="indexterm"></a>
<code class="literal">(make-rtd <span class="emphasis"><em>name fieldspecs</em></span>) </code>
</p>
<p><code class="literal">(make-rtd <span class="emphasis"><em>name fieldspecs parent-rtd</em></span>) </code></p>
<p><code class="literal">(make-rtd <span class="emphasis"><em>name fieldspecs parent-rtd option …</em></span>) </code></p></p><p><span class="emphasis"><em>name</em></span> is a symbol, which matters only to the
<a class="link" href="#rtd-name"><code class="literal">rtd-name</code></a> procedure of the inspection layer.
<span class="emphasis"><em>fieldspecs</em></span> is a vector of field specifiers, where
each field specifier is one of</p><div class="itemizedlist"><ul type="disc"><li>
a symbol naming the (mutable) field;
</li><li>
a list of the form <code class="literal">(mutable <span class="emphasis"><em>name</em></span>)</code>,
where <span class="emphasis"><em>name</em></span> is a symbol naming the mutable field;
</li><li>
a list of the form <code class="literal">(immutable <span class="emphasis"><em>name</em></span>)</code>,
where <span class="emphasis"><em>name</em></span> is a symbol naming the immutable field.
</li></ul></div><p>The optional parent is an rtd or <code class="literal">#f</code>. It is an error for
any of the symbols in fieldspecs to name more than one
of the fields specified by fieldspecs, but the field names
in fieldspecs may shadow field names in the parent rtd.</p><p><a class="link" href="#make-rtd"><code class="literal">make-rtd</code></a> returns an R6RS-compatible record-type
descriptor.</p><p>Larceny allows the following optional arguments to follow
the optional <span class="emphasis"><em>parent-rtd</em></span> argument:</p><div class="itemizedlist"><ul type="disc"><li>
the symbol <code class="literal">sealed</code> means the new rtd cannot be used
as the parent of other rtds;
</li><li>
the symbol <code class="literal">opaque</code> means the <a class="link" href="#record?"><code class="literal">record?</code></a> predicate
will not recognize instances of the new rtd;
</li><li>
the symbol <code class="literal">uid</code>, followed by another symbol <span class="emphasis"><em>id</em></span>,
means the new rtd is non-generative with uid <span class="emphasis"><em>id</em></span>; the
semantics of this extension is the same as in the R6RS.
</li></ul></div><p>These Larceny-specific options may be used in any
combination, giving Larceny's ERR5RS records the same
expressive power as R6RS records, with which they are
fully interoperable.</p><p><a id="rtd?"></a>
<span class="emphasis"><em> Procedure rtd?</em></span>
<p>
<a id="id2536506" class="indexterm"></a>
<code class="literal">(rtd? <span class="emphasis"><em>obj</em></span>) </code>
</p></p><p>This predicate returns true if and only if its argument
is a record-type descriptor.
<code class="literal">rtd?</code> is equivalent to the <code class="literal">record-type-descriptor?</code>
procedure of the R6RS.</p><p><a id="rtd-constructor"></a>
<span class="emphasis"><em> Procedure rtd-constructor</em></span>
<p>
<a id="id2536552" class="indexterm"></a>
<code class="literal">(rtd-constructor <span class="emphasis"><em>rtd</em></span>) </code>
</p>
<p><code class="literal">(rtd-constructor <span class="emphasis"><em>rtd fieldspecs</em></span>) </code></p></p><p><span class="emphasis"><em>rtd</em></span> is a record-type descriptor, and <span class="emphasis"><em>fieldspecs</em></span> is
an optional vector of symbols.</p><p>If no <span class="emphasis"><em>fieldspecs</em></span> argument is supplied,
then <code class="literal">rtd-constructor</code> returns a procedure that expects
one argument for each field of the record-type described
by <span class="emphasis"><em>rtd</em></span> and returns an instance of that record-type
with its fields initialized to the corresponding
arguments.
Arguments that correspond to the fields of the
record-type's parent (if any) come first.</p><p>If <span class="emphasis"><em>fieldspecs</em></span> is supplied, then <code class="literal">rtd-constructor</code>
returns a procedure that expects one argument for each
element of <span class="emphasis"><em>fieldspecs</em></span> and returns an instance of the
record-type described by <span class="emphasis"><em>rtd</em></span> with the named fields
initialized to the corresponding arguments.</p><p>It is an error if some symbol occurs more than once in
<span class="emphasis"><em>fieldspecs</em></span>.  Fields of a derived record-type shadow
fields of the same name in its parent; the <span class="emphasis"><em>fieldspecs</em></span>
argument cannot be used to initialize a shadowed field.</p><p><a id="rtd-predicate"></a>
<span class="emphasis"><em> Procedure rtd-predicate</em></span>
<p>
<a id="id2536668" class="indexterm"></a>
<code class="literal">(rtd-predicate <span class="emphasis"><em>rtd</em></span>) </code>
</p></p><p>Equivalent to the <code class="literal">record-predicate</code> procedure of the R6RS.</p><p><a id="rtd-accessor"></a>
<span class="emphasis"><em> Procedure rtd-accessor</em></span>
<p>
<a id="id2536706" class="indexterm"></a>
<code class="literal">(rtd-accessor <span class="emphasis"><em>rtd field</em></span>) </code>
</p></p><p><span class="emphasis"><em>field</em></span> is a symbol that names a field of the
record-type described by the record-type descriptor <span class="emphasis"><em>rtd</em></span>.
Returns a unary procedure that accepts instances of <span class="emphasis"><em>rtd</em></span>
(or any record-type that inherits from <span class="emphasis"><em>rtd</em></span>) and
returns the current value of the named field.</p><p>Fields in derived record-types shadow fields of the same
name in a parent record-type.</p><p><a id="rtd-mutator"></a>
<span class="emphasis"><em> Procedure rtd-mutator</em></span>
<p>
<a id="id2536765" class="indexterm"></a>
<code class="literal">(rtd-mutator <span class="emphasis"><em>rtd field</em></span>) </code>
</p></p><p><span class="emphasis"><em>field</em></span> is a symbol that names a field of the
record-type described by the record-type descriptor <span class="emphasis"><em>rtd</em></span>.
Returns a binary procedure that accepts instances of <span class="emphasis"><em>rtd</em></span>
(or any record-type that inherits from <span class="emphasis"><em>rtd</em></span>) and a new
value to be stored into the named field, performs that
side effect, and returns an unspecified value.</p><p>Fields in derived record-types shadow fields of the same
name in a parent record-type.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="Err5rsRecordsInspectionSection"></a>10.2.2. Inspection layer</h4></div></div></div><p>This section describes the <code class="literal">(err5rs records inspection)</code> library.</p><p><a id="record?"></a>
<span class="emphasis"><em> Procedure record?</em></span>
<p>
<a id="id2536842" class="indexterm"></a>
<code class="literal">(record? <span class="emphasis"><em>obj</em></span>) </code>
</p></p><p>Equivalent to its R6RS namesake.</p><p><a id="record-rtd"></a>
<span class="emphasis"><em> Procedure record-rtd</em></span>
<p>
<a id="id2536875" class="indexterm"></a>
<code class="literal">(record-rtd <span class="emphasis"><em>record</em></span>) </code>
</p></p><p>Equivalent to its R6RS namesake.</p><p><a id="rtd-name"></a>
<span class="emphasis"><em> Procedure rtd-name</em></span>
<p>
<a id="id2536908" class="indexterm"></a>
<code class="literal">(rtd-name <span class="emphasis"><em>rtd</em></span>) </code>
</p></p><p>Equivalent to the <code class="literal">record-type-name</code> procedure of the R6RS.</p><p><a id="rtd-parent"></a>
<span class="emphasis"><em> Procedure rtd-parent</em></span>
<p>
<a id="id2536946" class="indexterm"></a>
<code class="literal">(rtd-parent <span class="emphasis"><em>rtd</em></span>) </code>
</p></p><p>Equivalent to the <code class="literal">record-type-parent</code> procedure of the R6RS.</p><p><a id="rtd-field-names"></a>
<span class="emphasis"><em> Procedure rtd-field-names</em></span>
<p>
<a id="id2536984" class="indexterm"></a>
<code class="literal">(rtd-field-names <span class="emphasis"><em>rtd</em></span>) </code>
</p></p><p>Equivalent to the <code class="literal">record-type-field-names</code> procedure of the R6RS.
(That is, it returns a vector of the symbols that name the fields
of the record-type represented by <span class="emphasis"><em>rtd</em></span>, excluding the fields of
parent record-types.)</p><p><a id="rtd-all-field-names"></a>
<span class="emphasis"><em> Procedure rtd-all-field-names</em></span>
<p>
<a id="id2537030" class="indexterm"></a>
<code class="literal">(rtd-all-field-names <span class="emphasis"><em>rtd</em></span>) </code>
</p></p><p>Returns a vector of the symbols that name the fields of
the record-type represented by <span class="emphasis"><em>rtd</em></span>, including the fields
of its parent record-types, if any, with the fields of
parent record-types coming before the fields of its children,
with each subsequence in the same order as in the vectors
that would be returned by calling <a class="link" href="#rtd-field-names"><code class="literal">rtd-field-names</code></a>
on <span class="emphasis"><em>rtd</em></span> and on all its ancestral record-type descriptors.</p><p><a id="rtd-field-mutable?"></a>
<span class="emphasis"><em> Procedure rtd-field-mutable?</em></span>
<p>
<a id="id2537089" class="indexterm"></a>
<code class="literal">(rtd-field-mutable? <span class="emphasis"><em>rtd field</em></span>) </code>
</p></p><p><span class="emphasis"><em>rtd</em></span> is a record-type descriptor, and <span class="emphasis"><em>field</em></span> is a
symbol naming a field of the record-type described by <span class="emphasis"><em>rtd</em></span>.
Returns <code class="literal">#t</code> if the named field is mutable; otherwise returns <code class="literal">#f</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="Err5rsRecordsSyntacticSection"></a>10.2.3. Syntactic layer</h4></div></div></div><p>This section describes the <code class="literal">(err5rs records syntactic)</code> library.</p><p>The syntactic layer consists of
<a class="ulink" href="http://srfi.schemers.org/srfi-9/" target="_top">SRFI 9</a>
extended with single inheritance and (optional) implicit naming.</p><p>All ERR5RS record-type definitions are generative (unless
Larceny's optional <code class="literal">uid</code> feature is used), but
ERR5RS drops the SRFI 9 restriction to top level, mainly
because the R6RS allows generative definitions wherever
a definition may appear.</p><p>The syntax of an ERR5RS record-type definition is</p><pre class="screen">    &lt;definition&gt;
      -&gt; &lt;record type definition&gt;           ; addition to 7.1.6 in R5RS

    &lt;record type definition&gt;
      -&gt; (define-record-type &lt;type spec&gt;
           &lt;constructor spec&gt;
           &lt;predicate spec&gt;
           &lt;field spec&gt; ...)

    &lt;type spec&gt;  -&gt; &lt;type name&gt;
                 -&gt; (&lt;type name&gt; &lt;parent&gt;)

    &lt;constructor spec&gt;
                 -&gt; #f
                 -&gt; #t
                 -&gt; &lt;constructor name&gt;
                 -&gt; (&lt;constructor name&gt; &lt;field name&gt; ...)

    &lt;predicate spec&gt;
                 -&gt; #f
                 -&gt; #t
                 -&gt; &lt;predicate name&gt;

    &lt;field spec&gt; -&gt; &lt;field name&gt;
                 -&gt; (&lt;field name&gt;)
                 -&gt; (&lt;field name&gt; &lt;accessor name&gt;)
                 -&gt; (&lt;field name&gt; &lt;accessor name&gt; &lt;mutator name&gt;)

    &lt;parent&gt;           -&gt; &lt;expression&gt;

    &lt;type name&gt;        -&gt; &lt;identifier&gt;
    &lt;constructor name&gt; -&gt; &lt;identifier&gt;
    &lt;predicate name&gt;   -&gt; &lt;identifier&gt;
    &lt;accessor name&gt;    -&gt; &lt;identifier&gt;
    &lt;mutator name&gt;     -&gt; &lt;identifier&gt;
    &lt;field name&gt;       -&gt; &lt;identifier&gt;</pre><p>The semantics of a record type definition is the same
as in SRFI 9: the record type definition macro-expands
into a cluster of definitions that</p><div class="itemizedlist"><ul type="disc"><li>
defines the <code class="literal">&lt;type name&gt;</code> as the record-type descriptor
for the new record-type;
</li><li>
defines a constructor for instances of the new
record-type (unless the constructor spec is <code class="literal">#f</code>);
</li><li>
defines a predicate that recognizes instances of the
new record-type and its subtypes (unless the predicate spec is <code class="literal">#f</code>);
</li><li>
defines an accessor for each field name;
</li><li>
defines a mutator for each mutable field name.
</li></ul></div><p>An ERR5RS record type definition extends SRFI 9 with the
following additional options:</p><div class="itemizedlist"><ul type="disc"><li>
If a <code class="literal">&lt;parent&gt;</code> expression is specified, then it must
evaluate to an rtd that serves as the parent record-type
for the record-type being defined.
</li><li>
If <code class="literal">#f</code> is specified for the constructor or predicate,
then no constructor or predicate procedure is defined.
(This is useful when the record-type being defined will
be used as an abstract base class.)
</li><li>
If <code class="literal">#t</code> is specified for the constructor or predicate,
then the name of the constructor is the type name prefixed
by <code class="literal">make-</code>, and the name of the predicate is the type name
followed by a question mark (<code class="literal">?</code>).
</li><li>
If the constructor name is specified as <code class="literal">#t</code> or as an
identifier, then the constructor's arguments correspond
to the fields of the parent (if any) followed by the new
fields added by this record-type definition.
</li><li><p>
If a field spec consists of a single identifier, then
</p><div class="itemizedlist"><ul type="circle"><li>
the field is immutable;
</li><li>
the name of its accessor is the type name followed by
a hyphen (<code class="literal">-</code>) followed by the field name.
</li></ul></div></li><li><p>
If a field spec consists of a list of one identifier, then
</p><div class="itemizedlist"><ul type="circle"><li>
the field is mutable;
</li><li>
the name of its accessor is the type name followed
by a hyphen (<code class="literal">-</code>) followed by the field name;
</li><li>
the name of its mutator is the type name followed by
a hyphen (<code class="literal">-</code>) followed by the field name followed by <code class="literal">-set!</code>.
</li></ul></div></li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="RecordIdentitySection"></a>10.2.4. Record identity</h4></div></div></div><p>Two ERR5RS records with fields are <code class="literal">eqv?</code> if and only if
they were created by the same (dynamic) call to some
record constructor.
Two ERR5RS records are <code class="literal">eq?</code> if and only if they are <code class="literal">eqv?</code>.</p><p>Apart from the usual constraint that equivalence according
to <code class="literal">eqv?</code> implies equivalence according to <code class="literal">equal?</code>, the
behavior of <code class="literal">equal?</code> on ERR5RS records is unspecified.
(This is compatible with the R6RS.)</p><p>A <code class="literal">define-record-type</code> form macro-expands into code that
calls <a class="link" href="#make-rtd"><code class="literal">make-rtd</code></a> each time the expanded record-type
definition is executed.
Two ERR5RS record-type descriptors are <code class="literal">eqv?</code> if and only if
they were created by the same (dynamic) call to
<a class="link" href="#make-rtd"><code class="literal">make-rtd</code></a>.</p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="LarcenyR5rsLibrariesChapter"></a>11. Larceny's R5RS libraries</h2></div></div></div><p>The procedures described in this chapter are nonstandard.
Some are deprecated after being rendered obsolete by R7RS
or R6RS standard libraries.
Others still provide useful capabilities that the standard
libraries don't.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2537564"></a>11.1. Strings</h3></div></div></div><p>Larceny provides Unicode strings with
<a class="ulink" href="http://www.r6rs.org/" target="_top">R6RS</a>
semantics.</p><p>The <code class="literal">string-downcase</code> and <code class="literal">string-upcase</code> procedures
perform Unicode-compatible case folding, which can result
in a string whose length is different from that of the original.</p><p>Larceny may still provide <code class="literal">string-downcase!</code> and <code class="literal">string-upcase!</code>
procedures, but they are deprecated.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2537611"></a>11.2. Bytevectors</h3></div></div></div><p>A <span class="emphasis"><em>bytevector</em></span> is a data structure that stores bytes — exact
8-bit unsigned integers. Bytevectors are useful in constructing
system interfaces and other low-level programming. In Larceny,
many bytevector-like structures — bignums, for example —
are implemented in terms of a
lower-level <span class="emphasis"><em>bytevector-like</em></span> data type. The operations on
generic bytevector-like structures are particularly fast but
useful largely in code that manipulates Larceny's data
representations.</p><p>The <a class="link" href="#"><code class="literal">(rnrs bytevectors)</code> library</a> now
provides a large set of procedures that, in Larceny, are
defined using the procedures described below.</p><p><a id="make-bytevector"></a>
<span class="emphasis"><em> Integrable procedure make-bytevector</em></span>
<p>
<a id="id2537662" class="indexterm"></a>
<code class="literal">(make-bytevector <span class="emphasis"><em>length</em></span>)  =&gt; <span class="emphasis"><em>bytevector</em></span></code>
</p>
<p><code class="literal">(make-bytevector <span class="emphasis"><em>length fill</em></span>)  =&gt; <span class="emphasis"><em>bytevector</em></span></code></p></p><p>Returns a bytevector of the desired length.
If no second argument is given, then the bytevector has not
been initialized and most likely contains garbage.</p><p><span class="emphasis"><em>Operations on bytevector structures</em></span></p><p><p><code class="literal">(bytevector? <span class="emphasis"><em>obj</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code></p></p><p><p><code class="literal">(bytevector-length <span class="emphasis"><em>bytevector</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p></p><p><p><code class="literal">(bytevector-ref <span class="emphasis"><em>bytevector offset</em></span>)  =&gt; <span class="emphasis"><em>byte</em></span></code></p></p><p><p><code class="literal">(bytevector-set! <span class="emphasis"><em>bytevector offset byte</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p><p><code class="literal">(bytevector-equal? <span class="emphasis"><em>bytevector1 bytevector2</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code></p></p><p><p><code class="literal">(bytevector-fill! <span class="emphasis"><em>bytevector byte</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p><p><code class="literal">(bytevector-copy <span class="emphasis"><em>bytevector</em></span>)  =&gt; <span class="emphasis"><em>bytevector</em></span></code></p></p><p>These procedures do what you expect.
All are integrable, except <code class="literal">bytevector-equal?</code> and <code class="literal">bytevector-copy</code>.
The <code class="literal">bytevector-equal?</code> name is deprecated, since the
R6RS calls it <code class="literal">bytevector=?</code>.</p><p><span class="emphasis"><em>Operations on bytevector-like structures</em></span></p><p><p><code class="literal">(bytevector-like? <span class="emphasis"><em>obj</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code></p></p><p><p><code class="literal">(bytevector-like-length <span class="emphasis"><em>bytevector</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p></p><p><p><code class="literal">(bytevector-like-ref <span class="emphasis"><em>bytevector offset</em></span>)  =&gt; <span class="emphasis"><em>byte</em></span></code></p></p><p><p><code class="literal">(bytevector-like-set! <span class="emphasis"><em>bytevector offset byte</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p><p><code class="literal">(bytevector-like-equal? <span class="emphasis"><em>bytevector1 bytevector2</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code></p></p><p><p><code class="literal">(bytevector-like-copy <span class="emphasis"><em>bytevector</em></span>)  =&gt; <span class="emphasis"><em>bytevector</em></span></code></p></p><p>A bytevector-like structure is a low-level representation
for indexed arrays of uninterpreted bytes.  Bytevector-like
structures are used to represent types such as bignums and
flonums.</p><p>There is no way to construct a "generic" bytevector-like
structure; use the constructors for specific bytevector-like
types.</p><p>The bytevector-like operations operate on all bytevector-like
structures.  All are integrable, except <code class="literal">bytevector-like-equal?</code>
and <code class="literal">bytevector-like-copy</code>.  All are deprecated because they
violate abstraction barriers and make your code
representation-dependent; they are useful mainly to
Larceny developers, who might otherwise be tempted to
write some low-level operations in C or assembly language.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2537942"></a>11.3. Vectors</h3></div></div></div><p><a id="vector-copy"></a>
<span class="emphasis"><em> Procedure vector-copy</em></span>
<p>
<a id="id2537960" class="indexterm"></a>
<code class="literal">(vector-copy <span class="emphasis"><em>vector</em></span>)  =&gt; <span class="emphasis"><em>vector</em></span></code>
</p></p><p>Returns a shallow copy of its argument.</p><p><span class="emphasis"><em>Operations on vector-like structures</em></span></p><p><p><code class="literal">(vector-like? <span class="emphasis"><em>object</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code></p>
<p><code class="literal">(vector-like-length <span class="emphasis"><em>vector-like</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code></p>
<p><code class="literal">(vector-like-ref <span class="emphasis"><em>vector-like k</em></span>)  =&gt; <span class="emphasis"><em>object</em></span></code></p>
<p><code class="literal">(vector-like-set! <span class="emphasis"><em>vector-like k object</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p>A vector-like structure is a low-level representation
for indexed arrays of Scheme objects.  Vector-like
structures are used to represent types such as vectors,
records, symbols, and ports.</p><p>There is no way to construct a "generic" vector-like structure;
use the constructors for specific data types.</p><p>The vector-like operations operate on all vector-like structures.
All are integrable.
All are deprecated because they
violate abstraction barriers and make your code
representation-dependent; they are useful mainly to
Larceny developers, who might otherwise be tempted to
write some low-level operations in C or assembly language.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2538061"></a>11.4. Procedures</h3></div></div></div><p><span class="emphasis"><em>Operations on procedures</em></span></p><p><p><code class="literal">(make-procedure <span class="emphasis"><em>length</em></span>)  =&gt; <span class="emphasis"><em>procedure</em></span></code></p>
<p><code class="literal">(procedure-length <span class="emphasis"><em>procedure</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code></p>
<p><code class="literal">(procedure-ref <span class="emphasis"><em>procedure offset</em></span>)  =&gt; <span class="emphasis"><em>object</em></span></code></p>
<p><code class="literal">(procedure-set! <span class="emphasis"><em>procedure offset object</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p>These procedures operate on the representations of procedures and
allow user programs to construct, inspect, and alter procedures.</p><p><a id="procedure-copy"></a>
<span class="emphasis"><em> Procedure procedure-copy</em></span>
<p>
<a id="id2538138" class="indexterm"></a>
<code class="literal">(procedure-copy <span class="emphasis"><em>procedure</em></span>)  =&gt; <span class="emphasis"><em>procedure</em></span></code>
</p></p><p>Returns a shallow copy of the procedure.</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>The procedures above are deprecated because they
violate abstraction barriers and make your code
representation-dependent; they are useful mainly to
Larceny developers, who might otherwise be tempted to
write some low-level operations in C or assembly language.</p></div><p>The rest of this section describes some procedures that
reach through abstraction barriers in a more controlled way
to extract heuristic information from procedures for debugging
purposes.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The following
text is copied from a straw proposal authored by Will Clinger and sent
to rrr-authors on 09 May 1996. The text has been edited lightly. See
the end for notes about the Larceny implementation.</p></div><p>The procedures that extract heuristic information from procedures are
permitted to return any result whatsoever. If the type of a result is
not among those listed below, then the result represents an
implementation-dependent extension to this interface, which may safely
be interpreted as though no information were available from the
procedure. Otherwise the result is to be interpreted as described
below.</p><p><a id="procedure-arity"></a>
<span class="emphasis"><em> Procedure procedure-arity</em></span>
<p>
<a id="id2538224" class="indexterm"></a>
<code class="literal">(procedure-arity <span class="emphasis"><em>proc</em></span>) </code>
</p></p><p>Returns information about the arity of <span class="emphasis"><em>proc</em></span>. If the result is <code class="literal">#f</code>,
then no information is available. If the result is an exact
non-negative integer <span class="emphasis"><em>k</em></span>, then <span class="emphasis"><em>proc</em></span> requires exactly <span class="emphasis"><em>k</em></span>
arguments. If the result is an inexact non-negative integer <span class="emphasis"><em>n</em></span>, then
<span class="emphasis"><em>proc</em></span> requires <span class="emphasis"><em>n</em></span> or more arguments. If the result is a pair, then
it is a list of non-negative integers, each of which indicates a
number of arguments that will be accepted by <span class="emphasis"><em>proc</em></span>; the list is not
necessarily exhaustive.</p><p><a id="procedure-documentation-string"></a>
<span class="emphasis"><em> Procedure procedure-documentation-string</em></span>
<p>
<a id="id2538300" class="indexterm"></a>
<code class="literal">(procedure-documentation-string <span class="emphasis"><em>proc</em></span>) </code>
</p></p><p>Returns general information about <span class="emphasis"><em>proc</em></span>. If the result is <code class="literal">#f</code>, then no
information is available. If the result is a string, then it is to be
interpreted as a "documentation string" (see Common Lisp).</p><p><a id="procedure-name"></a>
<span class="emphasis"><em> Procedure procedure-name</em></span>
<p>
<a id="id2538346" class="indexterm"></a>
<code class="literal">(procedure-name <span class="emphasis"><em>proc</em></span>) </code>
</p></p><p>Returns information about the name of <span class="emphasis"><em>proc</em></span>. If the result is <code class="literal">#f</code>,
then no information is available. If the result is a symbol or string,
then it represents a name. If the result is a pair, then it is a list
of symbols and/or strings representing a path of names; the first
element represents an outer name and the last element represents an
inner name.</p><p><a id="procedure-source-file"></a>
<span class="emphasis"><em> Procedure procedure-source-file</em></span>
<p>
<a id="id2538395" class="indexterm"></a>
<code class="literal">(procedure-source-file <span class="emphasis"><em>proc</em></span>) </code>
</p></p><p>Returns information about the name of a file that contains the source
code for <span class="emphasis"><em>proc</em></span>. If the result is <code class="literal">#f</code>, then no information is
available. If the result is a string, then the string is the name of a
file.</p><p><a id="procedure-source-position"></a>
<span class="emphasis"><em> Procedure procedure-source-position</em></span>
<p>
<a id="id2538443" class="indexterm"></a>
<code class="literal">(procedure-source-position <span class="emphasis"><em>proc</em></span>) </code>
</p></p><p>Returns information about the position of the source code for <span class="emphasis"><em>proc</em></span>
whithin the source file specified by procedure-source-file. If the
result is <code class="literal">#f</code>, then no information is available. If the result is an
exact integer <span class="emphasis"><em>k</em></span>, then <span class="emphasis"><em>k</em></span> characters precede the opening parenthesis
of the source code for <span class="emphasis"><em>proc</em></span> within that source file.</p><p><a id="procedure-expression"></a>
<span class="emphasis"><em> Procedure procedure-expression</em></span>
<p>
<a id="id2538503" class="indexterm"></a>
<code class="literal">(procedure-expression <span class="emphasis"><em>proc</em></span>) </code>
</p></p><p>Returns information about the source code for <span class="emphasis"><em>proc</em></span>. If the result is
<code class="literal">#f</code>, then no information is available. If the result is a pair, then it
is a lambda expression in the traditional representation of a list.</p><p><a id="procedure-environment"></a>
<span class="emphasis"><em> Procedure procedure-environment</em></span>
<p>
<a id="id2538551" class="indexterm"></a>
<code class="literal">(procedure-environment <span class="emphasis"><em>proc</em></span>) </code>
</p></p><p>Returns information about the environment of <span class="emphasis"><em>proc</em></span>. If the result is
<code class="literal">#f</code>, then no information is available. In any case the result may be
passed to any of the <a class="link" href="#">environment inquiry functions</a>.</p><p><span class="strong"><strong>Notes on the Larceny implementation</strong></span></p><p>Twobit does not yet produce data for all of these functions, so some
of them always return <code class="literal">#f</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2538610"></a>11.5. Pairs and Lists</h3></div></div></div><p>The <code class="literal">(rnrs lists)</code> library now
provides a set of procedures that may supersede some
of the procedures described below.
If one of Larceny's procedures duplicates the semantics of
an R6RS procedure whose name is different, then Larceny's
name is deprecated.</p><p><a id="append!"></a>
<span class="emphasis"><em> Procedure append!</em></span>
<p>
<a id="id2538643" class="indexterm"></a>
<code class="literal">(append! <span class="emphasis"><em>list1 list2 … obj</em></span>)  =&gt; <span class="emphasis"><em>object</em></span></code>
</p></p><p><code class="literal">append!</code> destructively appends its arguments, which must be lists, and
returns the resulting list. The last argument can be any object. The
argument lists are appended by changing the cdr of the last pair of
each argument except the last to point to the next argument.</p><p><a id="every?"></a>
<span class="emphasis"><em> Procedure every?</em></span>
<p>
<a id="id2538687" class="indexterm"></a>
<code class="literal">(every? <span class="emphasis"><em>procedure list1 list2 …</em></span>)  =&gt; <span class="emphasis"><em>object</em></span></code>
</p></p><p><code class="literal">every?</code> applies <span class="emphasis"><em>procedure</em></span> to each element tuple of <span class="emphasis"><em>list_s in
first-to-last order, and returns <code class="literal">#f</code> as soon as _procedure</em></span> returns
<code class="literal">#f</code>. If <span class="emphasis"><em>procedure</em></span> does not return <code class="literal">#f</code> for any element tuple of
<span class="emphasis"><em>list_s, then the value returned by _procedure</em></span> for the last element
tuple of _list_s is returned.</p><p><a id="last-pair"></a>
<span class="emphasis"><em> Procedure last-pair</em></span>
<p>
<a id="id2538760" class="indexterm"></a>
<code class="literal">(last-pair <span class="emphasis"><em>list-structure</em></span>)  =&gt; <span class="emphasis"><em>pair</em></span></code>
</p></p><p><code class="literal">last-pair</code> returns the last pair of the <span class="emphasis"><em>list structure</em></span>, which must be
a sequence of pairs linked through the cdr fields.</p><p><a id="list-copy"></a>
<span class="emphasis"><em> Procedure list-copy</em></span>
<p>
<a id="id2538806" class="indexterm"></a>
<code class="literal">(list-copy <span class="emphasis"><em>list-copy</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code>
</p></p><p><code class="literal">list-copy</code> makes a shallow copy of the <span class="emphasis"><em>list</em></span> and returns that copy.</p><p><a id="remove"></a>
<span class="emphasis"><em> Procedure remove</em></span>
<p>
<a id="id2538848" class="indexterm"></a>
<code class="literal">(remove <span class="emphasis"><em>key list</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code>
</p>
<a id="remq"></a>
<span class="emphasis"><em> Procedure remq</em></span>
<p>
<a id="id2538879" class="indexterm"></a>
<code class="literal">(remq <span class="emphasis"><em>key list</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code>
</p>
<a id="remv"></a>
<span class="emphasis"><em> Procedure remv</em></span>
<p>
<a id="id2538909" class="indexterm"></a>
<code class="literal">(remv <span class="emphasis"><em>key list</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code>
</p>
<a id="remp"></a>
<span class="emphasis"><em> Procedure remp</em></span>
<p>
<a id="id2538939" class="indexterm"></a>
<code class="literal">(remp <span class="emphasis"><em>pred? list</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code>
</p></p><p>Each of these procedures returns a new list which contains all the
elements of <span class="emphasis"><em>list</em></span> in the original order, except that those elements of
the original list that were equal to <span class="emphasis"><em>key</em></span> (or that satisfy <span class="emphasis"><em>pred?</em></span>) are
not in the new list. Remove uses <code class="literal">equal?</code> as the equivalence predicate;
<code class="literal">remq</code> uses <code class="literal">eq?</code>, and <code class="literal">remv</code> uses <code class="literal">eqv?</code>.</p><p><a id="remove!"></a>
<span class="emphasis"><em> Procedure remove!</em></span>
<p>
<a id="id2539018" class="indexterm"></a>
<code class="literal">(remove! <span class="emphasis"><em>key list</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code>
</p>
<a id="remq!"></a>
<span class="emphasis"><em> Procedure remq!</em></span>
<p>
<a id="id2539051" class="indexterm"></a>
<code class="literal">(remq! <span class="emphasis"><em>key list</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code>
</p>
<a id="remv!"></a>
<span class="emphasis"><em> Procedure remv!</em></span>
<p>
<a id="id2539086" class="indexterm"></a>
<code class="literal">(remv! <span class="emphasis"><em>key list</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code>
</p>
<a id="remp!"></a>
<span class="emphasis"><em> Procedure remp!</em></span>
<p>
<a id="id2539121" class="indexterm"></a>
<code class="literal">(remp! <span class="emphasis"><em>pred? list</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code>
</p></p><p>These procedures are like <code class="literal">remove</code>, <code class="literal">remq</code>, <code class="literal">remv</code>, and <code class="literal">remp</code>,
except they modify <span class="emphasis"><em>list</em></span> instead of returning a fresh list.</p><p><a id="reverse!"></a>
<span class="emphasis"><em> Procedure reverse!</em></span>
<p>
<a id="id2539189" class="indexterm"></a>
<code class="literal">(reverse! <span class="emphasis"><em>list</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code>
</p></p><p><code class="literal">reverse!</code> destructively reverses its argument and returns the reversed
list.</p><p><a id="some?"></a>
<span class="emphasis"><em> Procedure some?</em></span>
<p>
<a id="id2539236" class="indexterm"></a>
<code class="literal">(some? <span class="emphasis"><em>procedure list1 list2 …</em></span>)  =&gt; <span class="emphasis"><em>object</em></span></code>
</p></p><p><code class="literal">some?</code> applies <span class="emphasis"><em>procedure</em></span> to each element tuple of <span class="emphasis"><em>list_s in
first-to-last order, and returns the first non-false value returned by
_procedure.</em></span> If <span class="emphasis"><em>procedure</em></span> does not return a true value for any
element tuple of _list_s, then some? returns <code class="literal">#f</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2539290"></a>11.6. Sorting</h3></div></div></div><p>The <code class="literal">(rnrs sorting)</code> library now
provides a small set of procedures that supersede most
of the procedures described below.
All of the procedures described below are therefore
deprecated.</p><p><span class="emphasis"><em>Procedures sort and sort!</em></span></p><p><p><code class="literal">(sort <span class="emphasis"><em>list less?</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code></p>
<p><code class="literal">(sort <span class="emphasis"><em>vector less?</em></span>)  =&gt; <span class="emphasis"><em>vector</em></span></code></p>
<p><code class="literal">(sort! <span class="emphasis"><em>list less?</em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code></p>
<p><code class="literal">(sort! <span class="emphasis"><em>vector less?</em></span>)  =&gt; <span class="emphasis"><em>vector</em></span></code></p></p><p>These procedures sort their argument (a list or a vector) according to
the predicate <span class="emphasis"><em>less?</em></span>, which must implement a total order on the
elements in the data structures that are sorted.</p><p><code class="literal">sort</code> returns a fresh data structure containing the sorted data;
<code class="literal">sort!</code> sorts the data structure in-place.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2539400"></a>11.7. Records</h3></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Larceny's records have been extended to implement all SRFI 99
and
<a class="ulink" href="http://www.r6rs.org/" target="_top">R6RS</a>
procedures from</p><pre class="literallayout">(srfi :99 records procedural)
(srfi :99 records inspection)
(rnrs records procedural)
(rnrs records inspection)</pre><p>We recommend that Larceny programmers use the SRFI 99 APIs instead
of the R6RS APIs.  This should entail no loss of portability, since
the standard reference implementation of SRFI 99 records should run
efficiently in any implementation of the R7RS/R6RS that permits new
libraries to defined at all.</p><p>Larceny now has two kinds of records: old-style and R7RS/R6RS/SRFI99/ERR5RS.
Old-style records cannot be created in R6RS-conforming mode, so
our extension of R6RS procedures to accept old-style records does
not affect R6RS conformance.</p></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The following specification describes Larceny's old-style record API,
which is now deprecated.  It
is based on a proposal posted by Pavel Curtis to
rrrs-authors on 10 Sep 1989, and later re-posted by Norman Adams to
comp.lang.scheme on 5 Feb 1992. The authorship and copyright status of
the original text are unknown to me.</p><p>This document differs from the original proposal in that its record
types are extensible, and that it specifies the type of record-type
descriptors.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2539478"></a>11.7.1. Specification</h4></div></div></div><p><a id="make-record-type"></a>
<span class="emphasis"><em> Procedure make-record-type</em></span>
<p>
<a id="id2539499" class="indexterm"></a>
<code class="literal">(make-record-type <span class="emphasis"><em>type-name field-names</em></span>) </code>
</p></p><p>Returns a "record-type descriptor", a value representing a new data
type, disjoint from all others. The <span class="emphasis"><em>type-name</em></span> argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type). The <span class="emphasis"><em>field-names</em></span>
argument is a list of symbols naming the "fields" of a record of the
new type. It is an error if the list contains any duplicates.</p><p>If the <span class="emphasis"><em>parent-rtd</em></span> argument is provided, then the new type will be a
subtype of the type represented by <span class="emphasis"><em>parent-rtd</em></span>, and the field names
of the new type will include all the field names of the parent
type. It is an error if the complete list of field names contains any
duplicates.</p><p>Record-type descriptors are themselves records. In particular,
record-type descriptors have a field printer that is either <code class="literal">#f</code> or a
procedure. If the value of the field is a procedure, then the
procedure will be called to print records of the type represented by
the record-type descriptor. The procedure must accept two arguments:
the record object to be printed and an output port.</p><p><a id="record-constructor"></a>
<span class="emphasis"><em> Procedure record-constructor</em></span>
<p>
<a id="id2539592" class="indexterm"></a>
<code class="literal">(record-constructor <span class="emphasis"><em>rtd</em></span>) </code>
</p></p><p>Returns a procedure for constructing new members of the type
represented by <span class="emphasis"><em>rtd.</em></span> The returned procedure accepts exactly as many
arguments as there are symbols in the given list, <span class="emphasis"><em>field-names</em></span>; these
are used, in order, as the initial values of those fields in a new
record, which is returned by the constructor procedure. The values of
any fields not named in that list are unspecified. The field-names
argument defaults to the list of field-names in the call to
make-record-type that created the type represented by <span class="emphasis"><em>rtd</em></span>; if the
<span class="emphasis"><em>field-names</em></span> argument is provided, it is an error if it contains any
duplicates or any symbols not in the default list.</p><p><a id="record-predicate"></a>
<span class="emphasis"><em> Procedure record-predicate</em></span>
<p>
<a id="id2539660" class="indexterm"></a>
<code class="literal">(record-predicate <span class="emphasis"><em>rtd</em></span>) </code>
</p></p><p>Returns a procedure for testing membership in the type represented by
<span class="emphasis"><em>rtd.</em></span> The returned procedure accepts exactly one argument and returns
a true value if the argument is a member of the indicated record type
or one of its subtypes; it returns a false value otherwise.</p><p><a id="record-accessor"></a>
<span class="emphasis"><em> Procedure record-accessor</em></span>
<p>
<a id="id2539708" class="indexterm"></a>
<code class="literal">(record-accessor <span class="emphasis"><em>rtd field-name</em></span>) </code>
</p></p><p>Returns a procedure for reading the value of a particular field of a
member of the type represented by <span class="emphasis"><em>rtd.</em></span> The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
<span class="emphasis"><em>field-name</em></span> in that record. The symbol field-name must be a member of
the list of field-names in the call to make-record-type that created
the type represented by <span class="emphasis"><em>rtd</em></span>, or a member of the field-names of the
parent type of the type represented by <span class="emphasis"><em>rtd.</em></span></p><p><a id="record-updater"></a>
<span class="emphasis"><em> Procedure record-updater</em></span>
<p>
<a id="id2539772" class="indexterm"></a>
<code class="literal">(record-updater <span class="emphasis"><em>rtd field-name</em></span>) </code>
</p></p><p>Returns a procedure for writing the value of a particular field of a
member of the type represented by <span class="emphasis"><em>rtd.</em></span> The returned procedure
accepts exactly two arguments: first, a record of the appropriate
type, and second, an arbitrary Scheme value; it modifies the field
named by the symbol <span class="emphasis"><em>field-name</em></span> in that record to contain the given
value. The returned value of the updater procedure is unspecified. The
symbol <span class="emphasis"><em>field-name</em></span> must be a member of the list of field-names in the
call to make-record-type that created the type represented by <span class="emphasis"><em>rtd</em></span>,
or a member of the field-names of the parent type of the type
represented by <span class="emphasis"><em>rtd.</em></span></p><p><p><code class="literal">(record? <span class="emphasis"><em>obj</em></span>) </code></p></p><p>Returns a true value if <span class="emphasis"><em>obj</em></span> is a record of any type and a false value
otherwise. Note that <code class="literal">record?</code> may be true of any Scheme value; of
course, if it returns true for some particular value, then
<code class="literal">record-type-descriptor</code> is applicable to that value and returns an
appropriate descriptor.</p><p><a id="record-type-descriptor"></a>
<span class="emphasis"><em> Procedure record-type-descriptor</em></span>
<p>
<a id="id2539881" class="indexterm"></a>
<code class="literal">(record-type-descriptor <span class="emphasis"><em>record</em></span>) </code>
</p></p><p>Returns a record-type descriptor representing the type of the given
record. That is, for example, if the returned descriptor were passed
to record-predicate, the resulting predicate would return a true value
when passed the given record. Note that it is not necessarily the case
that the returned descriptor is the one that was passed to
record-constructor in the call that created the constructor procedure
that created the given record.</p><p><a id="record-type-name"></a>
<span class="emphasis"><em> Procedure record-type-name</em></span>
<p>
<a id="id2539931" class="indexterm"></a>
<code class="literal">(record-type-name <span class="emphasis"><em>rtd</em></span>) </code>
</p></p><p>Returns the type-name associated with the type represented by <span class="emphasis"><em>rtd.</em></span>
The returned value is eqv? to the type-name argument given in the call
to make-record-type that created the type represented by rtd.</p><p><a id="record-type-field-names"></a>
<span class="emphasis"><em> Procedure record-type-field-names</em></span>
<p>
<a id="id2539977" class="indexterm"></a>
<code class="literal">(record-type-field-names <span class="emphasis"><em>rtd</em></span>) </code>
</p></p><p>Returns a list of the symbols naming the fields in members of the type
represented by <span class="emphasis"><em>rtd.</em></span></p><p><a id="record-type-parent"></a>
<span class="emphasis"><em> Procedure record-type-parent</em></span>
<p>
<a id="id2540020" class="indexterm"></a>
<code class="literal">(record-type-parent <span class="emphasis"><em>rtd</em></span>) </code>
</p></p><p>Returns a record-type descriptor for the parent type of the type
represented by <span class="emphasis"><em>rtd</em></span>, if that type has a parent type, or a false value
otherwise. The type represented by <span class="emphasis"><em>rtd</em></span> has a parent type if the call
to make-record-type that created <span class="emphasis"><em>rtd</em></span> provided the <span class="emphasis"><em>parent-rtd</em></span>
argument.</p><p><a id="record-type-extends?"></a>
<span class="emphasis"><em> Procedure record-type-extends?</em></span>
<p>
<a id="id2540080" class="indexterm"></a>
<code class="literal">(record-type-extends? <span class="emphasis"><em>rtd1 rtd2</em></span>) </code>
</p></p><p>Returns a true value if the type represented by <span class="emphasis"><em>rtd1</em></span> is a subtype of
the type represented by <span class="emphasis"><em>rtd2</em></span> and a false value otherwise. A type <span class="emphasis"><em>s</em></span>
is a subtype of a type <span class="emphasis"><em>t</em></span> if <span class="emphasis"><em>s=t</em></span> or if the parent type of <span class="emphasis"><em>s</em></span>, if
it exists, is a subtype of <span class="emphasis"><em>t.</em></span></p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2540132"></a>11.7.2. Implementation</h4></div></div></div><p>The R6RS spouts some tendentious nonsense about procedural
records being slower than syntactic records, but this is not
true of Larceny's records, and is unlikely to be true of other
implementations either.
Larceny's procedural records are fairly efficient already,
and will become even more efficient in future versions as
interlibrary optimizations are added.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2540153"></a>11.8. Input, Output, and Files</h3></div></div></div><p>The <code class="literal">(scheme base)</code>, <code class="literal">(scheme file)</code>, <code class="literal">(rnrs io ports)</code>,
and <code class="literal">(rnrs files)</code> libraries now
provide a set of procedures that may supersede some
of the procedures described below.
If one of Larceny's procedures duplicates the semantics of
an R7RS or R6RS procedure whose name is different, then Larceny's
name is deprecated.</p><p><a id="close-open-files"></a>
<span class="emphasis"><em> Procedure close-open-files</em></span>
<p>
<a id="id2540209" class="indexterm"></a>
<code class="literal">(close-open-files <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Closes all open files.</p><p><a id="console-input-port"></a>
<span class="emphasis"><em> Procedure console-input-port</em></span>
<p>
<a id="id2540249" class="indexterm"></a>
<code class="literal">(console-input-port <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>input-port</em></span></code>
</p></p><p>Returns a character input port such that no read from the port has
signalled an error or returned the end-of-file object.</p><p><span class="emphasis"><em>Rationale:</em></span> console-input-port and console-output-port are artifacts
of Unix interactive I/O conventions, where an interactive end-of-file
does not mean "quit" but rather "done here". Under these conventions
the console port should be reset following an end-of-file. Resetting
conflicts with the semantics of ports in Scheme, so console-input-port
and console-output-port return a new port if the current port is
already at end-of-file.</p><p>Since it is convenient to handle errors in the same manner as
end-of-file, these procedures also return a new port if an error has
been signalled during an I/O operation on the port.</p><p>Console-input-port and console-output-port simply call the port
generators installed in the parameters console-input-port-factory and
console-output-port-factory, which allow user programs to install
their own console port generators.</p><p><a id="console-output-port"></a>
<span class="emphasis"><em> Procedure console-output-port</em></span>
<p>
<a id="id2540325" class="indexterm"></a>
<code class="literal">(console-output-port <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>output-port</em></span></code>
</p></p><p>Returns a character output port such that no write to the port has
signalled an error.</p><p>See console-input-port for a full explanation.</p><p><a id="console-input-port-factory"></a>
<a id="id2540367" class="indexterm"></a>
<span class="emphasis"><em>Parameter console-input-port-factory</em></span></p><p>The value of this parameter is a procedure that returns a character
input port such that no read from the port has signalled an error or
returned the end-of-file object.</p><p>See console-input-port for a full explanation.</p><p><a id="console-output-port-factory"></a>
<a id="id2540403" class="indexterm"></a>
<span class="emphasis"><em>Parameter console-output-port-factory</em></span></p><p>The value of this parameter is a procedure that returns a character
output port such that no write the port has signalled an error.</p><p>See console-input-port for a full explanation.</p><p><a id="current-input-port"></a>
<a id="id2540438" class="indexterm"></a>
<span class="emphasis"><em>Parameter current-input-port</em></span></p><p>The value of this parameter is a character input port.</p><p><a id="current-output-port"></a>
<a id="id2540466" class="indexterm"></a>
<span class="emphasis"><em>Parameter current-output-port</em></span></p><p>The value of this parameter is a character output port.</p><p><a id="delete-file"></a>
<span class="emphasis"><em> Procedure delete-file</em></span>
<p>
<a id="id2540498" class="indexterm"></a>
<code class="literal">(delete-file <span class="emphasis"><em>filename</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Deletes the named file. No error is signalled if the file does not
exist.</p><p><a id="eof-object"></a>
<span class="emphasis"><em> Procedure eof-object</em></span>
<p>
<a id="id2540540" class="indexterm"></a>
<code class="literal">(eof-object <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>end-of-file object</em></span></code>
</p></p><p><span class="emphasis"><em>Eof-object</em></span> returns an end-of-file object.</p><p><a id="file-exists?"></a>
<span class="emphasis"><em> Procedure file-exists?</em></span>
<p>
<a id="id2540581" class="indexterm"></a>
<code class="literal">(file-exists? <span class="emphasis"><em>filename</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>File-exists? returns #t if the named file exists at the time the
procedure is called.</p><p><a id="file-modification-time"></a>
<span class="emphasis"><em> Procedure file-modification-time</em></span>
<p>
<a id="id2540625" class="indexterm"></a>
<code class="literal">(file-modification-time <span class="emphasis"><em>filename</em></span>)  =&gt; <span class="emphasis"><em>vector or #f</em></span></code>
</p></p><p>File-modification-time returns the time of last modification of the
file as a vector, or #f if the file does not exist. The vector has six
elements: year, month, day, hour, minute, second, all of which are
exact nonnegative integers. The time returned is relative to the local
timezone.</p><p><code class="literal">     (file-modification-time "larceny") =&gt; #(1997 2 6 12 51 13)</code></p><p><code class="literal">     (file-modification-time "geekdom") =&gt; #f</code></p><p><a id="flush-output-port"></a>
<span class="emphasis"><em> Procedure flush-output-port</em></span>
<p>
<a id="id2540692" class="indexterm"></a>
<code class="literal">(flush-output-port <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p>
<p><code class="literal">(flush-output-port <span class="emphasis"><em>port</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p>Write any buffered data in the port to the underlying output medium.</p><p><a id="get-output-string"></a>
<span class="emphasis"><em> Procedure get-output-string</em></span>
<p>
<a id="id2540746" class="indexterm"></a>
<code class="literal">(get-output-string <span class="emphasis"><em>string-output-port</em></span>)  =&gt; <span class="emphasis"><em>string</em></span></code>
</p></p><p>Retrieve the output string from the given string output port.</p><p><a id="open-input-string"></a>
<span class="emphasis"><em> Procedure open-input-string</em></span>
<p>
<a id="id2540788" class="indexterm"></a>
<code class="literal">(open-input-string <span class="emphasis"><em>string</em></span>)  =&gt; <span class="emphasis"><em>input-port</em></span></code>
</p></p><p>Creates an input port that reads from <span class="emphasis"><em>string</em></span>. The string may be
shared with the caller. A string input port does not need to be
closed, although closing it will prevent further reads from it.</p><p><a id="open-output-string"></a>
<span class="emphasis"><em> Procedure open-output-string</em></span>
<p>
<a id="id2540836" class="indexterm"></a>
<code class="literal">(open-output-string <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>output-port</em></span></code>
</p></p><p>Creates an output port where any output is written to a string. The
accumulated string can be retrieved with
<a class="xref" href="#get-output-string">get-output-string</a> at any time.</p><p><a id="port?"></a>
<span class="emphasis"><em> Procedure port?</em></span>
<p>
<a id="id2540885" class="indexterm"></a>
<code class="literal">(port? <span class="emphasis"><em>object</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>Tests whether its argument is a port.</p><p><a id="port-name"></a>
<span class="emphasis"><em> Procedure port-name</em></span>
<p>
<a id="id2540926" class="indexterm"></a>
<code class="literal">(port-name <span class="emphasis"><em>port</em></span>)  =&gt; <span class="emphasis"><em>string</em></span></code>
</p></p><p>Returns the name associated with the port; for file ports, this is the file name.</p><p><a id="port-position"></a>
<span class="emphasis"><em> Procedure port-position</em></span>
<p>
<a id="id2540967" class="indexterm"></a>
<code class="literal">(port-position <span class="emphasis"><em>port</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns the number of characters that have been read from or written to the port.</p><p><a id="rename-file"></a>
<span class="emphasis"><em> Procedure rename-file</em></span>
<p>
<a id="id2541008" class="indexterm"></a>
<code class="literal">(rename-file <span class="emphasis"><em>from to</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Renames the file <span class="emphasis"><em>from</em></span> and gives it the name <span class="emphasis"><em>to</em></span>. No error is
signalled if <span class="emphasis"><em>from</em></span> does not exist or <span class="emphasis"><em>to</em></span> exists.</p><p><a id="reset-output-string"></a>
<span class="emphasis"><em> Procedure reset-output-string</em></span>
<p>
<a id="id2541064" class="indexterm"></a>
<code class="literal">(reset-output-string <span class="emphasis"><em>port</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Given a <span class="emphasis"><em>port</em></span> created with <span class="emphasis"><em>open-output-string</em></span>, deletes from the
port all the characters that have been output so far.</p><p><a id="with-input-from-port"></a>
<span class="emphasis"><em> Procedure with-input-from-port</em></span>
<p>
<a id="id2541115" class="indexterm"></a>
<code class="literal">(with-input-from-port <span class="emphasis"><em>input-port thunk</em></span>)  =&gt; <span class="emphasis"><em>object</em></span></code>
</p></p><p>Calls <span class="emphasis"><em>thunk</em></span> with current input bound to <span class="emphasis"><em>input-port</em></span> in the dynamic
extent of <span class="emphasis"><em>thunk</em></span>. Returns whatever value was returned from <span class="emphasis"><em>thunk</em></span>.</p><p><a id="with-output-to-port"></a>
<span class="emphasis"><em> Procedure with-output-to-port</em></span>
<p>
<a id="id2541171" class="indexterm"></a>
<code class="literal">(with-output-to-port <span class="emphasis"><em>output-port thunk</em></span>)  =&gt; <span class="emphasis"><em>object</em></span></code>
</p></p><p>Calls <span class="emphasis"><em>thunk</em></span> with current output bound to <span class="emphasis"><em>output-port</em></span> in the
dynamic extent of <span class="emphasis"><em>thunk</em></span>. Returns whatever value was returned from
<span class="emphasis"><em>thunk</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2541215"></a>11.9. Operating System Interface</h3></div></div></div><p><a id="command-line-arguments"></a>
<span class="emphasis"><em> Procedure command-line-arguments</em></span>
<p>
<a id="id2541237" class="indexterm"></a>
<code class="literal">(command-line-arguments <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>vector</em></span></code>
</p></p><p>Returns a vector of strings: the arguments supplied to the program by
the user or the operating system.</p><p><a id="dump-heap"></a>
<span class="emphasis"><em> Procedure dump-heap</em></span>
<p>
<a id="id2541279" class="indexterm"></a>
<code class="literal">(dump-heap <span class="emphasis"><em>filename procedure</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Dump a heap image to the named file that will start up with the
supplied procedure. Before <span class="emphasis"><em>procedure</em></span> is called, command line
arguments will be parsed and any init procedures registered with
<code class="literal">add-init-procedure!</code>  will be called.</p><p><span class="emphasis"><em>Note: Currently, heap dumping is only available with the
stop-and-copy collector (<code class="literal">-stopcopy</code> command line option), although the
heap image can be used with all the other collectors.</em></span></p><p><a id="dump-interactive-heap"></a>
<span class="emphasis"><em> Procedure dump-interactive-heap</em></span>
<p>
<a id="id2541352" class="indexterm"></a>
<code class="literal">(dump-interactive-heap <span class="emphasis"><em>filename</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Dump a heap image to the named file that will start up with the
standard read-eval-print loop. Before the read-eval-print loop is
called, command line arguments will be parsed and any init procedures
registered with <code class="literal">add-init-procedure!</code>
will be called.</p><p><span class="emphasis"><em>Note: Currently, heap dumping is only available with the
stop-and-copy collector (<code class="literal">-stopcopy</code> command line option), although the
heap image can be used with all the other collectors.</em></span></p><p><a id="getenv"></a>
<span class="emphasis"><em> Procedure getenv</em></span>
<p>
<a id="id2541419" class="indexterm"></a>
<code class="literal">(getenv <span class="emphasis"><em>key</em></span>)  =&gt; <span class="emphasis"><em>string or #f</em></span></code>
</p></p><p>Returns the operating system environment mapping for the string <span class="emphasis"><em>key</em></span>,
or <code class="literal">#f</code> if there is no mapping for <span class="emphasis"><em>key</em></span>.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>This is now a synonym for the <code class="literal">get-environment-variable</code>
exported by the <code class="literal">(scheme process-context)</code> library.</p></div><p><a id="setenv"></a>
<span class="emphasis"><em> Procedure setenv</em></span>
<p>
<a id="id2541492" class="indexterm"></a>
<code class="literal">(setenv <span class="emphasis"><em>key val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Sets the operating system environment mapping for the string <span class="emphasis"><em>key</em></span>
to <span class="emphasis"><em>val</em></span>.</p><p><a id="system"></a>
<span class="emphasis"><em> Procedure system</em></span>
<p>
<a id="id2541540" class="indexterm"></a>
<code class="literal">(system <span class="emphasis"><em>command</em></span>)  =&gt; <span class="emphasis"><em>status</em></span></code>
</p></p><p>Send the <span class="emphasis"><em>command</em></span> to the operating system's command processor and
return the command's exit status, if any. On Unix, <span class="emphasis"><em>command</em></span> is a
string and <span class="emphasis"><em>status</em></span> is an exact integer.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="FixnumPrimitives"></a>11.10. Fixnum primitives</h3></div></div></div><p>Fixnums are small exact integers that are likely to be
represented without heap
allocation. Larceny never represents a number that can be
represented as a fixnum any other way, so programs that can use
fixnums will do so automatically. However, operations that work only
on fixnums can sometimes be substantially faster than generic
operations, and the following primitives are provided for use in those
programs that need especially good performance.</p><p>The <code class="literal">(rnrs arithmetic fixnums)</code> library now
provides a large set of procedures, some of them similar to
the procedures described below.
If one of Larceny's procedures duplicates the semantics of
an R6RS procedure whose name is different, then Larceny's
name is deprecated within R7RS/R6RS code.</p><p>All arguments to the following procedures must be fixnums.</p><p><a id="fixnum?"></a>
<span class="emphasis"><em> Procedure fixnum?</em></span>
<p>
<a id="id2541648" class="indexterm"></a>
<code class="literal">(fixnum? <span class="emphasis"><em>obj</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>Returns <code class="literal">#t</code> if its argument is a fixnum, and <code class="literal">#f</code> otherwise.</p><p><a id="fx+"></a>
<span class="emphasis"><em> Procedure fx+</em></span>
<p>
<a id="id2541698" class="indexterm"></a>
<code class="literal">(fx+ <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns the fixnum sum of its arguments. If the result is not
representable as a fixnum, then an error is signalled (unless error
checking has been disabled).</p><p><a id="fx-"></a>
<span class="emphasis"><em> Procedure fx-</em></span>
<p>
<a id="id2541741" class="indexterm"></a>
</p></p><p>Returns the fixnum difference of its arguments. If the result is not
representable as a fixnum, then an error is signalled.</p><p><a id="fx&#x2014;"></a>
<span class="emphasis"><em> Procedure fx—</em></span>
<p>
<a id="id2541773" class="indexterm"></a>
<code class="literal">(fx— <span class="emphasis"><em>fix1</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns the fixnum negative of its argument. If the result is not
representable as a fixnum, then an error is signalled.</p><p><a id="fx*"></a>
<span class="emphasis"><em> Procedure fx*</em></span>
<p>
<a id="id2541816" class="indexterm"></a>
<code class="literal">(fx* <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns the fixnum product of its arguments. If the result is not
representable as a fixnum, then an error is signalled.</p><p><a id="fx="></a>
<span class="emphasis"><em> Procedure fx=</em></span>
<p>
<a id="id2541859" class="indexterm"></a>
<code class="literal">(fx= <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>Returns <code class="literal">#t</code> if its arguments are equal, and <code class="literal">#f</code> otherwise.</p><p><a id="fx&lt;"></a>
<span class="emphasis"><em> Procedure fx&lt;</em></span>
<p>
<a id="id2541910" class="indexterm"></a>
<code class="literal">(fx&lt; <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>Returns <code class="literal">#t</code> if <span class="emphasis"><em>fix1</em></span> is less than <span class="emphasis"><em>fix2</em></span>, and <code class="literal">#f</code> otherwise.</p><p><a id="fx&lt;="></a>
<span class="emphasis"><em> Procedure fx&lt;=</em></span>
<p>
<a id="id2541970" class="indexterm"></a>
<code class="literal">(fx&lt;= <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>Returns <code class="literal">#t</code> if <span class="emphasis"><em>fix1</em></span> is less than or equal to <span class="emphasis"><em>fix2</em></span>, and <code class="literal">#f</code>
otherwise.</p><p><a id="fx&gt;"></a>
<span class="emphasis"><em> Procedure fx&gt;</em></span>
<p>
<a id="id2542028" class="indexterm"></a>
<code class="literal">(fx&gt; <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>Returns <code class="literal">#t</code> if <span class="emphasis"><em>fix1</em></span> is greater than <span class="emphasis"><em>fix2</em></span>, and <code class="literal">#f</code> otherwise.</p><p><a id="fx&gt;="></a>
<span class="emphasis"><em> Procedure fx&gt;=</em></span>
<p>
<a id="id2542087" class="indexterm"></a>
<code class="literal">(fx&gt;= <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>Returns <code class="literal">#t</code> if <span class="emphasis"><em>fix1</em></span> is greater than or equal to <span class="emphasis"><em>fix2</em></span>, and <code class="literal">#f</code>
otherwise.</p><p><a id="fxnegative?"></a>
<span class="emphasis"><em> Procedure fxnegative?</em></span>
<p>
<a id="id2542146" class="indexterm"></a>
<code class="literal">(fxnegative? <span class="emphasis"><em>fix</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>Returns <code class="literal">#t</code> if its argument is less than zero, and <code class="literal">#f</code> otherwise.</p><p><a id="fxpositive?"></a>
<span class="emphasis"><em> Procedure fxpositive?</em></span>
<p>
<a id="id2542199" class="indexterm"></a>
<code class="literal">(fxpositive? <span class="emphasis"><em>fix</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>Returns <code class="literal">#t</code> if its argument is greater than zero, and <code class="literal">#f</code> otherwise.</p><p><a id="fxzero?"></a>
<span class="emphasis"><em> Procedure fxzero?</em></span>
<p>
<a id="id2542250" class="indexterm"></a>
<code class="literal">(fxzero? <span class="emphasis"><em>fix</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>Returns <code class="literal">#t</code> if its argument is zero, and <code class="literal">#f</code> otherwise.</p><p><a id="fxlogand"></a>
<span class="emphasis"><em> Procedure fxlogand</em></span>
<p>
<a id="id2542302" class="indexterm"></a>
<code class="literal">(fxlogand <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns the bitwise <span class="emphasis"><em>and</em></span> of its arguments.</p><p><a id="fxlogior"></a>
<span class="emphasis"><em> Procedure fxlogior</em></span>
<p>
<a id="id2542345" class="indexterm"></a>
<code class="literal">(fxlogior <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns the bitwise <span class="emphasis"><em>inclusive or</em></span> of its arguments.</p><p><a id="fxlognot"></a>
<span class="emphasis"><em> Procedure fxlognot</em></span>
<p>
<a id="id2542388" class="indexterm"></a>
<code class="literal">(fxlognot <span class="emphasis"><em>fix</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns the bitwise <span class="emphasis"><em>not</em></span> of its argument.</p><p><a id="fxlogxor"></a>
<span class="emphasis"><em> Procedure fxlogxor</em></span>
<p>
<a id="id2542432" class="indexterm"></a>
<code class="literal">(fxlogxor <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns the bitwise <span class="emphasis"><em>exclusive or</em></span> of its arguments.</p><p><a id="fxlsh"></a>
<span class="emphasis"><em> Procedure fxlsh</em></span>
<p>
<a id="id2542476" class="indexterm"></a>
<code class="literal">(fxlsh <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns <span class="emphasis"><em>fix1</em></span> shifted left <span class="emphasis"><em>fix2</em></span> places, shifting in zero bits at
the low end. If the shift count exceeds the number of bits in the
machine's word size, then the results are machine-dependent.</p><p><a id="most-positive-fixnum"></a>
<span class="emphasis"><em> Procedure most-positive-fixnum</em></span>
<p>
<a id="id2542528" class="indexterm"></a>
<code class="literal">(most-positive-fixnum <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns the largest representable positive fixnum.</p><p><a id="most-negative-fixnum"></a>
<span class="emphasis"><em> Procedure most-negative-fixnum</em></span>
<p>
<a id="id2542568" class="indexterm"></a>
<code class="literal">(most-negative-fixnum <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns the smallest representable negative fixnum.</p><p><a id="fxrsha"></a>
<span class="emphasis"><em> Procedure fxrsha</em></span>
<p>
<a id="id2542608" class="indexterm"></a>
<code class="literal">(fxrsha <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns <span class="emphasis"><em>fix1</em></span> shifted right <span class="emphasis"><em>fix2</em></span> places, shifting in a copy of the
sign bit at the left end. If the shift count exceeds the number of
bits in the machine's word size, then the results are
machine-dependent.</p><p><a id="fxrshl"></a>
<span class="emphasis"><em> Procedure fxrshl</em></span>
<p>
<a id="id2542658" class="indexterm"></a>
<code class="literal">(fxrshl <span class="emphasis"><em>fix1 fix2</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns <span class="emphasis"><em>fix1</em></span> shifted right <span class="emphasis"><em>fix2</em></span> places, shifting in zero bits at
the high end. If the shift count exceeds the number of bits in the
machine's word size, then the results are machine-dependent.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2542695"></a>11.11. Numbers</h3></div></div></div><p>Larceny has six representations for numbers: <span class="emphasis"><em>fixnums</em></span> are small,
exact integers; <span class="emphasis"><em>bignums</em></span> are unlimited-precision exact integers;
<span class="emphasis"><em>ratnums</em></span> are exact rationals; <span class="emphasis"><em>flonums</em></span> are inexact rationals;
<span class="emphasis"><em>rectnums</em></span> are exact complexes; and <span class="emphasis"><em>compnums</em></span> are inexact complexes.</p><p><span class="emphasis"><em>Number-representation predicates</em></span></p><p><p><code class="literal">(fixnum? <span class="emphasis"><em>obj</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code></p>
<p><code class="literal">(bignum? <span class="emphasis"><em>obj</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code></p>
<p><code class="literal">(ratnum? <span class="emphasis"><em>obj</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code></p>
<p><code class="literal">(flonum? <span class="emphasis"><em>obj</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code></p>
<p><code class="literal">(rectnum? <span class="emphasis"><em>obj</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code></p>
<p><code class="literal">(compnum? <span class="emphasis"><em>obj</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code></p></p><p>These predicates test whether an object is a number of a particular
representation and return <code class="literal">#t</code> if so, <code class="literal">#f</code> if not.</p><p><a id="random"></a>
<span class="emphasis"><em> Procedure random</em></span>
<p>
<a id="id2542847" class="indexterm"></a>
<code class="literal">(random <span class="emphasis"><em>limit</em></span>)  =&gt; <span class="emphasis"><em>exact integer</em></span></code>
</p></p><p>Returns a pseudorandom nonnegative exact integer in the range 0
through <span class="emphasis"><em>limit</em></span>-1.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2542878"></a>11.12. Hashtables and hash functions</h3></div></div></div><p>Hashtables represent finite mappings from keys to values.
If the hash function is a good one, then the value associated
with a key may be looked up in constant time (on the average).</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The R6RS hashtables library are a big improvement
over Larceny's traditional hash tables, and should be used
instead of the API described below.</p></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>To resolve a clash of names and semantics with the
R6RS <code class="literal">make-hashtable</code> procedure, Larceny's traditional
<code class="literal">make-hashtable</code> procedure has been renamed to
<code class="literal">make-oldstyle-hashtable</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2542931"></a>11.12.1. Hash tables</h4></div></div></div><p><a id="make-oldstyle-hashtable"></a>
<span class="emphasis"><em> Procedure make-oldstyle-hashtable</em></span>
<p>
<a id="id2542953" class="indexterm"></a>
<code class="literal">(make-oldstyle-hashtable <span class="emphasis"><em>hash-function bucket-searcher size</em></span>)  =&gt; <span class="emphasis"><em>hashtable</em></span></code>
</p></p><p>Returns a newly allocated mutable hash table using <span class="emphasis"><em>hash-function</em></span> as
the hash function and <span class="emphasis"><em>bucket-searcher</em></span>, e.g. <code class="literal">assq</code>, <code class="literal">assv</code>, <code class="literal">assoc</code>, to
search a bucket with <span class="emphasis"><em>size</em></span> buckets at first, expanding the number of
buckets as needed. The <span class="emphasis"><em>hash-function</em></span> must accept a key and return a
non-negative exact integer.</p><p><p><code class="literal">(make-oldstyle-hashtable <span class="emphasis"><em>hash-function bucket-searcher</em></span>)  =&gt; <span class="emphasis"><em>hashtable</em></span></code></p></p><p>Equivalent to <code class="literal">(make-oldstyle-hashtable <span class="emphasis"><em>hash-function bucket-searcher n</em></span>)</code> for
some value of <span class="emphasis"><em>n</em></span> chosen by the implementation.</p><p><p><code class="literal">(make-oldstyle-hashtable <span class="emphasis"><em>hash-function</em></span>)  =&gt; <span class="emphasis"><em>hashtable</em></span></code></p></p><p>Equivalent to <code class="literal">(make-oldstyle-hashtable <span class="emphasis"><em>hash-function</em></span> assv)</code>.</p><p><p><code class="literal">(make-oldstyle-hashtable <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>hashtable</em></span></code></p></p><p>Equivalent to <code class="literal">(make-oldstyle-hashtable object-hash assv)</code>.</p><p><a id="hashtable-contains?"></a>
<span class="emphasis"><em> Procedure hashtable-contains?</em></span>
<p>
<a id="id2543118" class="indexterm"></a>
<code class="literal">(hashtable-contains? <span class="emphasis"><em>hashtable key</em></span>)  =&gt; <span class="emphasis"><em>bool</em></span></code>
</p></p><p>Returns true iff the <span class="emphasis"><em>hashtable</em></span> contains an entry for <span class="emphasis"><em>key</em></span>.</p><p><a id="hashtable-fetch"></a>
<span class="emphasis"><em> Procedure hashtable-fetch</em></span>
<p>
<a id="id2543166" class="indexterm"></a>
<code class="literal">(hashtable-fetch <span class="emphasis"><em>hashtable key flag</em></span>)  =&gt; <span class="emphasis"><em>object</em></span></code>
</p></p><p>Returns the value associated with <span class="emphasis"><em>key</em></span> in the <span class="emphasis"><em>hashtable</em></span> if the
<span class="emphasis"><em>hashtable</em></span> contains <span class="emphasis"><em>key</em></span>; otherwise returns <span class="emphasis"><em>flag</em></span>.</p><p><a id="hashtable-get"></a>
<span class="emphasis"><em> Procedure hashtable-get</em></span>
<p>
<a id="id2543226" class="indexterm"></a>
<code class="literal">(hashtable-get <span class="emphasis"><em>hashtable key</em></span>)  =&gt; <span class="emphasis"><em>object</em></span></code>
</p></p><p>Equivalent to <code class="literal">(hashtable-fetch  #f)</code>.</p><p><a id="hashtable-put!"></a>
<span class="emphasis"><em> Procedure hashtable-put!</em></span>
<p>
<a id="id2543273" class="indexterm"></a>
<code class="literal">(hashtable-put! <span class="emphasis"><em>hashtable key value</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Changes the <span class="emphasis"><em>hashtable</em></span> to associate <span class="emphasis"><em>key</em></span> with <span class="emphasis"><em>value</em></span>, replacing any
existing association for <span class="emphasis"><em>key</em></span>.</p><p><a id="hashtable-remove!"></a>
<span class="emphasis"><em> Procedure hashtable-remove!</em></span>
<p>
<a id="id2543330" class="indexterm"></a>
<code class="literal">(hashtable-remove! <span class="emphasis"><em>hashtable key</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Removes any association for <span class="emphasis"><em>key</em></span> within the <span class="emphasis"><em>hashtable</em></span>.</p><p><a id="hashtable-clear!"></a>
<span class="emphasis"><em> Procedure hashtable-clear!</em></span>
<p>
<a id="id2543378" class="indexterm"></a>
<code class="literal">(hashtable-clear! <span class="emphasis"><em>hashtable</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Removes all associations from the <span class="emphasis"><em>hashtable</em></span>.</p><p><a id="hashtable-size"></a>
<span class="emphasis"><em> Procedure hashtable-size</em></span>
<p>
<a id="id2543422" class="indexterm"></a>
<code class="literal">(hashtable-size <span class="emphasis"><em>hashtable</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code>
</p></p><p>Returns the number of keys contained within the <span class="emphasis"><em>hashtable</em></span>.</p><p><a id="hashtable-for-each"></a>
<span class="emphasis"><em> Procedure hashtable-for-each</em></span>
<p>
<a id="id2543466" class="indexterm"></a>
<code class="literal">(hashtable-for-each <span class="emphasis"><em>procedure hashtable</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>The <span class="emphasis"><em>procedure</em></span> must accept two arguments, a key and the value
associated with that key. Calls the <span class="emphasis"><em>procedure</em></span> once for each
key-value association in <span class="emphasis"><em>hashtable</em></span>. The order of these calls is
indeterminate.</p><p><a id="hashtable-map"></a>
<span class="emphasis"><em> Procedure hashtable-map</em></span>
<p>
<a id="id2543524" class="indexterm"></a>
<code class="literal">(hashtable-map <span class="emphasis"><em>procedure hashtable</em></span>) </code>
</p></p><p>The <span class="emphasis"><em>procedure</em></span> must accept two arguments, a key and the value
associated with that key. Calls the <span class="emphasis"><em>procedure</em></span> once for each
key-value association in <span class="emphasis"><em>hashtable</em></span>, and returns a list of the
results. The order of the calls is indeterminate.</p><p><a id="hashtable-copy"></a>
<span class="emphasis"><em> Procedure hashtable-copy</em></span>
<p>
<a id="id2543579" class="indexterm"></a>
<code class="literal">(hashtable-copy <span class="emphasis"><em>hashtable</em></span>)  =&gt; <span class="emphasis"><em>hashtable</em></span></code>
</p></p><p>Returns a copy of the <span class="emphasis"><em>hashtable</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2543609"></a>11.12.2. Hash functions</h4></div></div></div><p>The <span class="emphasis"><em>hash values</em></span> returned by these functions are nonnegative exact
integer suitable as hash values for the hashtable functions.</p><p><a id="equal-hash"></a>
<span class="emphasis"><em> Procedure equal-hash</em></span>
<p>
<a id="id2543641" class="indexterm"></a>
<code class="literal">(equal-hash <span class="emphasis"><em>object</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code>
</p></p><p>Returns a hash value for <span class="emphasis"><em>object</em></span> based on its contents.</p><p><a id="object-hash"></a>
<span class="emphasis"><em> Procedure object-hash</em></span>
<p>
<a id="id2543685" class="indexterm"></a>
<code class="literal">(object-hash <span class="emphasis"><em>object</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code>
</p></p><p>Returns a hash value for <span class="emphasis"><em>object</em></span> based on its identity.</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>This hash function performs extremely poorly on pairs,
vectors, strings, and bytevectors, which are the objects
with which it is mostly likely to be used.
For efficient hashing on object identity, create the
hashtable with <code class="literal">make-eq-hashtable</code> or <code class="literal">make-eqv-hashtable</code>
of the <code class="literal">(rnrs hashtables)</code> library.</p></div><p><a id="string-hash"></a>
<span class="emphasis"><em> Procedure string-hash</em></span>
<p>
<a id="id2543758" class="indexterm"></a>
<code class="literal">(string-hash <span class="emphasis"><em>string</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns a hash value for <span class="emphasis"><em>string</em></span> based on its content.</p><p><a id="symbol-hash"></a>
<span class="emphasis"><em> Procedure symbol-hash</em></span>
<p>
<a id="id2543802" class="indexterm"></a>
<code class="literal">(symbol-hash <span class="emphasis"><em>symbol</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p>Returns a hash value for <span class="emphasis"><em>symbol</em></span> based on its print name.
The <code class="literal">symbol-hash</code>
is very fast, because the hash code is cached in the symbol data
structure.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2543843"></a>11.13. Parameters</h3></div></div></div><p>Parameters are procedures that serve as containers for values.</p><p>When called with no arguments, a parameter returns its current value.
The value of a parameter can be changed temporarily using the
<span class="emphasis"><em>parameterize</em></span> syntax described below.</p><p>The effect of passing arguments to a parameter is implementation-dependent.
In Larceny, passing one argument to a parameter changes the current value
of the parameter to the result of applying a <span class="emphasis"><em>converter</em></span> procedure to that
argument, as described by SRFI 39.</p><p><a id="make-parameter"></a>
<span class="emphasis"><em> Procedure make-parameter</em></span>
<p>
<a id="id2543894" class="indexterm"></a>
<code class="literal">(make-parameter <span class="emphasis"><em>init</em></span>)  =&gt; <span class="emphasis"><em>procedure</em></span></code>
</p>
<p><code class="literal">(make-parameter <span class="emphasis"><em>init converter</em></span>)  =&gt; <span class="emphasis"><em>procedure</em></span></code></p>
<p><code class="literal">(make-parameter <span class="emphasis"><em>name init predicate</em></span>)  =&gt; <span class="emphasis"><em>procedure</em></span></code></p></p><p>Creates a parameter.</p><p>When <span class="emphasis"><em>make-parameter</em></span> is called with one argument <span class="emphasis"><em>init</em></span>,
the parameter's initial value is <span class="emphasis"><em>init</em></span>, and the parameter's
<span class="emphasis"><em>converter</em></span> will be the identity function.</p><p>When <span class="emphasis"><em>make-parameter</em></span> is called with two arguments,
<span class="emphasis"><em>converter</em></span> must be a procedure that accepts one argument,
and the parameter's initial value is the result of calling
<span class="emphasis"><em>converter</em></span> on <span class="emphasis"><em>init</em></span>.</p><p>Larceny extends SRFI 39 and the R7RS specification of <span class="emphasis"><em>make-parameter</em></span>
by allowing it to be called with three arguments.
The first argument, <span class="emphasis"><em>name,</em></span> must be a symbol or string giving the
print name of the parameter.
The second argument, <span class="emphasis"><em>init,</em></span> will be the initial value of the parameter.
The third argument is a <span class="emphasis"><em>predicate</em></span> from which Larceny constructs a
<span class="emphasis"><em>converter</em></span> procedure that acts like the identity function on arguments
that satisfy the <span class="emphasis"><em>predicate</em></span> but raises an exception on arguments that
don't.</p><p><p><code class="literal">(make-parameter <span class="emphasis"><em>name init</em></span>)  =&gt; <span class="emphasis"><em>procedure</em></span></code></p></p><p>Larceny's parameter objects predate SRFI 39.
For backward compatibility, Larceny's <span class="emphasis"><em>make-parameter</em></span> will
accept two arguments even if the second is not a procedure,
provided the first argument is a symbol or string.
In that special case, the two arguments will be treated as the
<span class="emphasis"><em>name</em></span> and <span class="emphasis"><em>init</em></span> arguments to Larceny's three-argument version,
with the <span class="emphasis"><em>predicate</em></span> defaulting to the identity function.
<span class="emphasis"><em>This extension is strongly deprecated.</em></span></p><p><span class="emphasis"><em>Syntax parameterize</em></span></p><p><code class="literal"> (parameterize ((parameter0 value0) …) expr0 expr1 …)</code></p><p><span class="emphasis"><em>Parameterize</em></span> temporarily overrides the values of a set of parameters
while the expressions in the body of the <span class="emphasis"><em>parameterize</em></span> expression are
evaluated.
(It is like <span class="emphasis"><em>fluid-let</em></span> for parameters instead of variables.)</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2544109"></a>11.13.1. Larceny parameters</h4></div></div></div><p>The following is a partial list of Larceny's parameters.
The first three are described by the R7RS standard.
Most of the others are intended for use by developers of Larceny;
some are described in Wiki pages at Larceny's GitHub site,
while others are described only by source code.</p><p><a class="ulink" href="io.html#proc:current-input-port" target="_top">Parameter <code class="literal">current-input-port</code></a></p><p><a class="ulink" href="io.html#proc:current-output-port" target="_top">Parameter <code class="literal">current-output-port</code></a></p><p><a class="ulink" href="io.html#proc:current-error-port" target="_top">Parameter <code class="literal">current-error-port</code></a></p><p><a class="ulink" href="io.html#proc:console-input-port-factory" target="_top">Parameter <code class="literal">console-input-port-factory</code></a></p><p><a class="ulink" href="io.html#proc:console-output-port-factory" target="_top">Parameter <code class="literal">console-output-port-factory</code></a></p><p><a class="ulink" href="repl.html#proc:herald" target="_top">Parameter <code class="literal">herald</code></a></p><p><a class="ulink" href="environ.html#proc:interaction-environment" target="_top">Parameter <code class="literal">interaction-environment</code></a></p><p><a class="ulink" href="control.html#proc:evaluator" target="_top">Parameter <code class="literal">evaluator</code></a></p><p><a class="ulink" href="control.html#proc:load-evaluator" target="_top">Parameter <code class="literal">load-evaluator</code></a></p><p><a class="ulink" href="repl.html#proc:repl-evaluator" target="_top">Parameter <code class="literal">repl-evaluator</code></a></p><p><a class="ulink" href="repl.html#proc:repl-level" target="_top">Parameter <code class="literal">repl-level</code></a></p><p><a class="ulink" href="repl.html#proc:repl-printer" target="_top">Parameter <code class="literal">repl-printer</code></a></p><p><a class="ulink" href="debugging.html#proc:break-handler" target="_top">Parameter <code class="literal">break-handler</code></a></p><p><a class="ulink" href="control.html#proc:error-handler" target="_top">Parameter <code class="literal">error-handler</code></a></p><p><a class="ulink" href="control.html#proc:quit-handler" target="_top">Parameter <code class="literal">quit-handler</code></a></p><p><a class="ulink" href="control.html#proc:reset-handler" target="_top">Parameter <code class="literal">reset-handler</code></a></p><p><a class="ulink" href="control.html#proc:keyboard-interrupt-handler" target="_top">Parameter <code class="literal">keyboard-interrupt-handler</code></a></p><p><a class="ulink" href="control.html#proc:timer-interrupt-handler" target="_top">Parameter <code class="literal">timer-interrupt-handler</code></a></p><p><a class="ulink" href="control.html#proc:standard-timeslice" target="_top">Parameter <code class="literal">standard-timeslice</code></a></p><p><a class="ulink" href="structures.html#proc:structure-comparator" target="_top">Parameter <code class="literal">structure-comparator</code></a></p><p><a class="ulink" href="structures.html#proc:structure-printer" target="_top">Parameter <code class="literal">structure-printer</code></a></p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2544388"></a>11.14. Property Lists</h3></div></div></div><p>The <span class="emphasis"><em>property list</em></span> of a symbol is an association list that is
attached to that symbol. The association list maps <span class="emphasis"><em>properties</em></span>, which
are themselves symbols, to arbitrary values.</p><p><a id="putprop"></a>
<span class="emphasis"><em> Procedure putprop</em></span>
<p>
<a id="id2544424" class="indexterm"></a>
<code class="literal">(putprop <span class="emphasis"><em>symbol property obj</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>If an association exists for <span class="emphasis"><em>property</em></span> on the property list of
<span class="emphasis"><em>symbol</em></span>, then its value is replaced by the new value
<span class="emphasis"><em>obj</em></span>. Otherwise, a new association is added to the property list of
<span class="emphasis"><em>symbol</em></span> that associates <span class="emphasis"><em>property</em></span> with <span class="emphasis"><em>obj</em></span>.</p><p><a id="getprop"></a>
<span class="emphasis"><em> Procedure getprop</em></span>
<p>
<a id="id2544491" class="indexterm"></a>
<code class="literal">(getprop <span class="emphasis"><em>symbol property</em></span>)  =&gt; <span class="emphasis"><em>obj</em></span></code>
</p></p><p>If an association exists for <span class="emphasis"><em>property</em></span> on the property list of
<span class="emphasis"><em>symbol</em></span>, then its value is returned. Otherwise, <code class="literal">#f</code> is returned.</p><p><a id="remprop"></a>
<span class="emphasis"><em> Procedure remprop</em></span>
<p>
<a id="id2544546" class="indexterm"></a>
<code class="literal">(remprop <span class="emphasis"><em>symbol property</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>If an association exists for <span class="emphasis"><em>property</em></span> on the property list of
<span class="emphasis"><em>symbol</em></span>, then that association is removed. Otherwise, this is a
no-op.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2544582"></a>11.15. Symbols</h3></div></div></div><p><a id="gensym"></a>
<span class="emphasis"><em> Procedure gensym</em></span>
<p>
<a id="id2544602" class="indexterm"></a>
<code class="literal">(gensym <span class="emphasis"><em>string</em></span>)  =&gt; <span class="emphasis"><em>symbol</em></span></code>
</p></p><p>Gensym returns a new uninterned symbol, the name of which contains the
given <span class="emphasis"><em>string.</em></span></p><p><a id="oblist"></a>
<span class="emphasis"><em> Procedure oblist</em></span>
<p>
<a id="id2544647" class="indexterm"></a>
<code class="literal">(oblist <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>list</em></span></code>
</p></p><p>Oblist returns the list of interned symbols.</p><p><a id="oblist-set!"></a>
<span class="emphasis"><em> Procedure oblist-set!</em></span>
<p>
<a id="id2544686" class="indexterm"></a>
<code class="literal">(oblist-set! <span class="emphasis"><em>list</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p>
<p><code class="literal">(oblist-set! <span class="emphasis"><em>list table-size</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p><code class="literal">oblist-set!</code> sets the list of interned symbols to those in the given
<span class="emphasis"><em>list</em></span> by clearing the symbol hash table and storing the symbols in
<span class="emphasis"><em>list</em></span> in the hash table. If the optional <span class="emphasis"><em>table-size</em></span> is given, it is
taken to be the desired size of the new symbol table.</p><p>See also: <a class="xref" href="#symbol-hash">symbol-hash</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2544757"></a>11.16. System Control and Performance Measurement</h3></div></div></div><p><a id="collect"></a>
<span class="emphasis"><em> Procedure collect</em></span>
<p>
<a id="id2544778" class="indexterm"></a>
<code class="literal">(collect <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p>
<p><code class="literal">(collect <span class="emphasis"><em>generation</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(collect <span class="emphasis"><em>generation method</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p>Collect initiates a garbage collection. If the system has multiple
generations, then the optional arguments are interpreted as
follows. The <span class="emphasis"><em>generation</em></span> is the generation to collect, where 0 is the
youngest generation. The <span class="emphasis"><em>method</em></span> determines how the collection is
performed. If <span class="emphasis"><em>method</em></span> is the symbol collect, then a full collection
is performed in that generation, whatever that means — in a normal
multi-generational copying collector, it means that all live objects
in the generation's current semispace and all live objects from all
younger generations are copied into the generation's other
semispace. If <span class="emphasis"><em>method</em></span> is the symbol promote, then live objects are
promoted from younger generations into the target generation — in our
example collector, that means that the objects are copied into the
target generation's current semispace.</p><p>The default value for <span class="emphasis"><em>generation</em></span> is 0, and the default value for
<span class="emphasis"><em>method</em></span> is collect.</p><p>Note that the collector's internal policy settings may cause it to
perform a more major type of collection than the one requested; for
example, an attempt to collect generation 2 could cause the collector
to promote all live data into generation 3.</p><p><a id="gc-counter"></a>
<span class="emphasis"><em> Procedure gc-counter</em></span>
<p>
<a id="id2544904" class="indexterm"></a>
<code class="literal">(gc-counter <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p><span class="emphasis"><em>gc-counter</em></span> returns the number of garbage collections performed since
startup. On a 32-bit system, the counter wraps around every
1,073,741,824 collections.</p><p><span class="emphasis"><em>gc-counter</em></span> is a primitive and compiles to a single load instruction
on the SPARC.</p><p><a id="major-gc-counter"></a>
<span class="emphasis"><em> Procedure major-gc-counter</em></span>
<p>
<a id="id2544958" class="indexterm"></a>
<code class="literal">(major-gc-counter <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p></p><p><span class="emphasis"><em>major-gc-counter</em></span> returns the number of major garbage collections
performed since startup, where a major collection is defined as a
collection that may change the address of objects that have already
survived a previous collection.
On a 32-bit system, the counter wraps around every
1,073,741,824 collections.</p><p><span class="emphasis"><em>major-gc-counter</em></span> is a primitive and compiles to a single load
instruction on the SPARC.  Its primary use to implement efficient
hashtables that hash on object identity (make-eq-hashtable and
make-eqv-hashtable).</p><p><a id="gcctl"></a>
<span class="emphasis"><em> Procedure gcctl</em></span>
<p>
<a id="id2545018" class="indexterm"></a>
<code class="literal">(gcctl <span class="emphasis"><em>heap-number operation operand</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p><span class="emphasis"><em>[GCCTL is largely obsolete in the new garbage collector but may be
resurrected in the future. It can still be used to control the
non-predictive collector.]</em></span></p><p>gcctl controls garbage collection policy on a heap-wise basis. The
<span class="emphasis"><em>heap-number</em></span> is the heap to operate on, like for the command line
switches: heap 1 is the youngest. If the given heap number does not
correspond to a heap, gcctl fails silently.</p><p>The <span class="emphasis"><em>operation</em></span> is a symbol that selects the operation to perform, and
the <span class="emphasis"><em>operand</em></span> is the operand to that operation, always a number. For
the non-predictive garbage collector, the following operator/operand
pairs are meaningful:</p><div class="itemizedlist"><ul type="disc"><li>
j-fixed, <span class="emphasis"><em>n</em></span>: after a collection, the collector parameter <span class="emphasis"><em>j</em></span> should be set to the value <span class="emphasis"><em>n</em></span>, if possible. (Non-predictive heaps only.)
</li><li>
j-percent, <span class="emphasis"><em>n</em></span>: after a collection, the collector parameter <span class="emphasis"><em>j</em></span> should be set to be <span class="emphasis"><em>n</em></span> percent of the number of free steps. (Non-predictive heaps only.)
</li><li>
incr-fixed, <span class="emphasis"><em>n</em></span>: when growing the heap, the growing should be done in increments of <span class="emphasis"><em>n</em></span>. In the non-predictive heap, <span class="emphasis"><em>n</em></span> is the number of steps. In other heaps, <span class="emphasis"><em>n</em></span> denotes kilobytes.
</li><li>
incr-percent, <span class="emphasis"><em>n</em></span>: when growing the heap, the growing should be done in increments of <span class="emphasis"><em>n</em></span> percent.
</li></ul></div><p><span class="strong"><strong>Example:</strong></span> if the non-predictive heap is heap number 2, then the expressions</p><pre class="literallayout">(gcctl 2 'j-fixed 0)
(gcctl 2 'incr-fixed 1)</pre><p>makes the non-predictive collector simulate a normal stop-and-copy
collector (because <span class="emphasis"><em>j</em></span> is always set to 0), and grows the heap only
one step at a time as necessary. This may be useful for certain kinds
of experiments.</p><p><span class="strong"><strong>Example:</strong></span> ditto, the expressions</p><pre class="literallayout">(gcctl 2 'j-percent 50)
(gcctl 2 'incr-percent 20)</pre><p>selects the default policy settings.</p><p><span class="strong"><strong>Note</strong></span>: The gcctl facility is experimental. A more developed
  facility will allow controlling heap contraction policy, as well as
  setting all the watermarks. Certainly one can envision other uses,
  too. Finally, it needs to be possible to get current values.</p><p><span class="strong"><strong>Note</strong></span>: Currently the non-predictive heap (np-sc-heap.c) and the
  standard stop-and-copy "old" heap (old-heap.c) are supported, but
  not the standard "young" heap (young-heap.c), nor the stop-and-copy
  collector (sc-heap.c).</p><p><a id="sro"></a>
<span class="emphasis"><em> Procedure sro</em></span>
<p>
<a id="id2545261" class="indexterm"></a>
<code class="literal">(sro <span class="emphasis"><em>pointer-tag type-tag limit</em></span>)  =&gt; <span class="emphasis"><em>vector</em></span></code>
</p></p><p>SRO ("standing room only") is a system primitive that traverses the
entire heap and returns a vector that contains all live objects in the
heap that satisfy the constraints imposed by its parameters:</p><div class="itemizedlist"><ul type="disc"><li>
If <span class="emphasis"><em>pointer-tag</em></span> is -1, then object type is unconstrained;
    otherwise, the object type is constrained to have a pointer tag
    that matches <span class="emphasis"><em>pointer-tag</em></span>. You can read all about pointer tags
    <a class="link" href="#">here</a>, but the short story is that 1=pair, 3=vector-like,
    5=bytevector-like, and 7=procedure-like.
</li><li>
If <span class="emphasis"><em>type-tag</em></span> is -1, then object type is unconstrained by
    type-tag; otherwise, only objects with a matching type-tag are
    selected (after selection by pointer tag). Pairs don't have
    type-tags, but other objects do. You can read all about type-tags
    <a class="link" href="#">here</a>.
</li><li>
<span class="emphasis"><em>Limit</em></span> constrains the selected objects by the number of
    references. If <span class="emphasis"><em>limit</em></span> is -1, then no constraints are imposed;
    otherwise, only objects (selected by pointer-tag and type-tag)
    with no more than <span class="emphasis"><em>limit</em></span> references to them are selected.
</li></ul></div><p>For example, (sro -1 -1 -1) returns a vector that contains all live
objects (not including the vector), and (sro 5 2 3) returns a vector
containing all live flonums (bytevector-like, with typetag 2) that are
referred to in no more than 3 places.</p><p><a id="stats-dump-on"></a>
<span class="emphasis"><em> Procedure stats-dump-on</em></span>
<p>
<a id="id2545399" class="indexterm"></a>
<code class="literal">(stats-dump-on <span class="emphasis"><em>filename</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Stats-dump-on turns on garbage collection statistics dumping. After
each collection, a complete RTS statistics dump is appended to the
file named by <span class="emphasis"><em>filename</em></span>.</p><p>The file format and contents are documented in a banner written at the
top of the output file. In addition, accessor procedures for the
output structure are defined in the program Util/process-stats.sch.</p><p>Stats-dump-on does not perform an initial dump when the file is first
opened; only at the first collection is the first set of statistics
dumped. The user might therefore want to initiate a minor collection
just after turning on dumping in order to have a baseline set of data.</p><p><a id="stats-dump-off"></a>
<span class="emphasis"><em> Procedure stats-dump-off</em></span>
<p>
<a id="id2545470" class="indexterm"></a>
<code class="literal">(stats-dump-off <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>Stats-dump-off turns off garbage collection statistics dumping (which
was turned on with <a class="xref" href="#stats-dump-on">stats-dump-on</a>). It does not dump a final set
of statistics before closing the file; therefore, the user may wish to
initiate a minor collection before calling this procedure.</p><p><a id="system-features"></a>
<span class="emphasis"><em> Procedure system-features</em></span>
<p>
<a id="id2545521" class="indexterm"></a>
<code class="literal">(system-features <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>alist</em></span></code>
</p></p><p>System-features returns an association lists of system features. Most
entries are self-explanatory. The following are a more subtle:</p><div class="itemizedlist"><ul type="disc"><li>
The value of architecture-name is Larceny's notion of the architecture for which it was compiled, not the architecture the program is currently running on. For example, the value of this feature is "Standard-C" if you're running Petit Larceny.
</li><li>
The value of heap-area-info is a vector of vectors, one subvector for each heap area in the running system. The subvector has four entries: the generation number, the area type, the current size, and additional information.
</li></ul></div><p><a id="display-memstats"></a>
<span class="emphasis"><em> Procedure display-memstats</em></span>
<p>
<a id="id2545597" class="indexterm"></a>
<code class="literal">(display-memstats <span class="emphasis"><em>vector</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p>
<p><code class="literal">(display-memstats <span class="emphasis"><em>vector minimal</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(display-memstats <span class="emphasis"><em>vector minimal full</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p>Display-memstats takes as its argument a vector as returned by
<a class="xref" href="#memstats">memstats</a> and displays the contents of the vector in
human-readable form on the current output port. By default, not all of
the values in the vector are displayed.</p><p>If the symbol minimal is passed as the second argument, then only a
small number of statistics generally relevant to running benchmarks
are displayed.</p><p>If the symbol full is passed as the second argument, then all
statistics are displayed.</p><p><a id="memstats"></a>
<span class="emphasis"><em> Procedure memstats</em></span>
<p>
<a id="id2545690" class="indexterm"></a>
<code class="literal">(memstats <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>vector</em></span></code>
</p></p><p>Memstats returns a freshly allocated vector containing run-time-system
resource usage statistics. Many of these will make no sense whatsoever
to you unless you also study the RTS sources. A listing of the
contents of the vector is available <a class="link" href="#">here</a>.</p><p><a id="run-with-stats"></a>
<span class="emphasis"><em> Procedure run-with-stats</em></span>
<p>
<a id="id2545742" class="indexterm"></a>
<code class="literal">(run-with-stats <span class="emphasis"><em>thunk</em></span>)  =&gt; <span class="emphasis"><em>obj</em></span></code>
</p></p><p>Run-with-stats evaluates <span class="emphasis"><em>thunk</em></span>, then prints a short summary of
run-time statistics, as with</p><pre class="literallayout">(display-memstats ... 'minimal),</pre><p>and then returns the result of evaluating <span class="emphasis"><em>thunk</em></span>.</p><p><a id="run-benchmark"></a>
<span class="emphasis"><em> Procedure run-benchmark</em></span>
<p>
<a id="id2545804" class="indexterm"></a>
<code class="literal">(run-benchmark <span class="emphasis"><em>name k thunk ok?</em></span>)  =&gt; <span class="emphasis"><em>obj</em></span></code>
</p></p><p>Run-benchmark prints a short banner (including the identifying <span class="emphasis"><em>name</em></span>)
to identify the benchmark, then runs <span class="emphasis"><em>thunk</em></span> <span class="emphasis"><em>k</em></span> times, and finally
tests the value returned from the last call to <span class="emphasis"><em>thunk</em></span> by applying the
predicate <span class="emphasis"><em>ok?</em></span> to it. If the predicate returns true, then
run-benchmark prints summary statistics, as with</p><pre class="literallayout">([display-memstats][5] ... 'minimal).</pre><p>If the predicate returns false, an error is signalled.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2545870"></a>11.17. SRFI Support</h3></div></div></div><p>SRFIs (Scheme Requests For Implementations) describe and implement
additional Scheme libraries. The SRFI effort is open to anyone,
and is described at <a class="ulink" href="http://srfi.schemers.org" target="_top">http://srfi.schemers.org</a>.</p><p>SRFIs are numbered.  Importing SRFIs into an R7RS library or
program is straightforward:</p><pre class="screen">(import (srfi 19)
        (srfi 27))</pre><p>The R6RS forbids numbers within library names, so R6RS libraries
and programs must import SRFI libraries using the SRFI 97 naming
convention in which a colon precedes the number:</p><pre class="screen">(import (srfi :19)
        (srfi :27))</pre><p>To test whether particular SRFIs are available, use the R7RS
<code class="literal">cond-expand</code> feature:</p><pre class="screen">(cond-expand
 ((and (library (srfi 19))
       (library (srfi 27)))
  (import (srfi 19))
  (import (srfi 27))))</pre><p><code class="literal">cond-expand</code> is not available to R6RS libraries or programs.</p><p>R5RS programs can use <code class="literal">cond-expand</code> as implemented by SRFI 0,
"Feature-based conditional expansion construct".  (SRFI 0 must
be loaded into Larceny before it can be used; see below.)
Larceny provides the following nonstandard key for use in SRFI 0:</p><pre class="screen">    larceny</pre><p>Larceny currently supports many SRFIs, though not as many as it
should.
Some SRFIs are built into Larceny's R5RS mode, but most must be
loaded dynamically using Larceny's <code class="literal">require</code> procedure:</p><pre class="screen">    &gt; (require 'srfi-0)</pre><p>The design documents for SRFI 0 and other SRFIs are available at
<a class="ulink" href="http://srfi.schemers.org" target="_top">http://srfi.schemers.org</a>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2546007"></a>11.18. SLIB support</h3></div></div></div><p><a class="ulink" href="http://www-swiss.ai.mit.edu/~jaffer/SLIB.html" target="_top">SLIB</a>
is a large collection of useful libraries that have been
written or collected by Aubrey Jaffer.</p><p>Larceny supports SLIB via
<a class="ulink" href="http://srfi.schemers.org/srfi-96/" target="_top">SRFI 96</a>,
but SLIB itself is not shipped with Larceny;
it must be downloaded separately and then installed.
For the most up-to-date information on installing and using
SLIB with Larceny, see <code class="literal">doc/HOWTO-SLIB</code>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2546048"></a>11.19. Foreign-Function Interface to C</h3></div></div></div><p>Larceny provides a general foreign-function interface (FFI) substrate
on which other FFIs can be built; see
<a class="ulink" href="LarcenyNotes/note7-ffi.html" target="_top">Larceny Note #7</a>.
The FFI described in this manual section is a simple example of
a derived FFI. It is not yet fully evolved, but it is useful.</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>This section has undergone signficant revision, but
not all of the material has been properly vetted.
Some of the information in this section may be out of date.</p></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Some of the text below is adapted from the 2008 Scheme Workshop
paper, “The Layers of Larceny's Foreign Function Interface,”
by Felix S Klock II.  That paper may provide additional insight
for those searching for implementation details and motivations.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2546093"></a>11.19.1. Introducing the FFI</h4></div></div></div><p>There are a number of different potential ways to use the FFI.
One client may want to develop code in C and load it into Larceny.
Another client may want to load native libraries
provided by the host operating system, enabling invocation
of foreign code from Scheme expressions without developing
any C code or even running a C compiler.
Larceny's FFI can be used for both of these cases,
but many of its facilities target a third client
in between the two extremes: a client with a C compiler and
the header files and object code for the foreign libraries,
but who wishes to avoid writing glue code in C to interface
with the libraries.</p><p>There are four main steps to interacting with foreign code:</p><div class="orderedlist"><ol type="1"><li>
identifying the space of values manipulated by the
   foreign code that will also be manipulated in Scheme,
</li><li>
describing how to marshal values between foreign and
   Scheme code,
</li><li>
loading library file(s) holding foreign object code, and
</li><li>
linking procedures from the loaded library.
</li></ol></div><p>Step 1 is conceptual, while steps 2 through 4
yield artifacts in Scheme source code.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2546168"></a>11.19.2. The space of foreign values</h4></div></div></div><p>At the machine code level, foreign values are uninterpreted
sequences of bits.  Often foreign object code is oriented
around manipulating word-sized bit-sequences (<span class="emphasis"><em>words</em></span>)
or arrays and tuples of words.</p><p>Many libraries are written with a particular
interpretation of such values.  In C code, explicit types are
often used hints to guide such interpretation; for example,
a <code class="literal">0</code> of type <code class="literal">bool</code> is usually interpreted as <span class="emphasis"><em>false</em></span>,
while a <code class="literal">1</code> (or other non-zero value) of type <code class="literal">bool</code> is
usually interpreted as <span class="emphasis"><em>true</em></span>.
Another example are C enumerations (or <span class="emphasis"><em>enums</em></span>).
An enum declaration defines a set of named
integral constants.  After the C declaration:</p><pre class="screen">enum months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };</pre><p>a <code class="literal">JAN</code> in C code now denotes <code class="literal">1</code>, <code class="literal">FEB</code> is <code class="literal">2</code>, and so on.
Furthermore, tools like debuggers may render a variable <code class="literal">x</code>
dynamically assigned the value <code class="literal">2</code> (and of static type <code class="literal">enum months</code>)
as <code class="literal">FEB</code>.  Thus the enum declaration
intoduces a new interpretation for a finite set of integers.</p><p>This leads to questions for a client of an FFI;
we explore some below.</p><div class="itemizedlist"><ul type="disc"><li>
Should foreign words be passed over to
the Scheme world as uninterpreted numbers (and thus
be converted into Scheme integers, usually fixnums),
or should they be marshaled into interpreted values, such as
<code class="literal">#f</code> and <code class="literal">#t</code> for the <code class="literal">bool</code> type, or the Scheme symbols
{<code class="literal">JAN</code>, <code class="literal">FEB</code>, <code class="literal">MAR</code>, <code class="literal">APR</code>, <code class="literal">MAY</code>, <code class="literal">JUN</code>,
 <code class="literal">JUL</code>, <code class="literal">AUG</code>, <code class="literal">SEP</code>, <code class="literal">OCT</code>, <code class="literal">NOV</code>, <code class="literal">DEC</code>}
for the <code class="literal">enum months</code> type?
</li><li>
Similarly, how should Scheme values be marshaled into
foreign words?
</li><li><p>
A foreign library might leave the mapping
of names like <code class="literal">FEB</code> to words like <code class="literal">2</code> <span class="emphasis"><em>unspecified</em></span>
in the library interface.
That is, while the C compiler will know <code class="literal">FEB</code> maps to <code class="literal">2</code>
according to a particular version of the library's header file,
the library designer may intend to change this mapping
in the future, and clients writing C code should <span class="emphasis"><em>only</em></span> use
the names to refer to a <code class="literal">enum months</code> value, and <span class="emphasis"><em>not</em></span> integer
expressions.
</p><div class="itemizedlist"><ul type="circle"><li>
How should this constraint be handled in the FFI; should
 the library client revise their code in reaction to
 such changes to the mapping?
</li><li>
Or should the system derive
 the mapping from the header files, in the same manner that
 the C compiler does?
</li></ul></div></li><li><p>
Foreign libraries often manipulate
mutable entities, like arrays of words where
modifications can be observed (often by design).
</p><div class="itemizedlist"><ul type="circle"><li>
How should such values be marshaled?
</li><li>
Is it sound to copy such values to the Scheme heap?
  If so, is a shallow copy sufficient?
</li></ul></div></li><li><p>
Will the foreign code hold references to heap-allocated
objects?  Heap-allocated objects that <span class="emphasis"><em>leak</em></span> out to
foreign memory must be treated with care;
garbage collection presents two main problems.
</p><div class="itemizedlist"><ul type="circle"><li>
First, such objects must not move during a garbage collection;
Larceny supports this via special-purpose allocation routines:
 <code class="literal">cons-nonrelocatable</code>, <code class="literal">make-nonrelocatable-bytevector</code>,
 and <code class="literal">make-nonrelocatable-vector</code>.
</li><li>
Second, the garbage collector must know to hold on to
(i.e. trace)
such values as long as they are needed by foreign code;
otherwise the objects or their referents may be
collected without the knowledge of the foreign code.
</li></ul></div></li></ul></div><p>Answering these questions may require deep knowledge
of the intended usage of the foreign library.</p><p>The Larceny FFI attempts to ease interfacing with
foreign code in the presence of the above concerns,
but the nature of the header files included with
most foreign libraries means that the FFI cannot infer
the answers unassisted.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Foreign C code developed to work in concert with Larceny
could hypothetically be written to cope with holding
handles for objects managed by the the garbage collector,
but there is currently no significant support
for this use-case.</p></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>One class of foreign values is not addressed
by the Larceny FFI: structures passed by value (as
opposed to by reference, ie pointers to structures).
There is no way to describe the interface to a
foreign procedure that accepts or produces a
C <code class="literal">struct</code> (at least not properly nor portably).</p><p>This tends to not matter for many foreign libraries
(since many C programmers eschew passing structures
by value), but it can arise.</p><p>If the foreign library of interest has procedures that
accept or produce a C <code class="literal">struct</code>, we currently recommend
either avoiding such procedures, or writing
adapter code in C that marshals between values handled
by the FFI and the C <code class="literal">struct</code>.</p></div><p>The conclusion is: when designing an interface to a foreign
library, you should analyze the values manipulated on the
foreign side and identify their relationship with values
on the Scheme side.
After you have identified the domains of interest,
you then describe how the values will be marshaled
back and forth between the two domains.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2546687"></a>11.19.3. Marshalling via ffi-attributes</h4></div></div></div><p>This section describes the marshalling protocol defined in
<code class="literal">lib/Base/std-ffi.sch</code>.</p><p>Foreign functions automatically marshal their inputs and outputs
according to type-descriptors attached to each foreign
function.</p><p>Type-descriptors are S-expressons formed according to the following
grammar:</p><pre class="literallayout">TypeDesc ::= CoreAttr | ArrowT | MaybeT | OneOfT

CoreAttr ::= PrimAttr | VoidStar | ---

PrimAttr ::= CurrentPrimAttr | DeprecatedPrimAttr

CurrentPrimAttr
         ::= int | uint | byte | short | ushort | char | uchar
          |  long | ulong | longlong | ulonglong
          |  size_t | float | double |  bool | string | void

DeprecatedPrimAttr
         ::= unsigned | boxed

VoidStar ::= void* | ---

ArrowT   ::= (-&gt; (TypeDesc ...) TypeDesc)

MaybeT   ::= (maybe TypeDesc)

OneOfT   ::= (oneof (Any Fixnum) ... TypeDesc)</pre><p>where <code class="literal">---</code> represents a user-extensible part of the grammar
(see below),
<code class="literal">Any</code> represents any Scheme value, and <code class="literal">Fixnum</code> represents
any word-sized integer.</p><p>A central registry maps <code class="literal">CoreAttr</code>'s to a foreign
representation and two conversion routines:
one to convert a Scheme value to a foreign argument, and
another to convert a foreign result back back to a Scheme value.
The denoted components are collectively referred to as a <span class="emphasis"><em>type</em></span>
within the FFI documentation.
The registry is extensible; the <code class="literal">ffi-add-attribute-core-entry!</code>
procedure adds new <code class="literal">CoreAttr's</code> to the registry, and
one can alternatively add short-hands for
type-descriptors via the <code class="literal">ffi-add-alias-of-attribute-entry!</code>
procedure.
Finally, one can add new <code class="literal">VoidStar</code> productions
(subtypes of the <code class="literal">void*</code> type-descriptor)
via the <code class="literal">ffi-install-void*-subtype</code> procedure
(defined in the <code class="literal">lib/Standard/foreign-stdlib.sch</code> library).</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2546834"></a>11.19.3.1. Primitive Attribute Types</h5></div></div></div><p>The following is a list of the accepted types and their conversions
at the boundary between Scheme and foreign code:</p><div class="variablelist"><dl><dt><span class="term">
<code class="literal">int</code>
</span></dt><dd>
  Exact integer values in the range [-2<sup>31</sup>,2<sup>31</sup>-1].
  Scheme integers in that range are converted to and from C "<code class="literal">int</code>".
</dd><dt><span class="term">
<code class="literal">uint</code>
</span></dt><dd>
  Exact integer values in the range [0,2<sup>32</sup>-1].
  Scheme integers in that ranges are converted to and from C "<code class="literal">unsigned int</code>".
</dd><dt><span class="term">
<code class="literal">byte</code>
</span></dt><dd>
  Synonymous with <code class="literal">int</code> in the current implementation.
</dd><dt><span class="term">
<code class="literal">short</code>
</span></dt><dd>
  Synonymous with <code class="literal">int</code> in the current implementation.
</dd><dt><span class="term">
<code class="literal">ushort</code>
</span></dt><dd>
  Synonymous with <code class="literal">unsigned</code> in the current implementation.
</dd><dt><span class="term">
<code class="literal">char</code>
</span></dt><dd>
  Scheme ASCII characters are converted to and from C "<code class="literal">char</code>".
</dd><dt><span class="term">
<code class="literal">uchar</code>
</span></dt><dd>
  Scheme ASCII characters are converted to and from C "<code class="literal">unsigned char</code>".
</dd><dt><span class="term">
<code class="literal">long</code>
</span></dt><dd>
  Synonymous with <code class="literal">int</code> in the current implementation.
</dd><dt><span class="term">
<code class="literal">ulong</code>
</span></dt><dd>
  Synonymous with <code class="literal">unsigned</code> in the current implementation.
</dd><dt><span class="term">
<code class="literal">longlong</code>
</span></dt><dd>
  Exact integer values in the range [-2<sup>63</sup>,2<sup>63</sup>-1].
  Scheme integers in that range are converted
  to and from C "<code class="literal">long long</code>".
</dd><dt><span class="term">
<code class="literal">ulonglong</code>
</span></dt><dd>
  Exact integer values in the range [0,2<sup>64</sup>-1].
  Scheme integers in that range are converted
  to and from C "<code class="literal">unsigned long long</code>".
</dd><dt><span class="term">
<code class="literal">size_t</code>
</span></dt><dd>
  Synonymous with <code class="literal">uint</code> in the current implementation.
</dd><dt><span class="term">
<code class="literal">float</code>
</span></dt><dd>
  Scheme flonums are converted to and from C "<code class="literal">float</code>".
  The conversion to <code class="literal">float</code> is performed via
  a C <code class="literal">(float)</code> cast from a C <code class="literal">double</code>.
</dd><dt><span class="term">
<code class="literal">double</code>
</span></dt><dd>
  Scheme flonums are converted to and from C "double".
</dd><dt><span class="term">
<code class="literal">bool</code>
</span></dt><dd>
  Scheme objects are converted to C "<code class="literal">int</code>";
  <code class="literal">#f</code> is converted to 0, and all other objects to 1.
  In the reverse direction, 0 is converted to <code class="literal">#f</code> and
  all other integers to <code class="literal">#t</code>.
</dd><dt><span class="term">
<code class="literal">string</code>
</span></dt><dd>
  A Scheme string holding ASCII characters
  is <span class="emphasis"><em>copied</em></span> into a NUL-terminated bytevector,
  passing a pointer to its first byte to the foreign procedure;
  <code class="literal">#f</code> is converted to a C "<code class="literal">(char*)0</code>" value.
  In the reverse direction, a pointer to a NUL-terminated sequence
  of bytes interpreted as ASCII characters is
  copied into a freshly allocated Scheme string; a NULL pointer is
  converted to <code class="literal">#f</code>.
</dd><dt><span class="term">
<code class="literal">void</code>
</span></dt><dd>
  No return value.
  (Only used in return position for foreign functions;
  all Scheme procedures passed to the FFI are invoked in a context
  expecting one value.)
</dd><dt><span class="term">
<code class="literal">unsigned</code>
</span></dt><dd>
  Synonymous with <code class="literal">uint</code>; deprecated.
</dd><dt><span class="term">
<code class="literal">boxed</code>
</span></dt><dd>
  Any heap-allocated data structure (pair,
  bytevector-like, vector-like, procedure) is converted to
  a C "<code class="literal">void*</code>" to the first element of the structure. The
  value <code class="literal">#f</code> is also acceptable. It is converted to a C "<code class="literal">(void*)0</code>"
  value.
  (Only used in argument position for foreign functions; foreign
   functions are not expected to return direct references
   to heap-allocated values.)
</dd></dl></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2547444"></a>11.19.3.2. Extending the Core Attribute Registry</h5></div></div></div><p>The public interface to many foreign libraries is written
in terms of types defined within that foreign library.
One can introduce new types to the Larceny FFI
by extending the core attribute entry table.</p><p><a id="ffi-add-attribute-core-entry!"></a>
<span class="emphasis"><em> Procedure ffi-add-attribute-core-entry!</em></span>
<p>
<a id="id2547474" class="indexterm"></a>
<code class="literal">(ffi-add-attribute-core-entry! <span class="emphasis"><em>entry-name rep-sym marshal unmarshal</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p><a class="xref" href="#ffi-add-attribute-core-entry!">ffi-add-attribute-core-entry!</a> extends the
internal registry with the new entry specified by its arguments.</p><div class="itemizedlist"><ul type="disc"><li>
<span class="emphasis"><em>entry-name</em></span> is a symbol (the symbolic type name being
introduced to the ffi).
</li><li>
<span class="emphasis"><em>rep-name</em></span> is a low-level type descriptor symbol, one of
<code class="literal">signed32</code>, <code class="literal">unsigned32</code>, <code class="literal">signed64</code>, <code class="literal">unsigned64</code>
(representing varieties of fixed width integers),
<code class="literal">ieee32</code> (representing “floats”),
<code class="literal">ieee64</code> (representing “doubles”), or
<code class="literal">pointer</code> (representing “<code class="literal">(void*)</code>” in C).
</li><li>
<span class="emphasis"><em>marshal</em></span> is a marshaling function that accepts a Scheme object and a symbol
(the name of the invoking procedure); it is responsible for checking
the Scheme object's validity and then producing a corresponding
instance of the low-level representation.
</li><li>
<span class="emphasis"><em>unmarshal</em></span> is either <code class="literal">#f</code> or an unmarshalling function that
accepts an instance of the low-level representation
and produces a corresponding Scheme object.
</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2547621"></a>11.19.3.3. Attribute Type Constructors</h5></div></div></div><p>Core attributes suffice for linking to simple
functions.
Constructured FFI attributes express more complex
marshaling protocols</p><p><b>Arrow Type Constructors. </b>A structured FFI attribute
of the form <code class="literal">(-&gt; (<span class="emphasis"><em>s_1</em></span> … <span class="emphasis"><em>s_n</em></span>) <span class="emphasis"><em>s_r</em></span>)</code>
(called an <span class="emphasis"><em>arrow type</em></span>)
allows passing functions from Scheme to C
and back again.  Each of the <span class="emphasis"><em>s_1</em></span>, …, <span class="emphasis"><em>s_n</em></span>, <span class="emphasis"><em>s_r</em></span>
is an FFI attribute.
When an arrow type describes an input to a foreign
function, it marshals a Scheme procedure to a
C function pointer by generating glue code to hook the two together
and marshal values as described by the FFI attributes
within the arrow type.
Likewise, when an arrow type describes an output from a
foreign function, it marshals a C function pointer
to a Scheme procedure, again by generating glue code.
These two mappings naturally generalize to arbitrary nesting
of arrow types, so one can create callbacks that consume
callouts, return callouts that consume callbacks, and so on.</p><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>The current implementation of arrow types introduces an
unnecessary space leak, because none of Larceny's current
garbage collectors attempt to reclaim some of the structure
allocated (in particular, the so-called trampolines)
when functions are marshaled via arrow types.</p><p>The FFI could be revised to reduce the leak
(e.g. it could keep a cache of generated trampolines and
reuse them, but currently do not do so).</p><p>Many foreign libraries have a structure where one only
sets up a fixed set of callbacks, and then all further
computation does not require arrow type marshaling.
This is one reason why fixing this problem
has been a low priority item for the Larceny development
team.</p></div><p><b>Maybe Type Constructor. </b><code class="literal">(maybe <span class="emphasis"><em>t</em></span>)</code> captures the
pattern of passing <code class="literal">NULL</code> in C and <code class="literal">#f</code> in Scheme
to represent the absence of information.
The FFI attribute <span class="emphasis"><em>t</em></span> within the maybe type
describes the typical information passed;
the constructed maybe type
marshals <code class="literal">#f</code> to the foreign null pointer or <code class="literal">0</code> (as appropriate),
and otherwise applies the marshaling of <span class="emphasis"><em>t</em></span>.
Likewise, it unmarshals the foreign
null pointer and <code class="literal">0</code> to <code class="literal">#f</code>, and otherwise applies the
unmarshaling of <span class="emphasis"><em>t</em></span>.</p><p>(There are a few other built-in type constructors, such as
 the <code class="literal">oneof</code> type constructor, but they
 are not as fully-developed as the two above, and are intended
 for use only for internal development for now.)</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2547812"></a>11.19.3.4. void* Type Hierarchies</h5></div></div></div><p>Using the <code class="literal">void*</code> attribute
wraps foreign addresses up in a Larceny record,
so that standard numeric
operations cannot be directly applied by accident.
The FFI uses two features of Larceny's record system:
the record type descriptor is a first class
value with an inspectable name, and
record types are extensible via single-inheritance.</p><p><b>Basic Operations on <code class="literal">void*</code>. </b>The FFI provides <code class="literal">void*-rt</code>, a record type
descriptor with a single field (a wrapped address).
There is also a family of functions for dereferencing the
pointer within a <code class="literal">void*-rt</code> and manipulating the
state it references.</p><p><a id="void*-&gt;address"></a>
<span class="emphasis"><em> Procedure void*-&gt;address</em></span>
<p>
<a id="id2547879" class="indexterm"></a>
<code class="literal">(void*-&gt;address <span class="emphasis"><em>x</em></span>)  =&gt; <span class="emphasis"><em>number</em></span></code>
</p>
Extracts the underlying address held in a <code class="literal">void*</code>.</p><p><a id="void*?"></a>
<span class="emphasis"><em> Procedure void*?</em></span>
<p>
<a id="id2547922" class="indexterm"></a>
<code class="literal">(void*? <span class="emphasis"><em>x</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p>
Distinquishes <code class="literal">void*</code>'s from other Scheme values.</p><p><a id="void*-byte-ref"></a>
<span class="emphasis"><em> Procedure void*-byte-ref</em></span>
<p>
<a id="id2547967" class="indexterm"></a>
<code class="literal">(void*-byte-ref <span class="emphasis"><em>x idx</em></span>)  =&gt; <span class="emphasis"><em>number</em></span></code>
</p>
Extracts byte at offset from address within <span class="emphasis"><em>x</em></span>.</p><p><a id="void*-byte-set!"></a>
<span class="emphasis"><em> Procedure void*-byte-set!</em></span>
<p>
<a id="id2548009" class="indexterm"></a>
<code class="literal">(void*-byte-set! <span class="emphasis"><em>x idx val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p>
Modifies byte at offset from address within <span class="emphasis"><em>x</em></span>.</p><p><a id="void*-word-ref"></a>
<span class="emphasis"><em> Procedure void*-word-ref</em></span>
<p>
<a id="id2548051" class="indexterm"></a>
<code class="literal">(void*-word-ref <span class="emphasis"><em>x idx</em></span>)  =&gt; <span class="emphasis"><em>number</em></span></code>
</p>
Extracts word-sized integer at offset from address within <span class="emphasis"><em>x</em></span>.</p><p><a id="void*-word-set!"></a>
<span class="emphasis"><em> Procedure void*-word-set!</em></span>
<p>
<a id="id2548093" class="indexterm"></a>
<code class="literal">(void*-word-set! <span class="emphasis"><em>x idx val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p>
Modifies word-sized integer at offset from address within <span class="emphasis"><em>x</em></span>.</p><p><a id="void*-void*-ref"></a>
<span class="emphasis"><em> Procedure void*-void*-ref</em></span>
<p>
<a id="id2548135" class="indexterm"></a>
<code class="literal">(void*-void*-ref <span class="emphasis"><em>x idx</em></span>)  =&gt; <span class="emphasis"><em>void*</em></span></code>
</p>
Extracts address (and wraps it in a <code class="literal">void*</code>) at offset from address within <span class="emphasis"><em>x</em></span>.</p><p><a id="void*-void*-set!"></a>
<span class="emphasis"><em> Procedure void*-void*-set!</em></span>
<p>
<a id="id2548183" class="indexterm"></a>
<code class="literal">(void*-void*-set! <span class="emphasis"><em>x idx val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p>
Modifies address at offset from address within <span class="emphasis"><em>x</em></span>.</p><p><a id="void*-double-ref"></a>
<span class="emphasis"><em> Procedure void*-double-ref</em></span>
<p>
<a id="id2548225" class="indexterm"></a>
<code class="literal">(void*-double-ref <span class="emphasis"><em>x idx</em></span>)  =&gt; <span class="emphasis"><em>number</em></span></code>
</p>
Extracts 64-bit flonum at offset from address within <span class="emphasis"><em>x</em></span>.</p><p><a id="void*-double-set!"></a>
<span class="emphasis"><em> Procedure void*-double-set!</em></span>
<p>
<a id="id2548267" class="indexterm"></a>
<code class="literal">(void*-double-set! <span class="emphasis"><em>x idx val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p>
Modifies 64-bit flonum at offset from address within <span class="emphasis"><em>x</em></span>.</p><p><b>Type Hierarchies. </b>Procedures for establishing type hierarchies are provided by the
<code class="literal">lib/Standard/foreign-stdlib.sch</code> library; see
<a class="xref" href="#ffi-install-void*-subtype">ffi-install-void*-subtype</a> and <a class="xref" href="#establish-void*-subhierarchy!">establish-void*-subhierarchy!</a>.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2548327"></a>11.19.4. Creating loadable modules</h4></div></div></div><p>You must first compile your C code and create one or more loadable object modules. These object modules may then be loaded into Larceny, and Scheme foreign functions may link to specific functions in the loaded module. Defining foreign functions in Scheme is covered in a later section.</p><p>The method for creating a loadable object module varies from platform to platform. In the following, assume you have to C source files file1.c and file2.c that define functions that you want to make available as foreign functions in Larceny.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2548349"></a>11.19.4.1. SunOS 4</h5></div></div></div><p>Compile your source files and create a shared library. Using GCC, the command line might look like this:</p><pre class="literallayout">gcc -fPIC -shared file1.c file2.c -o my-library.so</pre><p>The command creates my-library.so in the current directory. This library can now be loaded into Larceny using <a class="xref" href="#foreign-file">foreign-file</a>. Any other shared libraries used by your library files should also be loaded into Larceny using <a class="xref" href="#foreign-file">foreign-file</a> before any procedures are linked using <a class="xref" href="#foreign-procedure">foreign-procedure</a>.</p><p>By default, /lib/libc.so is made available to the dynamic linker and to the foreign function interface, so there is no need for you to load that library explicitly.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2548403"></a>11.19.4.2. SunOS 5</h5></div></div></div><p>Compile your source files and create a shared library, linking with all the necessary libraries. Using GCC, the command line might look like this:</p><pre class="literallayout">gcc -fPIC -shared file1.c file2.c -lc -lm -lsocket -o my-library.so</pre><p>Now you can use foreign-file to load my-library.so into Larceny.</p><p>By default, /lib/libc.so is made available to the foreign function interface, so there is no need for you to load that library explicitly.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2548436"></a>11.19.5. The Interface</h4></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2548442"></a>11.19.5.1. Procedures</h5></div></div></div><p><a id="foreign-file"></a>
<span class="emphasis"><em> Procedure foreign-file</em></span>
<p>
<a id="id2548463" class="indexterm"></a>
<code class="literal">(foreign-file <span class="emphasis"><em>filename</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p><a class="xref" href="#foreign-file">foreign-file</a> loads the named object file into Larceny and makes it available for dynamic linking.</p><p>Larceny uses the operating system provided dynamic linker to do dynamic linking. The operation of the dynamic linker varies from platform to platform:</p><div class="itemizedlist"><ul type="disc"><li>
On some versions of SunOS 4, if the linker is given a file that does not exist, it will terminate the process. (Most likely this is a bug.) This means you should never call foreign-file with the name of a file that does not exist.
</li><li>
On SunOS 5, if a foreign file is given to foreign-file without a directory specification, then the dynamic linker will search its load path (the <code class="literal">LD_LIBRARY_PATH</code> environment variable) for the file. Hence, a foreign file in the current directory should be "./file.so", not "file.so".
</li></ul></div><p><a id="foreign-procedure"></a>
<span class="emphasis"><em> Procedure foreign-procedure</em></span>
<p>
<a id="id2548551" class="indexterm"></a>
<code class="literal">(foreign-procedure <span class="emphasis"><em>name (arg-type …) return-type</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p>FIXME: The interface to this function has been extended to support
hooking into Windows procedures that use the Pascal calling convention
instead of the C one.  The way to select which convention to use
should be documented.</p><p>Returns a Scheme procedure <span class="emphasis"><em>p</em></span> that calls the foreign procedure whose
name is <span class="emphasis"><em>name</em></span>. When <span class="emphasis"><em>p</em></span> is called, it will convert its parameters to
representations indicated by the <span class="emphasis"><em>arg-type</em></span>s and invoke the foreign
procedure, passing the converted values as parameters. When the
foreign procedure returns, its return value is converted to a Scheme
value according to <span class="emphasis"><em>return-type</em></span>.</p><p>Types are described below.</p><p>The address of the foreign procedure is obtained by searching for <span class="emphasis"><em>name</em></span> in the symbol tables of the foreign files that have been loaded with <span class="emphasis"><em>foreign-file</em></span>.</p><p><a id="foreign-null-pointer"></a>
<span class="emphasis"><em> Procedure foreign-null-pointer</em></span>
<p>
<a id="id2548644" class="indexterm"></a>
<code class="literal">(foreign-null-pointer <span class="emphasis"><em></em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code>
</p></p><p>Returns a foreign null pointer.</p><p><a id="foreign-null-pointer?"></a>
<span class="emphasis"><em> Procedure foreign-null-pointer?</em></span>
<p>
<a id="id2548684" class="indexterm"></a>
<code class="literal">(foreign-null-pointer? <span class="emphasis"><em>integer</em></span>)  =&gt; <span class="emphasis"><em>boolean</em></span></code>
</p></p><p>Tests whether its argument is a foreign null pointer.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2548712"></a>11.19.6. Foreign Data Access</h4></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2548718"></a>11.19.6.1. Raw memory access</h5></div></div></div><p>The two primitives <span class="emphasis"><em>peek-bytes</em></span> and <span class="emphasis"><em>poke-bytes</em></span> are provided for reading and writing memory at specific addresses. These procedures are typically used for copying data from foreign data structures into Scheme bytevectors for subsequent decoding.</p><p>(The use of <span class="emphasis"><em>peek-bytes</em></span> and <span class="emphasis"><em>poke-bytes</em></span> can often be avoided by keeping foreign data in a Scheme bytevector and passing the bytevector to a call-out using the <span class="strong"><strong>boxed</strong></span> parameter type. However, this technique is inappropriate if the foreign code retains a pointer to the Scheme datum, which may be moved by the garbage collector.)</p><p><a id="peek-bytes"></a>
<span class="emphasis"><em> Procedure peek-bytes</em></span>
<p>
<a id="id2548774" class="indexterm"></a>
<code class="literal">(peek-bytes <span class="emphasis"><em>addr bytevector count</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p><span class="emphasis"><em>Addr</em></span> must be an exact nonnegative integer. <span class="emphasis"><em>Count</em></span> must be a fixnum. The bytes in the range from <span class="emphasis"><em>addr</em></span> through <span class="emphasis"><em>addr+count-1</em></span> are copied into <span class="emphasis"><em>bytevector</em></span>, which must be long enough to hold that many bytes.</p><p>If any address in the range is not an address accessible to the process, unpredictable things may happen. Typically, you'll get a segmentation fault. Larceny does not yet catch segmentation faults.</p><p><a id="poke-bytes"></a>
<span class="emphasis"><em> Procedure poke-bytes</em></span>
<p>
<a id="id2548841" class="indexterm"></a>
<code class="literal">(poke-bytes <span class="emphasis"><em>addr bytevector count</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p><span class="emphasis"><em>Addr</em></span> must be an exact nonnegative integer. <span class="emphasis"><em>Count</em></span> must be a fixnum. The <span class="emphasis"><em>count</em></span> first bytes from <span class="emphasis"><em>bytevector</em></span> are copied into memory in the range from <span class="emphasis"><em>addr</em></span> through <span class="emphasis"><em>addr+count-1</em></span>.</p><p>If any address in the range is not an address accessible to the process, unpredictable things may happen. Typically, you'll get a segmentation fault. Larceny does not yet catch segmentation faults.</p><p>Also, it's possible to corrupt memory with <span class="emphasis"><em>poke-bytes</em></span>. Don't do that.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2548905"></a>11.19.6.2. Foreign data sizes</h5></div></div></div><p>The following variables constants define the sizes of basic C data types:</p><div class="itemizedlist"><ul type="disc"><li>
<span class="strong"><strong>sizeof:short</strong></span> The size of a "short int".
</li><li>
<span class="strong"><strong>sizeof:int</strong></span> The size of an "int".
</li><li>
<span class="strong"><strong>sizeof:long</strong></span> The size of a "long int".
</li><li>
<span class="strong"><strong>sizeof:pointer</strong></span> The size of any pointer type.
</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2548973"></a>11.19.6.3. Decoding foreign data</h5></div></div></div><p>Foreign data is visible to a Scheme program either as an object pointed to by a memory address (which is itself represented as an integer), or as a bytevector that contains the bytes of the foreign datum.</p><p>A number of utility procedures that make reading and writing data of common C primitive types have been written for both these kinds of foreign objects.</p><p><span class="emphasis"><em>Bytevector accessor procedures</em></span></p><p><p><code class="literal">(%get16 <span class="emphasis"><em>bv i</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%get16u <span class="emphasis"><em>bv i</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%get32 <span class="emphasis"><em>bv i</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%get32u <span class="emphasis"><em>bv i</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%get-int <span class="emphasis"><em>bv i</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%get-unsigned <span class="emphasis"><em>bv i</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%get-short <span class="emphasis"><em>bv i</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%get-ushort <span class="emphasis"><em>bv i</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%get-long <span class="emphasis"><em>bv i</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%get-ulong <span class="emphasis"><em>bv i</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%get-pointer <span class="emphasis"><em>bv i</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p></p><p>These procedures decode bytevectors that contain the bytes of foreign objects. In each case, <span class="emphasis"><em>bv</em></span> is a bytevector and <span class="emphasis"><em>i</em></span> is the offset of the first byte of a field in that bytevector. The field is fetched and returned as an integer (signed or unsigned as appropriate).</p><p><span class="emphasis"><em>Bytevector updater procedures</em></span></p><p><p><code class="literal">(%set16 <span class="emphasis"><em>bv i val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%set16u <span class="emphasis"><em>bv i val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%set32 <span class="emphasis"><em>bv i val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%set32u <span class="emphasis"><em>bv i val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%set-int <span class="emphasis"><em>bv i val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%set-unsigned <span class="emphasis"><em>bv i val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%set-short <span class="emphasis"><em>bv i val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%set-ushort <span class="emphasis"><em>bv i val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%set-long <span class="emphasis"><em>bv i val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%set-ulong <span class="emphasis"><em>bv i val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%set-pointer <span class="emphasis"><em>bv i val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p>These procedures update bytevectors that contain the bytes of foreign objects. In each case, <span class="emphasis"><em>bv</em></span> is a bytevector, <span class="emphasis"><em>i</em></span> is an offset of the first byte of a field in that bytevector, and <span class="emphasis"><em>val</em></span> is a value to be stored in that field. The values must be exact integers in a range implied by the data type.</p><p><span class="emphasis"><em>Foreign-pointer accessor procedures</em></span></p><p><p><code class="literal">(%peek8 <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek8u <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek16 <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek16u <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek32 <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek32u <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p></p><p><p><code class="literal">(%peek-int <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek-long <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek-unsigned <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek-ulong <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek-short <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek-ushort <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek-pointer <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p>
<p><code class="literal">(%peek-string <span class="emphasis"><em>addr</em></span>)  =&gt; <span class="emphasis"><em>integer</em></span></code></p></p><p>These procedures read raw memory. In each case, <span class="emphasis"><em>addr</em></span> is an address, and the value stored at that address (the size of which is indicated by the name of the procedure) is fetched and returned as an integer.</p><p><span class="emphasis"><em>%Peek-string</em></span> expects to find a NUL-terminated string of 8-bit bytes at the given address. It is returned as a Scheme string.</p><p><span class="emphasis"><em>Foreign-pointer updater procedures</em></span></p><p><p><code class="literal">(%poke8 <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%poke8u <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%poke16 <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%poke16u <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%poke32 <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%poke32u <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p><p><code class="literal">(%poke-int <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%poke-long <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%poke-unsigned <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%poke-ulong <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%poke-short <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%poke-ushort <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p>
<p><code class="literal">(%poke-pointer <span class="emphasis"><em>addr val</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code></p></p><p>These procedures update raw memory. In each case, <span class="emphasis"><em>addr</em></span> is an address, and <span class="emphasis"><em>val</em></span> is a value to be stored at that address.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2549724"></a>11.19.7. Heap dumping and the FFI</h4></div></div></div><p>If foreign functions are linked into Larceny using the FFI, and a
Larceny heap image is subsequently dumped (with
<a class="xref" href="#dump-interactive-heap">dump-interactive-heap</a> or
<a class="xref" href="#dump-heap">dump-heap</a>), then the foreign functions are not saved as
part of the heap image. When the heap image is subsequently loaded
into Larceny at startup, the FFI will attempt to re-link all the
foreign functions in the heap image.</p><p>During the relinking phase, foreign files will again be loaded into Larceny, and Larceny's FFI will use the file names <span class="emphasis"><em>as they were originally given to the FFI</em></span> when it tries to load the files. In particular, if relative pathnames were used, Larceny will not have converted them to absolute pathnames.</p><p>An error during relinking will result in Larceny aborting with an error message and returning to the operating system. This is considered a feature.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2549773"></a>11.19.8. Examples</h4></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2549779"></a>11.19.8.1. Change directory</h5></div></div></div><p>This procedure uses the chdir() system call to set the process's current working directory. The string parameter type is used to pass a Scheme string to the C procedure.</p><pre class="literallayout">(define cd
  (let ((chdir (foreign-procedure "chdir" '(string) 'int)))
    (lambda (newdir)
      (if (not (zero? (chdir newdir)))
      (error "cd: " newdir " is not a valid directory name."))
      (unspecified))))</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2549807"></a>11.19.8.2. Print Working Directory</h5></div></div></div><p>This procedure uses the getcwd() (get current working directory) system call to retrieve the name of the process's current working directory. A bytevector is created and passed in as a buffer in which to store the return value — a 0-terminated ASCII string. Then the FFI utility function ffi/asciiz-&gt;string is called to convert the bytevector to a string.</p><pre class="literallayout">(define pwd
  (let ((getcwd (foreign-procedure "getcwd" '(boxed int) 'int)))
    (lambda ()
      (let ((s (make-bytevector 1024)))
    (getcwd s 1024)
    (ffi/asciiz-&gt;string s)))))</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2549838"></a>11.19.8.3. Quicksort</h5></div></div></div><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>this example is bogus.  It is not safe to pass a collectable
object into a C procedure when the callback invocation might cause a
garbage collection, thus moving the object and invalidating the
address stored in the C machine context.</p></div><p>This demonstrates how to use a callback such as the comparator argument to qsort.
It is specified in the type signature using -&gt; as a type constructor.
(Note that one should probably use the built-in sort routines rather than call out
 like this; this example is for demonstrating callbacks, not how to sort.)</p><pre class="literallayout">(define qsort!
  (foreign-procedure "qsort" '(boxed ushort ushort (-&gt; (void* void*) int)) 'void))</pre><pre class="literallayout">(let ((bv (list-&gt;vector '(40 10 30 20 1 2 3 4))))
  (qsort! bv 8 4
          (lambda (x y)
            (let ((x (/ (void*-word-ref x 0) 4))
                  (y (/ (void*-word-ref y 0) 4)))
              (- x y))))
  bv)</pre><pre class="literallayout">(let ((bv (list-&gt;bytevector '(40 10 30 20 1 2 3 4))))
  (qsort! bv 8 1
          (lambda (x y)
            (let ((x (void*-byte-ref x 0))
                  (y (void*-byte-ref y 0)))
              (- x y))))
  bv)</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2549907"></a>11.19.8.4. Other examples</h5></div></div></div><p>The Experimental directory contains several examples of use of the FFI. See in particular the files unix.sch (Unix system calls) and socket.sch (procedures for communicating over sockets).</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2549922"></a>11.19.9. Higher level layers</h4></div></div></div><p>The general foreign-function interface functionality described above
is powerful but awkward to use in practice.  A user might be tempted
to hard code values of offsets or constants that are compiler
dependent.  Also, the FFI will marshall some low-level values such
as strings or integers, but other values such as enumerations
which could be naturally mapped to sets of symbols are not marshalled
since the host environment does not provide the necessary type
information to the FFI.</p><p>This section documents a collection of libraries to mitigate these and
other problems.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2549947"></a>11.19.9.1. foreign-ctools</h5></div></div></div><p>Foreign data access is performed by peeking at manually calculated
addresses, but in practice one often needs to inspect fields of C
structures, whose offsets are dependant on the application binary
interface (ABI) of the host environment.  Similarly, C programs often
use refer to values via constant macro definitions; since the values
of such names are not provided by the object code and Scheme programs
do not have a C preprocessor run on them prior to execution, it is
difficult to refer to the same value without encoding "magic numbers"
into the Scheme source code.</p><p>The foreign-ctools library is meant to mitigate problems like the two
described above.  It provides special forms for introducing global
definitions of values typically available at compile-time for a C
program.  The library assumes the presence of a C compiler (such as
<span class="emphasis"><em>cc</em></span> on Unix systems or <span class="emphasis"><em>cl.exe</em></span> on Windows systems).  The special
forms work by dynamically generating, compiling, and running C code at
expansion time to determine the desired values of structure offsets or
macro constants.</p><p>Here is a grammar for the <code class="literal">define-c-info</code> form provided by
the <code class="literal">foreign-ctools</code> library.</p><pre class="literallayout">&lt;exp&gt;     ::= (define-c-info &lt;c-decl&gt; ... &lt;c-defn&gt; ...)

&lt;c-decl&gt;  ::= (compiler &lt;cc-spec&gt;)
           |  (path &lt;include-path&gt;)
           |  (include &lt;header&gt;)
           |  (include&lt;&gt; &lt;header&gt;)

&lt;cc-spec&gt; ::= cc | cl

&lt;c-defn&gt;  ::= (const &lt;id&gt; &lt;c-type&gt; &lt;c-expr&gt;)
           |  (sizeof &lt;id&gt; &lt;c-type-expr&gt;)
           |  (struct &lt;c-name&gt; &lt;field-clause&gt; ...)
           |  (fields &lt;c-name&gt; &lt;field-clause&gt; ...)
           |  (ifdefconst &lt;id&gt; &lt;c-type&gt; &lt;c-name&gt;)

&lt;c-type&gt;  ::= int | uint | long | ulong

&lt;include-path&gt;
          ::= &lt;string-literal&gt;

&lt;header&gt;  ::= &lt;string-literal&gt;

&lt;field-clause&gt;
          ::= (&lt;offset-id&gt; &lt;c-field&gt;)
           |  (&lt;offset-id&gt; &lt;c-field&gt; &lt;size-id&gt;)

&lt;c-expr&gt;  ::= &lt;string-literal&gt;

&lt;c-type-expr&gt;
          ::= &lt;string-literal&gt;

&lt;c-name&gt;  ::= &lt;string-literal&gt;

&lt;c-field&gt; ::= &lt;string-literal&gt;</pre><p><span class="emphasis"><em>Syntax define-c-info</em></span></p><p><code class="literal"> (define-c-info &lt;c-decl&gt; … &lt;c-defn&gt; …)</code></p><p>The <code class="literal">&lt;c-decl&gt;</code> clauses of <code class="literal">define-c-info</code>
control how header files are processed.
The <code class="literal">compiler</code> clause selects between <code class="literal">cc</code>
(the default UNIX system compiler) and <code class="literal">cl</code>
(the compiler included with Microsoft's Windows SDK).
The <code class="literal">path</code> clause adds a directory to search when
looking for header files.
The <code class="literal">include</code> and <code class="literal">include&lt;&gt;</code> clauses indicate
header files to include when executing the
<code class="literal">&lt;c-defn&gt;</code> clauses;
the two variants correspond to the quoted and bracketed
forms of the C preprocessor's <code class="literal">#include</code> directive.</p><p>The <code class="literal">&lt;c-defn&gt;</code> clauses bind identifiers.
A <code class="literal">(const <span class="emphasis"><em>x</em></span> <span class="emphasis"><em>t</em></span> "<span class="emphasis"><em>ae</em></span>")</code> clause binds <span class="emphasis"><em>x</em></span> to
the integer value of <span class="emphasis"><em>ae</em></span> according to the C language;
<span class="emphasis"><em>ae</em></span> can be any C arithmetic expression that evaluates
to a value of type <span class="emphasis"><em>t</em></span>.
(The expected usage is for <span class="emphasis"><em>ae</em></span> to be an
expression that the C preprocessor expands to an arithmetic expression.)</p><p>The remaining clauses provide similar functionality:</p><div class="itemizedlist"><ul type="disc"><li>
<code class="literal">(sizeof <span class="emphasis"><em>x</em></span> "<span class="emphasis"><em>te</em></span>")</code>
 binds <span class="emphasis"><em>x</em></span> to the size occupied by values
 of type <span class="emphasis"><em>te</em></span>, where <span class="emphasis"><em>te</em></span> is any C type expression.
</li><li>
<code class="literal">(struct "<span class="emphasis"><em>cn</em></span>" … (<span class="emphasis"><em>x</em></span> "<span class="emphasis"><em>cf</em></span>" <span class="emphasis"><em>y</em></span>) …)</code>
 binds <span class="emphasis"><em>x</em></span> to the offset from the start of a
 structure of type <code class="literal">struct <span class="emphasis"><em>cn</em></span></code> to its
 <span class="emphasis"><em>cf</em></span> field, and binds <span class="emphasis"><em>y</em></span>, if present, to the field's size.
 A <code class="literal">fields</code> clause is similar, but it applies
 to structures of type <code class="literal"><span class="emphasis"><em>cn</em></span></code> rather than <code class="literal">struct <span class="emphasis"><em>cn</em></span></code>.
</li><li>
<code class="literal">(ifdefconst <span class="emphasis"><em>x</em></span> <span class="emphasis"><em>t</em></span> "<span class="emphasis"><em>cn</em></span>")</code>
 binds <span class="emphasis"><em>x</em></span> to the value of <code class="literal"><span class="emphasis"><em>cn</em></span></code> if <code class="literal"><span class="emphasis"><em>cn</em></span></code> is defined;
 <span class="emphasis"><em>x</em></span> is otherwise bound to Larceny's unspecified value.
</li></ul></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2550333"></a>11.19.9.2. foreign-sugar</h5></div></div></div><p>The <a class="xref" href="#foreign-procedure">foreign-procedure</a> function is sufficient to link in
dynamically loaded C procedures, but it can be annoying to
use when there are many procedures to define that all follow
a regular pattern where one could infer a mapping between
Scheme identifiers and C function names.</p><p>For example, some libraries follow a naming convention where a words
within a name are separated by underscores; such functions could be
immediately mapped to Scheme names where the underscores have been
replaced by dashes.</p><p>The foreign-sugar library provides a special form, <code class="literal">define-foreign</code>,
which gives the user a syntax for defining foreign functions using
a syntax where one provides only the Scheme name, the argument types,
and the return type.  The <code class="literal">define-foreign</code> form then attempts to
infer what C function the name was meant to refer to.</p><p><span class="emphasis"><em>Syntax define-foreign</em></span></p><p><code class="literal"> (define-foreign (name arg-type …) result-type)</code></p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>There is other functionality provided allowing the user to
introduce new rules for inferring C function names, but they are
undocumented because they will probably have to change when we switch
to an R6RS macro expander.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2550413"></a>11.19.9.3. foreign-stdlib</h5></div></div></div><p><a id="stdlib/malloc"></a>
<span class="emphasis"><em> Procedure stdlib/malloc</em></span>
<p>
<a id="id2550434" class="indexterm"></a>
<code class="literal">(stdlib/malloc <span class="emphasis"><em>rtd</em></span> <span class="emphasis"><em>[ctor]</em></span>)  =&gt; <span class="emphasis"><em>procedure</em></span></code>
</p></p><p>Given a record extension of <span class="emphasis"><em>void*-rt</em></span>, returns an allocator that uses
the C <code class="literal">malloc</code> procedure to allocate instances of such an object.
Note that the client is responsible for eventually freeing such
objects with <a class="xref" href="#stdlib/free">stdlib/free</a>.</p><p><a id="stdlib/free"></a>
<span class="emphasis"><em> Procedure stdlib/free</em></span>
<p>
<a id="id2550499" class="indexterm"></a>
<code class="literal">(stdlib/free <span class="emphasis"><em>void*-obj</em></span>) </code>
</p></p><p>Frees objects produced by allocators returned from <a class="xref" href="#stdlib/malloc">stdlib/malloc</a>.</p><p><a id="ffi-install-void*-subtype"></a>
<span class="emphasis"><em> Procedure ffi-install-void*-subtype</em></span>
<p>
<a id="id2550545" class="indexterm"></a>
</p>
<p><code class="literal">(ffi-install-void*-subtype <span class="emphasis"><em>rtd</em></span>)  =&gt; <span class="emphasis"><em>rtd</em></span></code></p>
<p><code class="literal">(ffi-install-void*-subtype <span class="emphasis"><em>string</em></span> <span class="emphasis"><em>[parent-rtd]</em></span>)  =&gt; <span class="emphasis"><em>rtd</em></span></code></p>
<p><code class="literal">(ffi-install-void*-subtype <span class="emphasis"><em>symbol</em></span> <span class="emphasis"><em>[parent-rtd]</em></span>)  =&gt; <span class="emphasis"><em>rtd</em></span></code></p></p><p><a class="xref" href="#ffi-install-void*-subtype">ffi-install-void*-subtype</a>
extends the core attribute registry with a new primitive
entry for <span class="emphasis"><em>subtype</em></span>.
The <span class="emphasis"><em>parent-rtd</em></span> argument should be a subtype of <code class="literal">void*-rt</code>
and defaults to <code class="literal">void*-rt</code>.
In the case of the <span class="emphasis"><em>symbol</em></span> or <span class="emphasis"><em>string</em></span> inputs, the
procedure constructs a new record type subtyping the <span class="emphasis"><em>parent</em></span> argument.
In the case of the <span class="emphasis"><em>rtd</em></span> input, the <span class="emphasis"><em>rtd</em></span> record type
must extend <code class="literal">void*-rt</code>.
<a class="xref" href="#ffi-install-void*-subtype">ffi-install-void*-subtype</a> returns the subtype record type.</p><p>The returned record type represents a tagged wrapped C pointer,
allowing one to encode type hierarchies.</p><p><a id="establish-void*-subhierarchy!"></a>
<span class="emphasis"><em> Procedure establish-void*-subhierarchy!</em></span>
<p>
<a id="id2550689" class="indexterm"></a>
<code class="literal">(establish-void*-subhierarchy! <span class="emphasis"><em>symbol-tree</em></span>)  =&gt; <span class="emphasis"><em>unspecified</em></span></code>
</p></p><p><a class="xref" href="#establish-void*-subhierarchy!">establish-void*-subhierarchy!</a> is a convenience function
for constructing large object hierarchies.
It descends the <span class="emphasis"><em>symbol-tree</em></span>,
creates a record type descriptor for each symbol
(where the root of the tree has the parent <code class="literal">void*-rt</code>),
and invokes <a class="xref" href="#ffi-install-void*-subtype">ffi-install-void*-subtype</a> on all
of the introduced types.</p><p><span class="emphasis"><em>Type char*</em></span> extends <span class="emphasis"><em>void*</em></span>
<a id="string-&gt;char*"></a>
<span class="emphasis"><em> Procedure string-&gt;char*</em></span>
<p>
<a id="id2550765" class="indexterm"></a>
<code class="literal">(string-&gt;char* <span class="emphasis"><em>string</em></span>)  =&gt; <span class="emphasis"><em>char*</em></span></code>
</p>
<a id="char*-strlen"></a>
<span class="emphasis"><em> Procedure char*-strlen</em></span>
<p>
<a id="id2550800" class="indexterm"></a>
<code class="literal">(char*-strlen <span class="emphasis"><em>char*</em></span>)  =&gt; <span class="emphasis"><em>fixnum</em></span></code>
</p>
<a id="char*-&gt;string"></a>
<span class="emphasis"><em> Procedure char*-&gt;string</em></span>
<p>
<a id="id2550836" class="indexterm"></a>
<code class="literal">(char*-&gt;string <span class="emphasis"><em>char*</em></span>)  =&gt; <span class="emphasis"><em>string</em></span></code>
</p>
<p><code class="literal">(char*-&gt;string <span class="emphasis"><em>char* len</em></span>)  =&gt; <span class="emphasis"><em>string</em></span></code></p>
<a id="CallWithCharStar"></a>
<span class="emphasis"><em> Procedure call-with-char*</em></span>
<p>
<a id="id2550884" class="indexterm"></a>
<code class="literal">(call-with-char* <span class="emphasis"><em>string string-function</em></span>)  =&gt; <span class="emphasis"><em>value</em></span></code>
</p>
<span class="emphasis"><em>Type char**</em></span> extends <span class="emphasis"><em>void*</em></span>
<a id="CallWithCharStarStar"></a>
<span class="emphasis"><em> Procedure call-with-char**</em></span>
<p>
<a id="id2550928" class="indexterm"></a>
<code class="literal">(call-with-char** <span class="emphasis"><em>string-vector function</em></span>)  =&gt; <span class="emphasis"><em>value</em></span></code>
</p>
<span class="emphasis"><em>Type int*</em></span> extends <span class="emphasis"><em>void*</em></span>
<a id="CallWithIntStar"></a>
<span class="emphasis"><em> Procedure call-with-int*</em></span>
<p>
<a id="id2550971" class="indexterm"></a>
<code class="literal">(call-with-int* <span class="emphasis"><em>fixnum-vector function</em></span>)  =&gt; <span class="emphasis"><em>value</em></span></code>
</p>
<span class="emphasis"><em>Type short*</em></span> extends <span class="emphasis"><em>void*</em></span>
<a id="CallWithShortStar"></a>
<span class="emphasis"><em> Procedure call-with-short*</em></span>
<p>
<a id="id2551013" class="indexterm"></a>
<code class="literal">(call-with-short* <span class="emphasis"><em>fixnum-vector function</em></span>)  =&gt; <span class="emphasis"><em>value</em></span></code>
</p>
<span class="emphasis"><em>Type double*</em></span> extends <span class="emphasis"><em>void*</em></span>
<a id="CallWithDoubleStar"></a>
<span class="emphasis"><em> Procedure call-with-double*</em></span>
<p>
<a id="id2551055" class="indexterm"></a>
<code class="literal">(call-with-double* <span class="emphasis"><em>num-vector function</em></span>)  =&gt; <span class="emphasis"><em>value</em></span></code>
</p></p><p>FIXME: (There are other functions, but I want to test and document the
ones above first…)</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2551084"></a>11.19.9.4. foreign-cstructs</h5></div></div></div><p>The <code class="literal">foreign-cstructs</code> library provides a
more direct interface to C structures.
It provides the <code class="literal">define-c-struct</code> special form.
This form is layered on top of <code class="literal">define-c-info</code>;
the latter provides the structure field offsets
and sizes used to generate constructors
(which produce appropriately sized bytevectors,
not record instances).
The <code class="literal">define-c-struct</code> form combines these
with marshaling and unmarshaling procedures to
provide high-level access to a structure.</p><p>The grammar for the <code class="literal">define-c-struct</code> form is presented below.</p><pre class="literallayout">&lt;exp&gt;    ::= (define-c-struct (&lt;struct-type&gt; &lt;ctor-id&gt; &lt;c-decl&gt; ...)
                &lt;field-clause&gt; ...)

&lt;field-clause&gt;
         ::= (&lt;c-field&gt; &lt;getter&gt;) | (&lt;c-field&gt; &lt;getter&gt; &lt;setter&gt;)

&lt;getter&gt; ::= (&lt;id&gt;) | (&lt;id&gt; &lt;unmarshal&gt;)

&lt;setter&gt; ::= (&lt;id&gt;) | (&lt;id&gt; &lt;marshal&gt;)

&lt;marshal&gt; ::= &lt;ffi-attr-symbol&gt; | &lt;marshal-proc-exp&gt;

&lt;unmarshal&gt; ::= &lt;ffi-attr-symbol&gt; | &lt;unmarshal-proc-exp&gt;

&lt;struct-type&gt; ::= &lt;string-literal&gt;</pre></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="id2551160"></a>11.19.9.5. foreign-cenums</h5></div></div></div><p>This library provides the special forms
 <code class="literal">define-c-enum</code> and <code class="literal">define-c-enum-set</code>,
which associate the identifiers of
a C <code class="literal">enum</code> type declaration
with the integer values they denote.</p><p>The <code class="literal">define-c-enum</code> form describes enums
encoding a discriminated sum;
<code class="literal">define-c-enum-set</code> describes bitmasks,
mapping them to R<sup>6</sup>RS enum-sets in Scheme.</p><p>The <code class="literal">(define-c-enum <span class="emphasis"><em>en</em></span> (&lt;c-decl&gt; …)  (<span class="emphasis"><em>x</em></span> "<span class="emphasis"><em>cn</em></span>") …)</code>
form adds the <code class="literal"><span class="emphasis"><em>en</em></span></code> FFI attribute.
The attribute marshals each symbol <code class="literal"><span class="emphasis"><em>x</em></span></code> to
the integer value that <code class="literal"><span class="emphasis"><em>cn</em></span></code> denotes in C;
unmarshaling does the inverse translation.</p><p>The <code class="literal">(define-c-enum-set <span class="emphasis"><em>ens</em></span> (&lt;c-decl&gt; …) (<span class="emphasis"><em>x</em></span> "<span class="emphasis"><em>cn</em></span>") …)</code>
form binds <span class="emphasis"><em>ens</em></span> to an R<sup>6</sup>RS enum-set constructor
with universe resulting from
<code class="literal">(make-enumeration '(<span class="emphasis"><em>x</em></span> …))</code>; it also adds the <code class="literal"><span class="emphasis"><em>ens</em></span></code>
FFI attribute.  The attribute marshals an
enum-set <span class="emphasis"><em>s</em></span> constructed by <span class="emphasis"><em>ens</em></span>
to the corresponding bitmask in C (that is,
the integer one would get by logically or'ing
all <span class="emphasis"><em>cn</em></span> such that the corresponding <span class="emphasis"><em>x</em></span> is in <span class="emphasis"><em>s</em></span>).
Unmarshaling attempts to do the inverse translation.</p><p>The grammar for the two forms is presented below.</p><pre class="literallayout">&lt;exp&gt; ::= (define-c-enum &lt;enum-id&gt; (&lt;c-decl&gt; ...)
            (&lt;id&gt; &lt;c-name&gt;) ...)

&lt;exp&gt; ::= (define-c-enum-set &lt;enum-id&gt; (&lt;c-decl&gt; ...)
            (&lt;id&gt; &lt;c-name&gt;) ...)

&lt;enum-id&gt; ::= &lt;id&gt;</pre></div></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2551351"></a>12. Debugging</h2></div></div></div><p>Larceny's debugging functionality is implemented in Scheme, using some
of Larceny's extensions for catching exceptions and inspecting the
continuation structure.</p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2551365"></a>12.1. Entering the debugger</h3></div></div></div><p>When Larceny detects an error or a keyboard interrupt, or when it hits
a breakpoint, it signals the condition by printing a message on the
console. Larceny then enters the debugger, which signals its presence
with a short banner and the debugger prompt:</p><pre class="literallayout">Entering debugger; type "?" for help.
debug&gt;</pre><p>You can also re-enter the debugger by evaluating (debug).</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2551394"></a>12.2. Debugger commands</h3></div></div></div><p>The debugger is still in an immature state. The following commands are available (commands can be typed in upper or lower case):</p><p><span class="strong"><strong>B</strong></span>     Print backtrace of continuation.</p><p><span class="strong"><strong>C</strong></span>     Print source code of procedure, if available.</p><p><span class="strong"><strong>D</strong></span>     Move down to previous (earlier) activation record.</p><p><span class="strong"><strong>E <span class="emphasis"><em>n expr</em></span></strong></span>      <span class="emphasis"><em>Expr</em></span> is evaluated in the current
interaction environment and must evaluate to a procedure.
It is passed the contents of slot <span class="emphasis"><em>n</em></span> from the current
activation record, and the result, if not unspecified,
is printed.</p><p><span class="strong"><strong>E <span class="emphasis"><em>(n1 … nk) expr</em></span></strong></span>      <span class="emphasis"><em>Expr</em></span> is evaluated in the current
interaction environment and must evaluate to a procedure. It is
passed the contents of slots <span class="emphasis"><em>n1</em></span> through <span class="emphasis"><em>nk</em></span> from the current
activation record, and the result, if not unspecified, is printed.</p><p><span class="strong"><strong>I <span class="emphasis"><em>n</em></span></strong></span>      Inspect the procedure in slot <span class="emphasis"><em>n</em></span> of the current
activation record.</p><p><span class="strong"><strong>I @_</strong></span>      Inspect the active procedure.</p><p><span class="strong"><strong>Q</strong></span>      Quit the debugger and abort the computation.</p><p><span class="strong"><strong>R</strong></span>      Return from the debugger and continue the computation.</p><p><span class="strong"><strong>S</strong></span>      Summarize the contents of the current activation record.</p><p><span class="strong"><strong>U</strong></span>      Up to the next (later) activation record.</p><p><span class="strong"><strong>X</strong></span>      Examine the contents of the current activation record.</p><p>The <span class="strong"><strong>B</strong></span>, <span class="strong"><strong>D</strong></span>, and <span class="strong"><strong>U</strong></span> commands can be prefixed with a count, for example, 5 U moves up five activation records, and 10 B displays the next 10 activation records. The default for <span class="strong"><strong>B</strong></span> is to display all the activations; the default count for <span class="strong"><strong>D</strong></span> and <span class="strong"><strong>U</strong></span> is 1.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2551595"></a>12.3. Breakpoints</h3></div></div></div><p>You can set breakpoints either in program text with the break primitive or interactively at the start of a procedure with the break-entry procedure. When Larceny reaches a breakpoint during execution, the program is suspended and the debugger is entered to allow you to inspect the program.</p><p><a id="larceny-break"></a>
<span class="emphasis"><em> Procedure larceny-break</em></span>
<p>
<a id="id2551624" class="indexterm"></a>
<code class="literal">(larceny-break <span class="emphasis"><em></em></span>) </code>
</p></p><p>Invokes the breakpoint handler.</p><p><a id="break-entry"></a>
<span class="emphasis"><em> Procedure break-entry</em></span>
<p>
<a id="id2551661" class="indexterm"></a>
<code class="literal">(break-entry <span class="emphasis"><em>procedure</em></span>) </code>
</p></p><p>Set a breakpoint at the start of the <span class="emphasis"><em>procedure</em></span>.</p><p><a id="unbreak"></a>
<span class="emphasis"><em> Procedure unbreak</em></span>
<p>
<a id="id2551702" class="indexterm"></a>
<code class="literal">(unbreak <span class="emphasis"><em>procedure …</em></span>) </code>
</p></p><p><p><code class="literal">(unbreak <span class="emphasis"><em></em></span>) </code></p></p><p>In the first form, remove any breakpoint set by break-entry at the start of the <span class="emphasis"><em>procedure_s. In the second form, remove all breakpoints set by _break-entry</em></span>.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2551742"></a>12.4. Tracing</h3></div></div></div><p><a id="trace-entry"></a>
<span class="emphasis"><em> Procedure trace-entry</em></span>
<p>
<a id="id2551762" class="indexterm"></a>
<code class="literal">(trace-entry <span class="emphasis"><em>procedure</em></span>) </code>
</p></p><p>Set a trace point on entry to the <span class="emphasis"><em>procedure</em></span>, removing any other trace points on the procedure. When the <span class="emphasis"><em>procedure</em></span> is entered, information about the call is printed on the console: the name of the procedure and the actual arguments.</p><p><a id="trace-exit"></a>
<span class="emphasis"><em> Procedure trace-exit</em></span>
<p>
<a id="id2551810" class="indexterm"></a>
<code class="literal">(trace-exit <span class="emphasis"><em>procedure</em></span>) </code>
</p></p><p>Set a trace point on exit from the <span class="emphasis"><em>procedure</em></span>, removing any other trace points on the procedure. When the <span class="emphasis"><em>procedure</em></span> returns, information about the return is printed on the console: the name of the procedure and the returned values.</p><p>Note that trace-exit destroys the tail recursion properties of the instrumented procedure. Where the <span class="emphasis"><em>procedure</em></span> would normally "return" by tail-calling another procedure, the instrumented procedure will call the other procedure by a non-tail call and then return, at which point the procedure name and return values will be printed. Thus use of trace-exit may destroy the space properties of the program.</p><p><a id="trace"></a>
<span class="emphasis"><em> Procedure trace</em></span>
<p>
<a id="id2551877" class="indexterm"></a>
<code class="literal">(trace <span class="emphasis"><em>procedure</em></span>) </code>
</p></p><p>Set trace points on <span class="emphasis"><em>procedure</em></span> both at entry and exit.</p><p><a id="untrace"></a>
<span class="emphasis"><em> Procedure untrace</em></span>
<p>
<a id="id2551918" class="indexterm"></a>
<code class="literal">(untrace <span class="emphasis"><em>procedure …</em></span>) </code>
</p></p><p><p><code class="literal">(untrace <span class="emphasis"><em></em></span>) </code></p></p><p>The first form removes any trace points from the specified procedures.
The second form removes all untrace points.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2551956"></a>12.5. Other functionality</h3></div></div></div><p><a id="break-handler"></a>
<a id="id2551971" class="indexterm"></a>
<span class="emphasis"><em>Parameter break-handler</em></span></p><p>The value of break-handler is a procedure that is called when a breakpoint or tracepoint is encountered. The procedure takes two arguments: the procedure in which the breakpoint was set, and the byte offset within the procedure's code vector of the breakpoint.</p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Standards"></a>13. Standards</h2></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2552003"></a>13.1. Scheme standards</h3></div></div></div><p>IEEE Standard 1178-1990,
"IEEE Standard for the Scheme Programming Language",
IEEE, 1991. ISBN 1-55937-125-0.
May be ordered from IEEE by calling 1-800-678-IEEE or 908-981-1393
or writing
IEEE Service Center, 445 Hoes Lane, P.O. Box 1331,
Piscataway, NJ 08855-1331, and using order number SH14209.</p><p>Richard Kelsey, William Clinger, and Jonathan Rees [editors].
<a class="ulink" href="http://www.brics.dk/~hosc/11-1/" target="_top">Revised^5 Report
on the Algorithmic Language Scheme</a>.
<span class="emphasis"><em>Journal of Higher Order and Symbolic Computation</em></span>,
11(1), 1998, pages 7-105.
Also appears in <span class="emphasis"><em>ACM SIGPLAN Notices</em></span> 33(9), September 1998.
Available online
<a class="ulink" href="http://www.schemers.org/Documents/Standards/R5RS/" target="_top">in various formats</a>.</p><p>Michael Sperber, R Kent Dybvig, Matthew Flatt, and Anton van Straaten
[editors].
<a class="ulink" href="http://www.r6rs.org/" target="_top">Revised^6 Report
on the Algorithmic Language Scheme</a>, 2007.</p><p>Alex Shinn, John Cowan, and Arthur A Gleckler [editors].
<a class="ulink" href="http://www.scheme-reports.org/" target="_top">Revised^7 Report
on the Algorithmic Language Scheme</a>, 2013.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2552079"></a>13.2. Other relevant standards</h3></div></div></div><p>IEEE Standard 754-1985,
"IEEE Standard for Binary Floating-Point Arithmetic",
IEEE, 1985.</p><p>IEEE Standard 754-2008,
"IEEE Standard for Floating-Point Arithmetic",
IEEE, 2008.
(<a class="ulink" href="http://en.wikipedia.org/wiki/IEEE_754r" target="_top">Revision of IEEE Std 754-1985</a>
began in 2000.
The IEEE Microprocessor Standards Committee (MSC)
accepted a candidate draft on 9 October 2006.
The candidate draft 1.2.6 was approved by 79% of 70 votes,
which exceeded the required supermajority of 75%.
Because there were negative votes and several hundred comments,
however, a revised draft 1.3.0 was prepared and approved by
84% of 73 votes.
Since there were over a hundred comments on the
second candidate draft as well, a third candidate draft 1.4.0 was
prepared and another vote taken in April 2007.
After a total of eight ballots, with the last four being
approved by more than 90% of the voters, the Ballot Review
Committee decided in May 2008 that
<a class="ulink" href="http://www.validlab.com/754R/" target="_top">maximum possible timely
consensus has been obtained</a>, and the consensus draft was
submitted to IEEE-SA RevCom.
IEEE-754-2008 was approved on 12 June 2008.)</p><p>The Unicode Consortium.
<a class="ulink" href="http://www.unicode.org/" target="_top">The Unicode Standard</a>.</p></div></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a id="id2552140"></a>Index</h2></div></div></div><div class="index"><div class="indexdiv"><h3>A</h3><dl><dt>append!, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt></dl></div><div class="indexdiv"><h3>B</h3><dl><dt>break-entry, <a class="indexterm" href="#id2551595">Breakpoints</a></dt><dt>break-handler, <a class="indexterm" href="#id2551956">Other functionality</a></dt></dl></div><div class="indexdiv"><h3>C</h3><dl><dt>call-with-char*, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>call-with-char**, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>call-with-double*, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>call-with-int*, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>call-with-short*, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>case-sensitive?, <a class="indexterm" href="#LexicalParametersSection">Lexical parameters</a></dt><dt>char*-&gt;string, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>char*-strlen, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>close-open-files, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>collect, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt><dt>command-line-arguments, <a class="indexterm" href="#id2541215">Operating System Interface</a></dt><dt>compile-file, <a class="indexterm" href="#CompilingR5rsSection">Compiling R5RS source files</a></dt><dt>compile-library, <a class="indexterm" href="#LarcenyCompilerSection">Compiler</a></dt><dt>compile-stale-libraries, <a class="indexterm" href="#LarcenyCompilerSection">Compiler</a></dt><dt>compiler-switches, <a class="indexterm" href="#LarcenyCompilerSection">Compiler</a></dt><dt>console-input-port, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>console-input-port-factory, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>console-output-port, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>console-output-port-factory, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>current-input-port, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>current-output-port, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>current-require-path, <a class="indexterm" href="#RequireLibraryTranslationSection">Mapping library names to files (R5RS)</a></dt></dl></div><div class="indexdiv"><h3>D</h3><dl><dt>delete-file, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>display-memstats, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt><dt>dump-heap, <a class="indexterm" href="#id2541215">Operating System Interface</a></dt><dt>dump-interactive-heap, <a class="indexterm" href="#id2541215">Operating System Interface</a></dt></dl></div><div class="indexdiv"><h3>E</h3><dl><dt>eof-object, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>equal-hash, <a class="indexterm" href="#id2543609">Hash functions</a></dt><dt>establish-void*-subhierarchy!, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>every?, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt></dl></div><div class="indexdiv"><h3>F</h3><dl><dt>ffi-add-attribute-core-entry!, <a class="indexterm" href="#id2547444">Extending the Core Attribute Registry</a></dt><dt>ffi-install-void*-subtype, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>file-exists?, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>file-modification-time, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>fixnum?, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>flush-output-port, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>foreign-file, <a class="indexterm" href="#id2548442">Procedures</a></dt><dt>foreign-null-pointer, <a class="indexterm" href="#id2548442">Procedures</a></dt><dt>foreign-null-pointer?, <a class="indexterm" href="#id2548442">Procedures</a></dt><dt>foreign-procedure, <a class="indexterm" href="#id2548442">Procedures</a></dt><dt>fx*, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fx+, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fx-, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fx&lt;, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fx&lt;=, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fx=, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fx&gt;, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fx&gt;=, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fxlogand, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fxlogior, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fxlognot, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fxlogxor, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fxlsh, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fxnegative?, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fxpositive?, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fxrsha, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fxrshl, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fxzero?, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>fx—, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt></dl></div><div class="indexdiv"><h3>G</h3><dl><dt>gc-counter, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt><dt>gcctl, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt><dt>gensym, <a class="indexterm" href="#id2544582">Symbols</a></dt><dt>get-output-string, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>getenv, <a class="indexterm" href="#id2541215">Operating System Interface</a></dt><dt>getprop, <a class="indexterm" href="#id2544388">Property Lists</a></dt></dl></div><div class="indexdiv"><h3>H</h3><dl><dt>hashtable-clear!, <a class="indexterm" href="#id2542931">Hash tables</a></dt><dt>hashtable-contains?, <a class="indexterm" href="#id2542931">Hash tables</a></dt><dt>hashtable-copy, <a class="indexterm" href="#id2542931">Hash tables</a></dt><dt>hashtable-fetch, <a class="indexterm" href="#id2542931">Hash tables</a></dt><dt>hashtable-for-each, <a class="indexterm" href="#id2542931">Hash tables</a></dt><dt>hashtable-get, <a class="indexterm" href="#id2542931">Hash tables</a></dt><dt>hashtable-map, <a class="indexterm" href="#id2542931">Hash tables</a></dt><dt>hashtable-put!, <a class="indexterm" href="#id2542931">Hash tables</a></dt><dt>hashtable-remove!, <a class="indexterm" href="#id2542931">Hash tables</a></dt><dt>hashtable-size, <a class="indexterm" href="#id2542931">Hash tables</a></dt></dl></div><div class="indexdiv"><h3>L</h3><dl><dt>larceny-break, <a class="indexterm" href="#id2551595">Breakpoints</a></dt><dt>last-pair, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>list-copy, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>load, <a class="indexterm" href="#Err5rsLoadSection">Load</a></dt></dl></div><div class="indexdiv"><h3>M</h3><dl><dt>major-gc-counter, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt><dt>make-bytevector, <a class="indexterm" href="#id2537611">Bytevectors</a></dt><dt>make-oldstyle-hashtable, <a class="indexterm" href="#id2542931">Hash tables</a></dt><dt>make-parameter, <a class="indexterm" href="#id2543843">Parameters</a></dt><dt>make-record-type, <a class="indexterm" href="#id2539478">Specification</a></dt><dt>make-rtd, <a class="indexterm" href="#Err5rsRecordsProceduralSection">Procedural layer</a></dt><dt>memstats, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt><dt>most-negative-fixnum, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt><dt>most-positive-fixnum, <a class="indexterm" href="#FixnumPrimitives">Fixnum primitives</a></dt></dl></div><div class="indexdiv"><h3>O</h3><dl><dt>object-hash, <a class="indexterm" href="#id2543609">Hash functions</a></dt><dt>oblist, <a class="indexterm" href="#id2544582">Symbols</a></dt><dt>oblist-set!, <a class="indexterm" href="#id2544582">Symbols</a></dt><dt>open-input-string, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>open-output-string, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt></dl></div><div class="indexdiv"><h3>P</h3><dl><dt>peek-bytes, <a class="indexterm" href="#id2548718">Raw memory access</a></dt><dt>poke-bytes, <a class="indexterm" href="#id2548718">Raw memory access</a></dt><dt>port-name, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>port-position, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>port?, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>procedure-arity, <a class="indexterm" href="#id2538061">Procedures</a></dt><dt>procedure-copy, <a class="indexterm" href="#id2538061">Procedures</a></dt><dt>procedure-documentation-string, <a class="indexterm" href="#id2538061">Procedures</a></dt><dt>procedure-environment, <a class="indexterm" href="#id2538061">Procedures</a></dt><dt>procedure-expression, <a class="indexterm" href="#id2538061">Procedures</a></dt><dt>procedure-name, <a class="indexterm" href="#id2538061">Procedures</a></dt><dt>procedure-source-file, <a class="indexterm" href="#id2538061">Procedures</a></dt><dt>procedure-source-position, <a class="indexterm" href="#id2538061">Procedures</a></dt><dt>putprop, <a class="indexterm" href="#id2544388">Property Lists</a></dt></dl></div><div class="indexdiv"><h3>R</h3><dl><dt>random, <a class="indexterm" href="#id2542695">Numbers</a></dt><dt>read-larceny-weirdness?, <a class="indexterm" href="#LexicalParametersSection">Lexical parameters</a></dt><dt>read-r6rs-flags?, <a class="indexterm" href="#LexicalParametersSection">Lexical parameters</a></dt><dt>read-r6rs-weirdness?, <a class="indexterm" href="#LexicalParametersSection">Lexical parameters</a></dt><dt>read-r7rs-weirdness?, <a class="indexterm" href="#LexicalParametersSection">Lexical parameters</a></dt><dt>read-traditional-weirdness?, <a class="indexterm" href="#LexicalParametersSection">Lexical parameters</a></dt><dt>record-accessor, <a class="indexterm" href="#id2539478">Specification</a></dt><dt>record-constructor, <a class="indexterm" href="#id2539478">Specification</a></dt><dt>record-predicate, <a class="indexterm" href="#id2539478">Specification</a></dt><dt>record-rtd, <a class="indexterm" href="#Err5rsRecordsInspectionSection">Inspection layer</a></dt><dt>record-type-descriptor, <a class="indexterm" href="#id2539478">Specification</a></dt><dt>record-type-extends?, <a class="indexterm" href="#id2539478">Specification</a></dt><dt>record-type-field-names, <a class="indexterm" href="#id2539478">Specification</a></dt><dt>record-type-name, <a class="indexterm" href="#id2539478">Specification</a></dt><dt>record-type-parent, <a class="indexterm" href="#id2539478">Specification</a></dt><dt>record-updater, <a class="indexterm" href="#id2539478">Specification</a></dt><dt>record?, <a class="indexterm" href="#Err5rsRecordsInspectionSection">Inspection layer</a></dt><dt>remove, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>remove!, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>remp, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>remp!, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>remprop, <a class="indexterm" href="#id2544388">Property Lists</a></dt><dt>remq, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>remq!, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>remv, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>remv!, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>rename-file, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>require, <a class="indexterm" href="#RequireLibraryTranslationSection">Mapping library names to files (R5RS)</a></dt><dt>reset-output-string, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>reverse!, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>rtd-accessor, <a class="indexterm" href="#Err5rsRecordsProceduralSection">Procedural layer</a></dt><dt>rtd-all-field-names, <a class="indexterm" href="#Err5rsRecordsInspectionSection">Inspection layer</a></dt><dt>rtd-constructor, <a class="indexterm" href="#Err5rsRecordsProceduralSection">Procedural layer</a></dt><dt>rtd-field-mutable?, <a class="indexterm" href="#Err5rsRecordsInspectionSection">Inspection layer</a></dt><dt>rtd-field-names, <a class="indexterm" href="#Err5rsRecordsInspectionSection">Inspection layer</a></dt><dt>rtd-mutator, <a class="indexterm" href="#Err5rsRecordsProceduralSection">Procedural layer</a></dt><dt>rtd-name, <a class="indexterm" href="#Err5rsRecordsInspectionSection">Inspection layer</a></dt><dt>rtd-parent, <a class="indexterm" href="#Err5rsRecordsInspectionSection">Inspection layer</a></dt><dt>rtd-predicate, <a class="indexterm" href="#Err5rsRecordsProceduralSection">Procedural layer</a></dt><dt>rtd-printer, <a class="indexterm" href="#RecordsPrinterSection">Records printer</a></dt><dt>rtd-printer-set!, <a class="indexterm" href="#RecordsPrinterSection">Records printer</a></dt><dt>rtd?, <a class="indexterm" href="#Err5rsRecordsProceduralSection">Procedural layer</a></dt><dt>run-benchmark, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt><dt>run-with-stats, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt></dl></div><div class="indexdiv"><h3>S</h3><dl><dt>setenv, <a class="indexterm" href="#id2541215">Operating System Interface</a></dt><dt>some?, <a class="indexterm" href="#id2538610">Pairs and Lists</a></dt><dt>sro, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt><dt>stats-dump-off, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt><dt>stats-dump-on, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt><dt>stdlib/free, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>stdlib/malloc, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>string-&gt;char*, <a class="indexterm" href="#id2550413">foreign-stdlib</a></dt><dt>string-hash, <a class="indexterm" href="#id2543609">Hash functions</a></dt><dt>symbol-hash, <a class="indexterm" href="#id2543609">Hash functions</a></dt><dt>system, <a class="indexterm" href="#id2541215">Operating System Interface</a></dt><dt>system-features, <a class="indexterm" href="#id2544757">System Control and Performance Measurement</a></dt></dl></div><div class="indexdiv"><h3>T</h3><dl><dt>trace, <a class="indexterm" href="#id2551742">Tracing</a></dt><dt>trace-entry, <a class="indexterm" href="#id2551742">Tracing</a></dt><dt>trace-exit, <a class="indexterm" href="#id2551742">Tracing</a></dt></dl></div><div class="indexdiv"><h3>U</h3><dl><dt>unbreak, <a class="indexterm" href="#id2551595">Breakpoints</a></dt><dt>untrace, <a class="indexterm" href="#id2551742">Tracing</a></dt></dl></div><div class="indexdiv"><h3>V</h3><dl><dt>vector-copy, <a class="indexterm" href="#id2537942">Vectors</a></dt><dt>void*-&gt;address, <a class="indexterm" href="#id2547812">void* Type Hierarchies</a></dt><dt>void*-byte-ref, <a class="indexterm" href="#id2547812">void* Type Hierarchies</a></dt><dt>void*-byte-set!, <a class="indexterm" href="#id2547812">void* Type Hierarchies</a></dt><dt>void*-double-ref, <a class="indexterm" href="#id2547812">void* Type Hierarchies</a></dt><dt>void*-double-set!, <a class="indexterm" href="#id2547812">void* Type Hierarchies</a></dt><dt>void*-void*-ref, <a class="indexterm" href="#id2547812">void* Type Hierarchies</a></dt><dt>void*-void*-set!, <a class="indexterm" href="#id2547812">void* Type Hierarchies</a></dt><dt>void*-word-ref, <a class="indexterm" href="#id2547812">void* Type Hierarchies</a></dt><dt>void*-word-set!, <a class="indexterm" href="#id2547812">void* Type Hierarchies</a></dt><dt>void*?, <a class="indexterm" href="#id2547812">void* Type Hierarchies</a></dt></dl></div><div class="indexdiv"><h3>W</h3><dl><dt>with-input-from-port, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt><dt>with-output-to-port, <a class="indexterm" href="#id2540153">Input, Output, and Files</a></dt></dl></div></div></div></div></body></html>
