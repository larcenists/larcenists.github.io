<html>
<title>
Notes on the Kernighan and Van Wyk benchmarks.
</title>

<body>

<p>
<h2>Notes on the Kernighan and Van Wyk Benchmarks</h2>

<p>
I used the
<a href="source.html">source code</a>
as supplied by Kernighan and Van Wyk,
except for a few minor bug fixes in 
<code><a href="array1.txt">array1.scm</a></code>,
<code><a href="assoc.txt">assoc.scm</a></code>, and
<code><a href="tail.txt">tail.scm</a></code>.

<p>
Since these benchmarks were written to test scripting languages,
I generally compiled them using safe compiler options and
unlimited precision generic arithmetic.

<p>
C code is inherently unsafe, however, so I also benchmarked the
unsafe code that can be generated by Gambit-C and by Chez Scheme.

<p>
Scheme48 supports generic arithmetic, but not unlimited precision
arithmetic.
It does not support floating point arithmetic, either, but uses
rational arithmetic instead.

<p>
<hr>

<p>
<h3><a name="sumloop1000000"><a href="sumloop.txt">sumloop</a> 1000000</a></h3>
This benchmark was intended to test looping and arithmetic,
but it performs one million assignments to a global variable.
In Larceny and Chez Scheme this benchmark therefore
becomes a test of the garbage collector's write barrier.
The <code>no-wb</code> line shows the timing for Larceny
with the write barrier turned off.

<p>
<h3><a name="ack"><a href="ack.txt">ack</a>(3,8)</a></h3>
One of the two recursive calls in the code for the
Ackermann function is tail-recursive, so Scheme ought to perform
much better than C on this benchmark.

<p>
<h3><a name="array1"><a href="array1.txt">array1</a> 200000</a></h3>
This benchmark allocates and destructively initializes two fairly
large one-dimensional arrays.

<p>
Larceny allocates both arrays in the youngest generation, but they
do not both fit there, so the garbage collector has to copy the
first into an older generation before allocating the second.  This
copying accounts for over half of the faster time shown for Larceny.
A more recent version of Larceny deals with large objects more
efficiently.

<p>
<h3><a name="string500000"><a href="string.txt">string</a> 500000</a></h3>
This tests nothing but <code>string-append</code> and
<code>substring</code>.  If these standard procedures are
implemented efficiently, then interpreted implementations
such as MIT Scheme can perform very well on this benchmark.

<p>
I have not been able to get Java to run this benchmark without
overflowing its string space.

<p>
<h3><a name="cat"><a href="cat.txt">cat</a></a></h3>
This file-copying benchmark is a simple test of character i/o.

<p>
<h3><a name="wc"><a href="wc.txt">wc</a></a></h3>
Another character i/o benchmark.

<p>
<h3><a name="tail"><a href="tail.txt">tail</a></a></h3>
This benchmark performs considerable character i/o, but it
also allocates storage very rapidly.
About 95% of the allocated storage becomes garbage almost
immediately, but the other 5% survives to the end of the
benchmark.
With the generational garbage collectors used in Larceny and
Chez Scheme, garbage collection accounts for less than 10%
of the cpu time, so this too is primarily an i/o benchmark.

<p>
<h3><a name="sum1"><a href="sum1.txt">sum1</a></a></h3>
This benchmark reads and sums 100,000 floating point numbers.
Several implementations of Scheme use my code for reading floating
point numbers with the best possible accuracy.  Chez Scheme uses a
more efficient version of that algorithm.
Scheme48 is slow on this benchmark because it uses
rational arithmetic instead of floating point.

<p>
<hr>

<p>
Last updated 15 February 1999.

</body>
</html>
